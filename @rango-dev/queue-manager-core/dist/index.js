var x=Object.defineProperty;var o=(c,t)=>x(c,"name",{value:t,configurable:!0});import{v4 as E}from"uuid";var f="queues-manager",r="queues";var d=class{constructor(){this.db=import("idb").then(async t=>t.openDB(f,1,{upgrade(e){e.createObjectStore(r,{keyPath:"id"})}})).catch(()=>{throw new Error("Couldn't load idb.")})}async insertQueue(t){let e=await this.db;await e.get(r,t.id)||await e.add(r,t)}async updateQueue(t,e){let s=await this.db,a=await s.get(r,t);if(!a)return;let i={...a,...e};await s.put(r,i)}async getAll(){return await(await this.db).getAll(r)}async deleteQueue(t){let e=await this.db;await e.get(r,t)&&await e.delete(r,t)}};o(d,"Persistor");var l=d;import{v4 as Q}from"uuid";var p=(n=>(n.PENDING="PENDING",n.RUNNING="RUNNING",n.FAILED="FAILED",n.SUCCESS="SUCCESS",n.CANCELED="CANCELED",n.BLOCKED="BLOCKED",n))(p||{}),S=5e3;var h=class{constructor(t){this.state={status:"PENDING",activeTaskIndex:0,tasks:{}};this.tasks=[];this.storage={};this.id=t.id,this.events=t.events,this.actions=t.actions}updateQueueStatus(t){this.state.status=t,this.events.onUpdateListStatus(t)}updateActiveTaskIndex(t){this.state.activeTaskIndex=t}updateTaskState(t,e){e.status&&(this.state.tasks[t].status=e.status),e.blockedFor&&(this.state.tasks[t].blockedFor=e.blockedFor);let s={id:t,task:this.get(t),action:this.tasks.find(a=>a.id===t).action};this.events.onUpdate(s)}createTask(t){let e=Q();this.tasks.push({action:t,id:e}),this.state.tasks[e]={status:"PENDING",blockedFor:null};let s=this.get(e);this.events.onCreate({id:e,task:s,action:t})}initTasks(t){this.state=t.state,this.storage=t.storage,t.tasks.forEach(e=>{this.tasks.push(e);let s=this.tasks.find(a=>a.id===e.id).action;this.events.onCreate({id:e.id,task:this.get(e.id),action:s})})}checkBlock(){let t=this.getActiveTask();if(!t)return;let{task:e,state:s}=t;s.status==="BLOCKED"&&this.events.onBlock({action:e.action,id:e.id,reason:s.blockedFor})}get(t){let e=this.state.tasks[t];return e||null}lastTaskIsSuccessful(){let t=this.tasks[this.tasks.length-1];if(t){let e=this.state.tasks[t.id];if(e&&e.status==="SUCCESS")return!0}return!1}firstTaskIsStarted(){let t=this.tasks[0];if(t){let e=this.state.tasks[t.id];if(e&&e.status!=="PENDING")return!0}return!1}getActiveTask(){let t=this.state.activeTaskIndex,e=this.tasks[t];if(!e)return null;let s=this.state.tasks[e.id];return{task:e,state:s,index:t}}check(){let t=this.state.status,e=this.firstTaskIsStarted()?"RUNNING":"PENDING";if(this.lastTaskIsSuccessful())e="SUCCESS";else for(let s of this.tasks)if(this.state.tasks[s.id].status==="FAILED"){e="FAILED";break}e!==t&&this.updateQueueStatus(e)}next(t){this.check();let e=this.getActiveTask();if(!e)return;let{index:s,task:a,state:i}=e;if(i.status==="SUCCESS"){this.updateActiveTaskIndex(s+1),this.next(t);return}if(!["FAILED","CANCELED","RUNNING"].includes(i.status)&&(i.status==="PENDING"||i.status==="BLOCKED")){this.updateTaskState(a.id,{status:"RUNNING"}),this.updateQueueStatus("RUNNING");let n=this.actions[a.action];n({context:this.getContext(t),next:()=>{this.markCurrentTaskAsFinished(t)},retry:()=>{this.resume(t)},failed:()=>{this.updateTaskState(a.id,{status:"FAILED"}),this.check()},schedule:u=>{this.createTask(u),this.check()},getStorage:this.getStorage.bind(this),setStorage:this.setStorage.bind(this),block:u=>{this.block({reason:u})},unblock:()=>{this.unblock()}})}}block({reason:t,silent:e=!1}){let s=this.getActiveTask();if(!s)throw new Error("Task isn't exist.");this.updateTaskState(s.task.id,{status:"BLOCKED",blockedFor:t}),this.updateQueueStatus("BLOCKED"),e||this.events.onBlock({action:s.task.action,id:s.task.id,reason:t})}unblock(){let t=this.getActiveTask();if(!t||t.state.status!=="BLOCKED")throw new Error("Task is not blocked.");this.updateTaskState(t.task.id,{status:"PENDING"}),this.updateQueueStatus("RUNNING"),this.events.onUnblock({id:t.task.id})}forceRun(t){let e=this.getActiveTask();if(!e||e.state.status!=="BLOCKED")throw new Error("Task is not blocked.");let s=this.actions[e.task.action];s({context:this.getContext(t),next:()=>{this.updateTaskState(e.task.id,{status:"RUNNING"}),this.updateQueueStatus("RUNNING"),this.markCurrentTaskAsFinished(t)},retry:()=>{this.resume(t)},failed:()=>{this.updateTaskState(e.task.id,{status:"FAILED"}),this.check()},schedule:a=>{this.createTask(a),this.check()},getStorage:this.getStorage.bind(this),setStorage:this.setStorage.bind(this),block:a=>{this.block({reason:a})},unblock:()=>{this.unblock()}})}markCurrentTaskAsFinished(t){this.check();let e=this.state.activeTaskIndex,s=this.tasks[e];if(!s)return;if(this.state.tasks[s.id].status==="RUNNING"){this.updateTaskState(s.id,{status:"SUCCESS"}),this.updateActiveTaskIndex(e+1);let i={id:s.id,task:this.get(s.id),action:this.tasks.find(n=>n.id===s.id).action};this.events.onUpdate(i),this.next(t)}}resume(t){let e=this.state.activeTaskIndex,s=this.tasks[e];if(!s)return;this.state.tasks[s.id].status==="RUNNING"?(this.updateTaskState(s.id,{status:"PENDING"}),this.next(t)):(this.resetState(),this.next(t))}cancel(){let t=this.getActiveTask();if(!t||["FAILED","CANCELED","SUCCESS"].includes(t.state.status))return;let{task:e}=t;this.updateTaskState(e.id,{status:"CANCELED"});let s={id:e.id,task:this.get(e.id),action:this.tasks.find(a=>a.id===e.id).action};this.events.onUpdate(s),this.updateQueueStatus("CANCELED")}resetState(){this.state.activeTaskIndex=0,this.state.status="PENDING",Object.keys(this.state.tasks).forEach(t=>{this.state.tasks[t].status="PENDING"})}getStorage(){return this.storage}setStorage(t){return this.storage=t,this.events.onStorageUpdate(t),this.storage}getContext(t){return{...t.context,_queue:{id:this.id}}}};o(h,"Queue");var T=h;var g=class{constructor(t){this.queuesDefs=new Map;this.queues=new Map;this.isPaused=!1;this.syncInterval=null;let e={onCreateQueue:()=>{},onCreateTask:()=>{},onUpdateQueue:()=>{},onUpdateTask:()=>{},onStorageUpdate:()=>{},onTaskBlock:()=>{},onPersistedDataLoaded:()=>{},onDeleteQueue:()=>{}};t.events?this.events={...e,...t.events}:this.events=e,t.queuesDefs.map(s=>{this.queuesDefs.set(s.name,s)}),this.context=t.context||{},this.persistor=new l,this.sync(),t.isPaused&&this.pause()}async create(t,e,s){if(!this.queuesDefs.has(t))throw new Error("You need to add a queue definition first.");try{let a=this.queuesDefs.get(t),i=s?.id||E(),n=Date.now(),u=this.createQueue({queue_id:i,queue_name:t});u.setStorage(e);let v=this.add(i,{list:u,createdAt:n,name:t,status:"PENDING",actions:{run:()=>{u.next({context:this.getContext()})},cancel:()=>{u.cancel()},setStorage:(...k)=>{u.setStorage(...k)},getStorage:()=>u.getStorage()}});return await this.persistor.insertQueue({id:i,createdAt:n,name:v.name,status:v.status,tasks:u.tasks,state:u.state,storage:u.getStorage()}),a.run.forEach(k=>{u.createTask(k)}),this.execute(),i}catch(a){throw new Error(a?.message)}}get(t){return this.queues.get(t)}getAll(){return this.queues}deleteQueue(t){this.queues.delete(t),this.persistor.deleteQueue(t)}execute(){if(this.shouldExecute())for(let[,t]of Array.from(this.queues))t.status==="PENDING"&&t.actions.run()}resume(){if(this.shouldExecute()){for(let[,t]of Array.from(this.queues))if(t.status==="RUNNING"){t.list.resume({context:this.getContext()});return}this.execute()}}retry(){if(this.shouldExecute()){for(let[,t]of Array.from(this.queues))t.status==="BLOCKED"&&t.list.checkBlock();this.execute()}}forceExecute(t,e){let s=this.get(t),a=this.getContext();e&&(a={...a,...e}),s?.list.forceRun({context:a})}pause(){this.isPaused||(this.isPaused=!0,this.syncInterval=setInterval(()=>{this.sync()},S))}run(){this.isPaused&&(this.isPaused=!1,this.syncInterval&&(clearInterval(this.syncInterval),this.syncInterval=null),this.sync())}async sync(){try{let t=await this.persistor.getAll();this.queues=new Map,t.forEach(e=>{let s=this.createQueue({queue_id:e.id,queue_name:e.name});this.add(e.id,{list:s,createdAt:e.createdAt,name:e.name,status:e.status,actions:{run:()=>{s.next({context:this.getContext()})},cancel:()=>{s.cancel()},setStorage:(...a)=>{s.setStorage(...a)},getStorage:()=>s.getStorage()}}),s.initTasks({state:e.state,tasks:e.tasks,storage:e.storage||{}}),e.status==="RUNNING"&&this.shouldExecute()&&s.resume({context:this.getContext()})})}catch(t){console.log(`IndexDB Error: ${t}`)}this.events.onPersistedDataLoaded(this)}createQueue(t){let{queue_id:e,queue_name:s}=t,a=this,i=this.queuesDefs.get(s),n=new T({id:e,events:{onCreate:u=>{this.events.onCreateTask(e,u),this.handleUpdate(e),i.events?.onCreate&&i.events.onCreate(u)},onUpdate:u=>{this.events.onUpdateTask(e,u),this.handleUpdate(e),i.events?.onUpdate&&i.events.onUpdate(u)},onUpdateListStatus:u=>{this.queues.set(e,{...this.get(e),status:u}),this.events.onUpdateQueue(e,this.get(e)),this.handleUpdate(e),this.execute(),i.events?.onUpdateListStatus&&i.events.onUpdateListStatus(u)},onStorageUpdate:u=>{this.events.onStorageUpdate(e,u),i.events?.onStorageUpdate&&i.events.onStorageUpdate(u),this.handleUpdate(e)},onBlock:u=>{this.queues.set(e,{...this.get(e),status:"BLOCKED"}),this.events.onTaskBlock(e),i.whenTaskBlocked&&i.whenTaskBlocked(u,{queue_id:e,queue:n,context:this.getContext(),getBlockedTasks:this.getBlockedTasks.bind(this),forceExecute:this.forceExecute.bind(this),retry:this.retry.bind(this),manager:a}),this.handleUpdate(e)},onUnblock:()=>{this.queues.set(e,{...this.get(e),status:"PENDING"}),this.handleUpdate(e),this.execute()}},actions:i.actions});return n}getBlockedTasks(){let t=this.getAll(),e=[];return t.forEach((s,a)=>{s.list.tasks.forEach(i=>{let n=s.list.state.tasks[i.id];n.status==="BLOCKED"&&e.push({task_id:i.id,queue_id:a,action:i.action,reason:n.blockedFor,storage:{get:()=>s.list.getStorage(),set:u=>s.list.setStorage(u)}})})}),e}add(t,e){this.queues.set(t,e);let s=this.get(t);return this.events.onCreateQueue({...s,id:t}),s}handleUpdate(t){let e=this.get(t);if(e){let s=e.status,a=e.list.state,i=e.list.tasks;this.persistor.updateQueue(t,{status:s,state:a,tasks:i,storage:e.list.getStorage()})}}getContext(){return this.context?.current||{}}shouldExecute(){return!this.isPaused}};o(g,"Manager");export{f as DB_NAME,g as Manager,l as Persistor,S as SYNC_POLLING_INTERVAL,p as Status};
//# sourceMappingURL=index.js.map
