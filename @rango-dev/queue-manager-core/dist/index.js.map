{
  "version": 3,
  "sources": ["../src/manager.ts", "../src/persistor.ts", "../src/queue.ts", "../src/types.ts"],
  "sourcesContent": ["import type { QueueEventHandlers, TaskEvent } from './queue';\nimport type { QueueStorage } from './types';\n\nimport { v4 as uuidv4 } from 'uuid';\n\nimport Persistor from './persistor';\nimport Queue from './queue';\nimport { Status, SYNC_POLLING_INTERVAL } from './types';\n\nexport type ManagerContext = object;\nexport type QueueName = string;\nexport type QueueID = string;\nexport type BlockedTask = {\n  queue_id: string;\n  task_id: string;\n  action: string;\n  reason: Record<string, unknown>;\n  storage: {\n    get: () => QueueStorage;\n    set: (data: QueueStorage) => QueueStorage;\n  };\n};\n\nexport type SetStorage<T> = (nextStorage: T) => T;\n\nexport interface ExecuterActions<\n  T extends QueueStorage = QueueStorage,\n  V extends string = string,\n  C = ManagerContext\n> {\n  next: () => void;\n  retry: () => void;\n  failed: () => void;\n  schedule: (actionName: V) => void;\n  setStorage: SetStorage<T>;\n  getStorage: () => T;\n  block: (reason: Record<string, unknown>) => void;\n  unblock: () => void;\n  context: C;\n}\n\nexport interface QueueDef<\n  T extends QueueStorage = QueueStorage,\n  V extends string = string,\n  C = ManagerContext\n> {\n  name: QueueName;\n  actions: {\n    [K in V]: (actions: ExecuterActions<T, V, C>) => void | Promise<void>;\n  };\n  events?: Partial<QueueEventHandlers>;\n  run: V[];\n  whenTaskBlocked?: (\n    event: any,\n    params: {\n      queue_id: string;\n      queue: Queue;\n      context: C;\n      getBlockedTasks: () => BlockedTask[];\n      forceExecute: (queue_id: string, data?: object) => void;\n      retry: () => void;\n      manager: Manager;\n    }\n  ) => void;\n}\n\nexport interface Events {\n  onCreateQueue: (queue: QueueInfo & { id: QueueID }) => void;\n  onUpdateQueue: (queue_id: QueueID, queue: QueueInfo) => void;\n  onCreateTask: (queue_id: QueueID, event: TaskEvent) => void;\n  onUpdateTask: (queue_id: QueueID, event: TaskEvent) => void;\n  onStorageUpdate: (queue_id: QueueID, data: QueueStorage) => void;\n  onTaskBlock: (queue_id: QueueID) => void;\n  onDeleteQueue: (queue_id: QueueID) => void;\n  onPersistedDataLoaded: (manager: Manager) => void;\n}\n\ninterface ManagerOptions {\n  events?: Partial<Events>;\n  queuesDefs: QueueDef[];\n  context?: ManagerContext;\n  isPaused?: boolean;\n}\n\nexport interface QueueInfo {\n  name: QueueName;\n  createdAt: number;\n  status: Status;\n  list: Queue;\n  actions: {\n    run: () => void;\n    cancel: () => void;\n    setStorage: SetStorage<any>;\n    getStorage: () => any;\n  };\n}\n\nclass Manager {\n  private queuesDefs = new Map<QueueName, QueueDef>();\n  private queues = new Map<QueueID, QueueInfo>();\n  private events: Events;\n  private persistor: Persistor;\n  private context: ManagerContext;\n  private isPaused = false;\n  // The client won't get any update on pause, We are using a polling mode to fix this issue for now.\n  private syncInterval: NodeJS.Timer | null = null;\n\n  /**\n   *\n   * Making an instance, initilize events, setup a persistor and try to recover the last state of the manager.\n   *\n   *\n   */\n  constructor(options: ManagerOptions) {\n    const defaultEventHandlers: Events = {\n      onCreateQueue: () => {\n        // ...\n      },\n      onCreateTask: () => {\n        // ...\n      },\n      onUpdateQueue: () => {\n        // ...\n      },\n      onUpdateTask: () => {\n        // ...\n      },\n      onStorageUpdate: () => {\n        // ...\n      },\n      onTaskBlock: () => {\n        // ...\n      },\n      onPersistedDataLoaded: () => {\n        // ..\n      },\n      onDeleteQueue: () => {\n        // ...\n      },\n    };\n\n    if (options.events) {\n      this.events = {\n        ...defaultEventHandlers,\n        ...options.events,\n      };\n    } else {\n      this.events = defaultEventHandlers;\n    }\n\n    options.queuesDefs.map((qDef) => {\n      this.queuesDefs.set(qDef.name, qDef);\n    });\n\n    this.context = options.context || {};\n    this.persistor = new Persistor();\n\n    void this.sync();\n\n    if (options.isPaused) {\n      this.pause();\n    }\n  }\n\n  // Create a new queue\n  /**\n   *\n   * Create a new queue by client.\n   *\n   * It will do the internal things to make a queue from definitions, and running using Manager.\n   *\n   * Notes:\n   *  - After creating the queue, it will be run automatically.\n   *\n   * @returns an ID for queue so it can be used to get the created queue later by client.\n   *\n   */\n  public async create(\n    name: QueueName,\n    storage: QueueStorage,\n    options?: { id?: QueueID }\n  ) {\n    if (!this.queuesDefs.has(name)) {\n      throw new Error('You need to add a queue definition first.');\n    }\n\n    try {\n      const def = this.queuesDefs.get(name)!;\n      const queue_id: QueueID = options?.id || uuidv4();\n      const createdAt = Date.now();\n      const list = this.createQueue({\n        queue_id: queue_id,\n        queue_name: name,\n      });\n      list.setStorage(storage);\n\n      const createdQueue = this.add(queue_id, {\n        list,\n        createdAt,\n        name,\n        status: Status.PENDING,\n        actions: {\n          run: () => {\n            list.next({\n              context: this.getContext(),\n            });\n          },\n          cancel: () => {\n            list.cancel();\n          },\n          setStorage: (...args) => {\n            list.setStorage(...args);\n          },\n          getStorage: () => {\n            return list.getStorage();\n          },\n        },\n      });\n\n      /*\n       * Persist initial queue\n       * Note: we need to first insert the queue, and then it can be updated by internal events.\n       */\n      await this.persistor.insertQueue({\n        id: queue_id,\n        createdAt,\n        name: createdQueue.name,\n        status: createdQueue.status,\n        tasks: list.tasks,\n        state: list.state,\n        storage: list.getStorage(),\n      });\n\n      // adding initial tasks\n      def.run.forEach((action) => {\n        list.createTask(action);\n      });\n\n      // After creating a new queue, try to run.\n      this.execute();\n      return queue_id;\n    } catch (e) {\n      throw new Error((e as any)?.message);\n    }\n  }\n  /**\n   *\n   * Reading persisted data from storage then brings into memory.\n   *\n   * Notes:\n   *  - Reset the memory, so we can call this method whenever we want and not only on the initialize process.\n   *  - All the events will be tirggered (like onCreateQueue, onCreateTask, onBlock, ....)\n   *  - Try to `resume` if the status is `running`.\n   *  - Trigger `onPersistedDataLoaded` event when queues recovered from storage.\n   *\n   */\n\n  /**\n   * Get a queue by its ID.\n   *\n   * @returns An object includes queue and its state in `Manager`.\n   */\n  public get(queue_id: QueueID) {\n    return this.queues.get(queue_id);\n  }\n\n  /**\n   * Get all queues from `Manager`\n   *\n   * @returns a list of queues includes all the queues and their states.\n   */\n  public getAll() {\n    return this.queues;\n  }\n\n  public deleteQueue(queue_id: QueueID) {\n    this.queues.delete(queue_id);\n    void this.persistor.deleteQueue(queue_id);\n  }\n  /**\n   *\n   * Ask from manager to run pending queues.\n   *\n   * It only try to run queues with `PENDING` status and ignore all the other statuses.\n   *\n   */\n  public execute() {\n    if (!this.shouldExecute()) {\n      return;\n    }\n\n    for (const [, q] of Array.from(this.queues)) {\n      if (q.status === Status.PENDING) {\n        q.actions.run();\n      }\n    }\n  }\n\n  /**\n   *\n   * Try to find queues with `RUNNING` status to run them again.\n   *\n   * It's useful for recovering the queue at some certain points\n   * like running a currepted task (reloaded when it was running) or needs manual trigger from UI.\n   *\n   * @returns\n   */\n  public resume() {\n    if (!this.shouldExecute()) {\n      return;\n    }\n\n    for (const [, q] of Array.from(this.queues)) {\n      if (q.status === Status.RUNNING) {\n        q.list.resume({\n          context: this.getContext(),\n        });\n        return;\n      }\n    }\n\n    // If there is no running queue, try to run a new queue.\n    this.execute();\n  }\n\n  /**\n   *\n   * Run all `BLOCKED` queues once again.\n   *\n   * If a queue has `BLOCKED` status and the last task is `BLOCKED` as well,\n   * The task will be run one more time.\n   *\n   * Useful for scenarios like we are blocking the queue under some conditions in task,\n   * We can use this method to ask the queue to run the blocked task one more time and\n   * maybe this time condtions are met and the queue can be proceed.\n   *\n   * @returns\n   */\n  public retry() {\n    if (!this.shouldExecute()) {\n      return;\n    }\n\n    for (const [, q] of Array.from(this.queues)) {\n      if (q.status === Status.BLOCKED) {\n        q.list.checkBlock();\n      }\n    }\n\n    // If there is no running queue, try to run a new queue.\n    this.execute();\n  }\n\n  /**\n   *\n   * Run a blocked task on a specific queue with the ability to pass more data.\n   *\n   * Useful when we have a custom logic for running queue and needs to pass some specific data\n   * to the task and try to run it manually with the provided data.\n   *\n   */\n  public forceExecute(queue_id: string, data?: object) {\n    const queue = this.get(queue_id);\n    let context = this.getContext();\n    if (data) {\n      context = {\n        ...context,\n        ...data,\n      };\n    }\n\n    queue?.list.forceRun({\n      context,\n    });\n  }\n\n  /**\n   * Active readonly mode for manager, it means it doesn't run anythin,\n   * And only can be used to read the data.\n   */\n  public pause() {\n    if (this.isPaused) {\n      return;\n    }\n    this.isPaused = true;\n    this.syncInterval = setInterval(() => {\n      void this.sync();\n    }, SYNC_POLLING_INTERVAL);\n  }\n\n  /**\n   * Activate normal mode which means it will be able to run the queuese as well.\n   */\n  public run() {\n    // If call this method multiple times, it should be run for once.\n    if (this.isPaused) {\n      this.isPaused = false;\n      if (!!this.syncInterval) {\n        clearInterval(this.syncInterval);\n        this.syncInterval = null;\n      }\n      void this.sync();\n    }\n  }\n\n  private async sync() {\n    try {\n      // Reading queues from storage\n      const queues = await this.persistor.getAll();\n\n      // Reset queues, if anything is exist in memory.\n      this.queues = new Map();\n\n      // Brings them into memory\n      queues.forEach((q) => {\n        const list = this.createQueue({\n          queue_id: q.id,\n          queue_name: q.name,\n        });\n        this.add(q.id, {\n          list,\n          createdAt: q.createdAt,\n          name: q.name,\n          status: q.status,\n          actions: {\n            run: () => {\n              list.next({\n                context: this.getContext(),\n              });\n            },\n            cancel: () => {\n              list.cancel();\n            },\n            setStorage: (...args) => {\n              list.setStorage(...args);\n            },\n            getStorage: () => {\n              return list.getStorage();\n            },\n          },\n        });\n\n        list.initTasks({\n          state: q.state,\n          tasks: q.tasks,\n          storage: q.storage || {},\n        });\n\n        if (q.status === Status.RUNNING && this.shouldExecute()) {\n          list.resume({\n            context: this.getContext(),\n          });\n        }\n      });\n    } catch (e) {\n      console.log(`IndexDB Error: ${e}`);\n    }\n\n    // Trigger an event to let the subscribers we are done here.\n    this.events.onPersistedDataLoaded(this);\n  }\n\n  /**\n   *\n   * Making a new instance from `Queue` and adds Manager's event handlers to it.\n   *\n   * @returns An instance of `Queue` with wrapped event handlers from Manager.\n   *\n   */\n  private createQueue(info: { queue_id: QueueID; queue_name: QueueName }) {\n    const { queue_id, queue_name } = info;\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const manager = this;\n    const def = this.queuesDefs.get(queue_name)!;\n    const list = new Queue({\n      id: queue_id,\n      events: {\n        onCreate: (task) => {\n          this.events.onCreateTask(queue_id, task);\n          this.handleUpdate(queue_id);\n\n          if (def.events?.onCreate) {\n            def.events.onCreate(task);\n          }\n        },\n        onUpdate: (task) => {\n          this.events.onUpdateTask(queue_id, task);\n          this.handleUpdate(queue_id);\n\n          if (def.events?.onUpdate) {\n            def.events.onUpdate(task);\n          }\n        },\n        onUpdateListStatus: (status) => {\n          this.queues.set(queue_id, {\n            ...this.get(queue_id)!,\n            status,\n          });\n          this.events.onUpdateQueue(queue_id, this.get(queue_id)!);\n\n          this.handleUpdate(queue_id);\n\n          // After finishing a queue, try to run other queues.\n          this.execute();\n          if (def.events?.onUpdateListStatus) {\n            def.events.onUpdateListStatus(status);\n          }\n        },\n        onStorageUpdate: (data) => {\n          this.events.onStorageUpdate(queue_id, data);\n          if (def.events?.onStorageUpdate) {\n            def.events.onStorageUpdate(data);\n          }\n          this.handleUpdate(queue_id);\n        },\n        onBlock: (event) => {\n          // Update queue status\n          this.queues.set(queue_id, {\n            ...this.get(queue_id)!,\n            status: Status.BLOCKED,\n          });\n\n          // Trigger event\n          this.events.onTaskBlock(queue_id);\n          if (def.whenTaskBlocked) {\n            def.whenTaskBlocked(event, {\n              queue_id: queue_id,\n              queue: list,\n              context: this.getContext(),\n              getBlockedTasks: this.getBlockedTasks.bind(this),\n              forceExecute: this.forceExecute.bind(this),\n              retry: this.retry.bind(this),\n              manager,\n            });\n          }\n\n          // Sync\n          this.handleUpdate(queue_id);\n        },\n        onUnblock: () => {\n          // Update queue status\n          this.queues.set(queue_id, {\n            ...this.get(queue_id)!,\n            status: Status.PENDING,\n          });\n\n          // Sync\n          this.handleUpdate(queue_id);\n\n          this.execute();\n        },\n      },\n      actions: def.actions,\n    });\n    return list;\n  }\n\n  /**\n   * Go through all tasks (from all queues) and return a list of blocked tasks\n   *\n   * @returns a list of blocked tasks including enough information to get the queue and mutate the storage.\n   *\n   */\n  private getBlockedTasks() {\n    const queues = this.getAll();\n    const blockedTasks: BlockedTask[] = [];\n    queues.forEach((q, queue_id) => {\n      q.list.tasks.forEach((task) => {\n        const state = q.list.state.tasks[task.id];\n        if (state.status === Status.BLOCKED) {\n          blockedTasks.push({\n            task_id: task.id,\n            queue_id: queue_id,\n            action: task.action,\n            reason: state.blockedFor,\n            storage: {\n              get: () => {\n                return q.list.getStorage();\n              },\n              set: (data) => {\n                return q.list.setStorage(data);\n              },\n            },\n          });\n        }\n      });\n    });\n\n    return blockedTasks;\n  }\n\n  /**\n   *\n   * Add a queue to the manager to keep track of the queue and its state.\n   *\n   * @param id\n   * @param queue\n   * @returns\n   */\n  private add(id: QueueID, queue: QueueInfo) {\n    this.queues.set(id, queue);\n    const createdQueue = this.get(id)!;\n    this.events.onCreateQueue({ ...createdQueue, id });\n\n    return createdQueue;\n  }\n\n  /**\n   *\n   * Sync in-memory state (of `Manager`) with storage (persist).\n   *\n   * Usually we call this method after a change detected in the state of manager.\n   *\n   */\n  private handleUpdate(queue_id: QueueID) {\n    const queue = this.get(queue_id);\n\n    if (queue) {\n      const status = queue.status;\n      const state = queue.list.state;\n      const tasks = queue.list.tasks;\n      void this.persistor.updateQueue(queue_id, {\n        status,\n        state,\n        tasks,\n        storage: queue.list.getStorage(),\n      });\n    }\n  }\n\n  private getContext() {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/ban-ts-comment\n    //@ts-ignore\n    return this.context?.current || {};\n  }\n\n  private shouldExecute() {\n    return !this.isPaused;\n  }\n}\n\nexport { Manager };\n", "import type { QueueID } from './manager';\nimport type { PersistedQueue } from './types';\nimport type { DBSchema, IDBPDatabase } from 'idb';\n\nexport const DB_NAME = 'queues-manager';\nconst OBJECT_STORE_NAME = 'queues';\nconst VERSION = 1;\n\ntype UpdatePersistedQueue = Partial<\n  Pick<PersistedQueue, 'status' | 'state' | 'tasks' | 'storage'>\n>;\n\ninterface Database extends DBSchema {\n  queues: {\n    value: PersistedQueue;\n    key: string;\n  };\n}\n\nclass Persistor {\n  db: Promise<IDBPDatabase<Database>>;\n  constructor() {\n    this.db = import('idb')\n      .then(async (idb) => {\n        return idb.openDB<Database>(DB_NAME, VERSION, {\n          upgrade(db) {\n            db.createObjectStore(OBJECT_STORE_NAME, { keyPath: 'id' });\n          },\n        });\n      })\n      .catch(() => {\n        throw new Error(\"Couldn't load idb.\");\n      });\n  }\n\n  async insertQueue(queue: PersistedQueue) {\n    const db = await this.db;\n    const queueRecord = await db.get(OBJECT_STORE_NAME, queue.id);\n    if (queueRecord) {\n      // Queue already exists inside persistor.\n    } else {\n      await db.add(OBJECT_STORE_NAME, queue);\n    }\n  }\n  async updateQueue(id: QueueID, queue: UpdatePersistedQueue) {\n    const db = await this.db;\n    const currentRecord = await db.get(OBJECT_STORE_NAME, id);\n\n    if (!currentRecord) {\n      return;\n    }\n\n    const updatedRecord = {\n      ...currentRecord,\n      ...queue,\n    };\n    await db.put(OBJECT_STORE_NAME, updatedRecord);\n  }\n  async getAll() {\n    const db = await this.db;\n    const results = await db.getAll(OBJECT_STORE_NAME);\n\n    return results;\n  }\n  async deleteQueue(id: QueueID) {\n    const db = await this.db;\n    const currentRecord = await db.get(OBJECT_STORE_NAME, id);\n\n    if (currentRecord) {\n      await db.delete(OBJECT_STORE_NAME, id);\n    }\n  }\n}\n\nexport default Persistor;\n", "import { v4 as uuidv4 } from 'uuid';\nimport { ManagerContext, QueueDef, QueueID } from './manager';\nimport { QueueStorage, Status } from './types';\n\ntype TaskId = string;\nexport type TaskState = {\n  status: Status;\n  blockedFor: any;\n};\n\nexport interface QueueContext {\n  _queue?: {\n    id: string;\n  };\n}\nexport type NextParams = {\n  context: ManagerContext;\n};\n\nexport interface QueueState {\n  status: Status;\n  activeTaskIndex: number;\n  tasks: {\n    [key in TaskId]: TaskState;\n  };\n}\n\nexport interface Task {\n  id: TaskId;\n  action: string;\n}\n\nexport type InitTasks = {\n  tasks: Task[];\n  state: QueueState;\n  storage: QueueStorage;\n};\n\nexport interface TaskEvent {\n  id: TaskId;\n  task: TaskState;\n  action: string;\n}\n\nexport interface QueueEventHandlers {\n  // all tasks\n  onUpdateListStatus: (status: Status) => void;\n  // single task\n  onCreate: (event: TaskEvent) => void;\n  onUpdate: (event: TaskEvent) => void;\n  onStorageUpdate: (data: QueueStorage) => void;\n  onBlock: (\n    data: Omit<TaskEvent, 'task'> & { reason: Record<string, unknown> }\n  ) => void;\n  onUnblock: (data: { id: string }) => void;\n}\n\ninterface QueueOptions {\n  id: QueueID;\n  events: QueueEventHandlers;\n  actions: QueueDef['actions'];\n}\n\n/**\n *\n * Notes on statuses:\n *  - Success: last task has success status\n *  - Failed: any of task has been failed\n *  - Running: first task is not on pending\n *  - Pending: default state. not started\n *\n */\nclass Queue {\n  public id: string;\n  public state: QueueState = {\n    status: Status.PENDING,\n    activeTaskIndex: 0,\n    tasks: {},\n  };\n  public tasks: Task[] = [];\n  private events: QueueOptions['events'];\n  private actions: QueueOptions['actions'];\n  private storage: QueueStorage = {};\n\n  constructor(options: QueueOptions) {\n    this.id = options.id;\n    this.events = options.events;\n    this.actions = options.actions;\n  }\n\n  /**\n   * Update queue status and trigger an event\n   *\n   */\n  private updateQueueStatus(status: Status) {\n    this.state.status = status;\n    this.events.onUpdateListStatus(status);\n  }\n\n  private updateActiveTaskIndex(index: number) {\n    this.state.activeTaskIndex = index;\n  }\n\n  /**\n   *\n   * Update task state (`status`, `blockedFor`) and trigger an event.\n   * @param id\n   * @param nextState\n   */\n  private updateTaskState(id: TaskId, nextState: Partial<TaskState>) {\n    if (nextState.status) {\n      this.state.tasks[id].status = nextState.status;\n    }\n    if (nextState.blockedFor) {\n      this.state.tasks[id].blockedFor = nextState.blockedFor;\n    }\n\n    const updatedTaskEvent = {\n      id: id,\n      task: this.get(id)!,\n      action: this.tasks.find((task) => task.id === id)!.action,\n    };\n    this.events.onUpdate(updatedTaskEvent);\n  }\n\n  /**\n   * Create a task by providing an `action` name.\n   *\n   * this method creating the task, push it to the queue's tasks and trigger an event.\n   * @param action\n   */\n  createTask(action: string) {\n    const id = uuidv4();\n    this.tasks.push({\n      action,\n      id,\n    });\n    this.state.tasks[id] = {\n      status: Status.PENDING,\n      blockedFor: null,\n    };\n\n    const createdTask = this.get(id);\n    this.events.onCreate({\n      id,\n      task: createdTask!,\n      action,\n    });\n  }\n\n  /**\n   * Initilize a queue with some tasks, instead of an empty queue.\n   *\n   * Using it for recover the queue state from persistor.\n   *\n   */\n  public initTasks(info: InitTasks) {\n    this.state = info.state;\n    this.storage = info.storage;\n\n    info.tasks.forEach((task) => {\n      this.tasks.push(task);\n      const action = this.tasks.find((t) => t.id === task.id)!.action;\n      this.events.onCreate({\n        id: task.id,\n        task: this.get(task.id)!,\n        action,\n      });\n    });\n  }\n\n  public checkBlock() {\n    const currentActiveTask = this.getActiveTask();\n\n    if (!currentActiveTask) {\n      return;\n    }\n    const { task, state } = currentActiveTask;\n\n    if (state.status === Status.BLOCKED) {\n      this.events.onBlock({\n        action: task.action,\n        id: task.id,\n        reason: state.blockedFor,\n      });\n    }\n  }\n\n  /**\n   * Getting task state by ID\n   */\n  public get(id: string): TaskState | null {\n    const task = this.state.tasks[id];\n\n    if (!task) return null;\n\n    return task;\n  }\n\n  /**\n   *\n   * Checking if status of the last is `SUCCESS` or not\n   *\n   */\n  private lastTaskIsSuccessful() {\n    const lastTask = this.tasks[this.tasks.length - 1];\n\n    // checking for empty lists.\n    if (lastTask) {\n      const lastTaskState = this.state.tasks[lastTask.id];\n\n      // Maybe we didn't create the state yet. It should has success status as well.\n      if (!!lastTaskState && lastTaskState.status === Status.SUCCESS) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * If the first task started (it's not PENDING),\n   * it means the queue has been ran.\n   *\n   * @returns\n   */\n  private firstTaskIsStarted() {\n    const firstTask = this.tasks[0];\n\n    // checking for empty lists.\n    if (firstTask) {\n      const firstTaskState = this.state.tasks[firstTask.id];\n\n      // Maybe we didn't create the state yet.\n      if (!!firstTaskState) {\n        if (firstTaskState.status !== Status.PENDING) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Getting active task index from state and\n   * returns the task and its state.\n   *\n   */\n  private getActiveTask() {\n    // First try to get task with `activeTask`\n    const index = this.state.activeTaskIndex;\n    const task = this.tasks[index];\n\n    // Consider all the tasks has been executed.\n    if (!task) {\n      return null;\n    }\n\n    const state = this.state.tasks[task.id];\n\n    return { task, state, index };\n  }\n\n  /**\n   * Update and find the queue status by checking state of each tasks in the queue.\n   */\n  public check() {\n    const currentListStatus = this.state.status;\n    let nextListStatus = this.firstTaskIsStarted()\n      ? Status.RUNNING\n      : Status.PENDING;\n\n    if (this.lastTaskIsSuccessful()) {\n      nextListStatus = Status.SUCCESS;\n    } else {\n      // Is there any failed task?\n      for (const task of this.tasks) {\n        const state = this.state.tasks[task.id];\n\n        // If one item fails, we stop to work on the list.\n        if (state.status === Status.FAILED) {\n          nextListStatus = Status.FAILED;\n          break;\n        }\n      }\n    }\n\n    // We only update and trigger an event when there is a new value\n    if (nextListStatus !== currentListStatus) {\n      this.updateQueueStatus(nextListStatus);\n    }\n  }\n\n  /**\n   * Execute active task.\n   * Based on the state of active task, the behaviour is different. If status is:\n   *  - Success -> we need to go to next task by updating the active index and try `next` on more time.\n   *  - Failed, Running, or no active task -> doesn't do anything.\n   *  - Pending or Blocked -> update the task and queue status to running, and execute the provided `action` for the task.\n   *\n   * The queue is a linked list somehow, active task means the pointer to where we are in the queue right now.\n   *\n   */\n  public next(params: NextParams) {\n    this.check();\n\n    const currentActiveTask = this.getActiveTask();\n\n    if (!currentActiveTask) {\n      return;\n    }\n\n    const {\n      index: activeTaskIndex,\n      task: activeTask,\n      state: activeTaskState,\n    } = currentActiveTask;\n\n    // if `activeTask` is already done, we will go for next one.\n    if (activeTaskState.status === Status.SUCCESS) {\n      this.updateActiveTaskIndex(activeTaskIndex + 1);\n      this.next(params);\n      return;\n    }\n\n    if (\n      [Status.FAILED, Status.CANCELED, Status.RUNNING].includes(\n        activeTaskState.status\n      )\n    ) {\n      return;\n    }\n\n    if (\n      activeTaskState.status === Status.PENDING ||\n      activeTaskState.status === Status.BLOCKED\n    ) {\n      // Update task status to `running`\n      this.updateTaskState(activeTask.id, {\n        status: Status.RUNNING,\n      });\n      this.updateQueueStatus(Status.RUNNING);\n\n      // Try to execute task.\n      const execute = this.actions[activeTask.action];\n      execute({\n        context: this.getContext(params),\n        next: () => {\n          this.markCurrentTaskAsFinished(params);\n        },\n        retry: () => {\n          this.resume(params);\n        },\n        failed: () => {\n          this.updateTaskState(activeTask.id, {\n            status: Status.FAILED,\n          });\n          this.check();\n        },\n        schedule: (action) => {\n          this.createTask(action);\n          this.check();\n        },\n        getStorage: this.getStorage.bind(this),\n        setStorage: this.setStorage.bind(this),\n        block: (reason: Record<string, unknown>) => {\n          this.block({ reason });\n        },\n        unblock: () => {\n          this.unblock();\n        },\n      });\n    }\n  }\n\n  /**\n   * Change the `status` of active task and queue to BLOCKED, then trigger an event.\n   */\n  public block({\n    reason,\n    silent = false,\n  }: {\n    reason: Record<string, unknown>;\n    silent?: boolean;\n  }) {\n    const currentActiveTask = this.getActiveTask();\n\n    if (!currentActiveTask) {\n      throw new Error(\"Task isn't exist.\");\n    }\n\n    this.updateTaskState(currentActiveTask.task.id, {\n      status: Status.BLOCKED,\n      blockedFor: reason,\n    });\n    this.updateQueueStatus(Status.BLOCKED);\n\n    if (!silent) {\n      this.events.onBlock({\n        action: currentActiveTask.task.action,\n        id: currentActiveTask.task.id,\n        reason,\n      });\n    }\n  }\n\n  /**\n   * If the active task is `BLOCKED`, update the task status to `PENDING`, queue status to `RUNNING`\n   * then trigger an event.\n   */\n  public unblock() {\n    const currentActiveTask = this.getActiveTask();\n\n    if (\n      !currentActiveTask ||\n      currentActiveTask.state.status !== Status.BLOCKED\n    ) {\n      throw new Error('Task is not blocked.');\n    }\n\n    this.updateTaskState(currentActiveTask.task.id, {\n      status: Status.PENDING,\n    });\n    this.updateQueueStatus(Status.RUNNING);\n    this.events.onUnblock({ id: currentActiveTask.task.id });\n  }\n\n  /**\n   * If the active task is `BLOCKED` then execute the `action` for the task.\n   *\n   * It is useful for when we need to run a blocked task without changing the status of task at the first place.\n   * For scenarios like we have some conditions in `action` and needs to run the `action` again\n   * to check the conditions are met or not, if yes, so we can proceed the `action`.\n   *\n   */\n  public forceRun(params: NextParams) {\n    const currentTask = this.getActiveTask();\n\n    if (!currentTask || currentTask.state.status !== Status.BLOCKED) {\n      throw new Error('Task is not blocked.');\n    }\n\n    // Try to execute task.\n    const execute = this.actions[currentTask.task.action];\n    execute({\n      context: this.getContext(params),\n      next: () => {\n        /*\n          NOTE:\n            When running `forceRun`, the status of task can be `BLOCKED`\n            So we need to change to `Running` first. \n        */\n        // Update task status to `running`\n        this.updateTaskState(currentTask.task.id, {\n          status: Status.RUNNING,\n        });\n        this.updateQueueStatus(Status.RUNNING);\n\n        this.markCurrentTaskAsFinished(params);\n      },\n      retry: () => {\n        this.resume(params);\n      },\n      failed: () => {\n        this.updateTaskState(currentTask.task.id, {\n          status: Status.FAILED,\n        });\n        this.check();\n      },\n      schedule: (action) => {\n        this.createTask(action);\n        this.check();\n      },\n      getStorage: this.getStorage.bind(this),\n      setStorage: this.setStorage.bind(this),\n      block: (reason: Record<string, unknown>) => {\n        this.block({ reason });\n      },\n      unblock: () => {\n        this.unblock();\n      },\n    });\n  }\n  private markCurrentTaskAsFinished(params: NextParams) {\n    this.check();\n    const activeTaskIndex = this.state.activeTaskIndex;\n    const activeTask = this.tasks[activeTaskIndex];\n\n    if (!activeTask) return;\n\n    const activeTaskState = this.state.tasks[activeTask.id];\n    if (activeTaskState.status === Status.RUNNING) {\n      this.updateTaskState(activeTask.id, {\n        status: Status.SUCCESS,\n      });\n      this.updateActiveTaskIndex(activeTaskIndex + 1);\n\n      const updatedTaskEvent = {\n        id: activeTask.id,\n        task: this.get(activeTask.id)!,\n        action: this.tasks.find((task) => task.id === activeTask.id)!.action,\n      };\n      this.events.onUpdate(updatedTaskEvent);\n      this.next(params);\n    }\n  }\n\n  /**\n   * If the active task is `RUNNING`, change it to `PENING` the try to run the task by calling `next`.\n   * If it's other than `RUNNING` we reset the queue state and run the queue from the beggining.\n   *\n   * @param params\n   * @returns\n   */\n  public resume(params: NextParams) {\n    const activeTaskIndex = this.state.activeTaskIndex;\n    const activeTask = this.tasks[activeTaskIndex];\n    if (!activeTask) return;\n\n    const activeTaskState = this.state.tasks[activeTask.id];\n    if (activeTaskState.status === Status.RUNNING) {\n      this.updateTaskState(activeTask.id, {\n        status: Status.PENDING,\n      });\n      this.next(params);\n    } else {\n      this.resetState();\n      this.next(params);\n    }\n  }\n\n  /**\n   *\n   * Cancel the queue by changing active task and queue status to `CANCELED`.\n   *\n   */\n  public cancel() {\n    const currentActiveTask = this.getActiveTask();\n\n    if (\n      !currentActiveTask ||\n      [Status.FAILED, Status.CANCELED, Status.SUCCESS].includes(\n        currentActiveTask.state.status\n      )\n    ) {\n      return;\n    }\n\n    const { task } = currentActiveTask;\n\n    // Update task status to `canceled`\n    this.updateTaskState(task.id, {\n      status: Status.CANCELED,\n    });\n    const updatedTaskEvent = {\n      id: task.id,\n      task: this.get(task.id)!,\n      action: this.tasks.find((t) => t.id === task.id)!.action,\n    };\n    this.events.onUpdate(updatedTaskEvent);\n\n    // Update queue status to `canceled`\n    this.updateQueueStatus(Status.CANCELED);\n  }\n\n  /**\n   * Update queue status, and all the tasks inside queue to `PENDING`.\n   */\n  private resetState() {\n    this.state.activeTaskIndex = 0;\n    this.state.status = Status.PENDING;\n    Object.keys(this.state.tasks).forEach((id) => {\n      this.state.tasks[id].status = Status.PENDING;\n    });\n  }\n\n  public getStorage() {\n    return this.storage;\n  }\n  public setStorage(data: QueueStorage) {\n    this.storage = data;\n    this.events.onStorageUpdate(data);\n    return this.storage;\n  }\n\n  private getContext(params: NextParams): QueueContext & ManagerContext {\n    return {\n      ...params.context,\n      _queue: {\n        id: this.id,\n      },\n    };\n  }\n}\n\nexport default Queue;\n", "import { QueueID, QueueName } from './manager';\nimport Queue, { QueueState, Task } from './queue';\n\nexport enum Status {\n  PENDING = 'PENDING',\n  RUNNING = 'RUNNING',\n  FAILED = 'FAILED',\n  SUCCESS = 'SUCCESS',\n  CANCELED = 'CANCELED',\n  BLOCKED = 'BLOCKED',\n}\n\nexport const SYNC_POLLING_INTERVAL = 5_000\n\nexport type QueueStorage = Record<string, unknown>;\n\nexport type QueueType = Queue;\n\nexport interface PersistedQueue {\n  id: QueueID;\n  createdAt: number;\n  name: QueueName;\n  status: Status;\n  state: QueueState;\n  tasks: Task[];\n  storage: QueueStorage;\n}\n"],
  "mappings": "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",
  "names": ["uuidv4", "DB_NAME", "OBJECT_STORE_NAME", "Persistor", "idb", "DB_NAME", "db", "OBJECT_STORE_NAME", "queue", "id", "currentRecord", "updatedRecord", "__name", "persistor_default", "uuidv4", "Status", "SYNC_POLLING_INTERVAL", "Queue", "options", "status", "index", "id", "nextState", "updatedTaskEvent", "task", "action", "uuidv4", "createdTask", "info", "t", "currentActiveTask", "state", "lastTask", "lastTaskState", "firstTask", "firstTaskState", "currentListStatus", "nextListStatus", "params", "activeTaskIndex", "activeTask", "activeTaskState", "execute", "reason", "silent", "currentTask", "data", "__name", "queue_default", "Manager", "options", "defaultEventHandlers", "qDef", "persistor_default", "name", "storage", "def", "queue_id", "uuidv4", "createdAt", "list", "createdQueue", "args", "action", "e", "q", "data", "queue", "context", "SYNC_POLLING_INTERVAL", "queues", "info", "queue_name", "manager", "queue_default", "task", "status", "event", "blockedTasks", "state", "id", "tasks", "__name"]
}
