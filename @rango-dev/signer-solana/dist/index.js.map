{
  "version": 3,
  "sources": ["../src/helpers.ts", "../src/signer.ts"],
  "sourcesContent": ["import {\n  Connection,\n  PublicKey,\n  Transaction,\n  TransactionInstruction,\n  VersionedTransaction,\n} from '@solana/web3.js';\nimport type {\n  SolanaTransaction,\n  SignerError as SignerErrorType,\n} from 'rango-types';\nimport { SolanaExternalProvider } from './signer';\nimport { SignerError, SignerErrorCode } from 'rango-types';\n\nasync function retryPromise<Type>(\n  promise: Promise<Type>,\n  count: number,\n  timeoutMs: number,\n  verifier: ((input: Type) => boolean) | null = null\n): Promise<Type> {\n  let remained = count;\n  while (remained > 0) {\n    try {\n      const result = (await Promise.race([\n        promise,\n        new Promise((_, reject) =>\n          setTimeout(() => reject(new Error('timeout')), timeoutMs)\n        ),\n      ])) as Type;\n      if (remained > 1 && verifier != null && !verifier(result))\n        throw new Error('bad result');\n      return result;\n    } catch (er) {\n      console.log(\n        'cant get result. time=' +\n          new Date().toLocaleTimeString() +\n          ' i=' +\n          remained +\n          ' , err=',\n        er\n      );\n      remained--;\n    }\n  }\n  throw new SignerError(\n    SignerErrorCode.SEND_TX_ERROR,\n    'function reached max retry count'\n  );\n}\nfunction getFailedHash(tx: SolanaTransaction) {\n  const random = Math.floor(Math.random() * 9000) + 1000;\n  return 'failed::' + tx.identifier + '::' + random;\n}\n\nconst IS_DEV = !process.env.NODE_ENV || process.env.NODE_ENV === 'development';\nconst SOLANA_RPC_URL = !IS_DEV\n  ? 'https://icy-crimson-wind.solana-mainnet.quiknode.pro/c83f94ebeb39a6d6a9d2ab03d4cba2c2af83c5c0/'\n  : 'https://fluent-still-scion.solana-mainnet.discover.quiknode.pro/fc8be9b8ac7aea382ec591359628e16d8c52ef6a/';\n\nfunction getSolanaConnection(): Connection {\n  return new Connection(SOLANA_RPC_URL, {\n    commitment: 'confirmed',\n    disableRetryOnRateLimit: false,\n  });\n}\n\nfunction confirmTx(signature: string): Promise<boolean> {\n  // eslint-disable-next-line no-async-promise-executor\n  return new Promise(async function (resolve, reject) {\n    let confirmRetry = 3;\n    let successfulConfirm = false;\n    while (confirmRetry > 0) {\n      try {\n        const confirmResult = await getSolanaConnection().confirmTransaction(\n          signature\n        );\n        if (\n          !!confirmResult &&\n          !!confirmResult.value &&\n          confirmResult.value.err == null\n        ) {\n          successfulConfirm = true;\n          break;\n        } else if (\n          confirmRetry === 1 &&\n          !!confirmResult &&\n          !!confirmResult.value &&\n          !!confirmResult.value.err\n        )\n          reject(confirmResult.value.err);\n      } catch (e) {\n        if (confirmRetry === 1) reject(e);\n      }\n\n      confirmRetry -= 1;\n    }\n    resolve(successfulConfirm);\n  });\n}\n\n// https://docs.phantom.app/integrating/sending-a-transaction\n// https://codesandbox.io/s/github/phantom-labs/sandbox\nexport type SolanaWeb3Signer = (\n  solanaWeb3Transaction: Transaction | VersionedTransaction\n) => Promise<number[] | Buffer | Uint8Array>;\n\nexport const generalSolanaTransactionExecutor = async (\n  tx: SolanaTransaction,\n  DefaultSolanaSigner: SolanaWeb3Signer\n): Promise<string> => {\n  const connection = getSolanaConnection();\n  let versionedTransaction: VersionedTransaction | undefined = undefined;\n  let transaction: Transaction | undefined = undefined;\n  if (tx.serializedMessage != null) {\n    if (tx.txType === 'VERSIONED') {\n      versionedTransaction = VersionedTransaction.deserialize(\n        new Uint8Array(tx.serializedMessage)\n      );\n      const blockhash = (\n        await retryPromise(\n          connection.getLatestBlockhash('confirmed'),\n          5,\n          10_000\n        )\n      ).blockhash;\n      if (!!blockhash) versionedTransaction.message.recentBlockhash = blockhash;\n    } else if (tx.txType === 'LEGACY') {\n      transaction = Transaction.from(\n        Buffer.from(new Uint8Array(tx.serializedMessage))\n      );\n      transaction.feePayer = new PublicKey(tx.from);\n      transaction.recentBlockhash = undefined;\n    }\n  } else {\n    transaction = new Transaction();\n    transaction.feePayer = new PublicKey(tx.from);\n    if (tx.recentBlockhash) transaction.recentBlockhash = tx.recentBlockhash;\n    else\n      transaction.recentBlockhash = (\n        await retryPromise(\n          connection.getLatestBlockhash('confirmed'),\n          5,\n          10_000\n        )\n      ).blockhash;\n    tx.instructions.forEach((instruction) => {\n      transaction?.add(\n        new TransactionInstruction({\n          keys: instruction.keys.map((accountMeta) => ({\n            pubkey: new PublicKey(accountMeta.pubkey),\n            isSigner: accountMeta.isSigner,\n            isWritable: accountMeta.isWritable,\n          })),\n          programId: new PublicKey(instruction.programId),\n          data: Buffer.from(instruction.data),\n        })\n      );\n    });\n    tx.signatures.forEach(function (signatureItem) {\n      const signature = Buffer.from(new Uint8Array(signatureItem.signature));\n      const publicKey = new PublicKey(signatureItem.publicKey);\n      transaction?.addSignature(publicKey, signature);\n    });\n  }\n  try {\n    let finalTx: Transaction | VersionedTransaction;\n    if (!!transaction) {\n      finalTx = transaction;\n    } else if (!!versionedTransaction) {\n      finalTx = versionedTransaction;\n    } else {\n      throw new Error('error creating transaction');\n    }\n    const raw = await DefaultSolanaSigner(finalTx);\n    const signature = await retryPromise(\n      connection.sendRawTransaction(raw),\n      2,\n      30_000\n    );\n    if (!signature)\n      throw new Error('tx cant send to blockchain. signature=' + signature);\n    const confirmed = await confirmTx(signature);\n    if (!confirmed)\n      throw new Error('tx cant confirm on blockchain. signature=' + signature);\n\n    return signature;\n  } catch (e) {\n    if (\n      e &&\n      SignerError.isSignerError(e) &&\n      (e as SignerErrorType).code === SignerErrorCode.REJECTED_BY_USER\n    )\n      throw e;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, no-prototype-builtins\n    if (e && (e as any).hasOwnProperty('code') && (e as any).code === 4001)\n      throw new SignerError(SignerErrorCode.REJECTED_BY_USER, undefined, e);\n\n    return getFailedHash(tx);\n  }\n};\n\nexport async function executeSolanaTransaction(\n  tx: SolanaTransaction,\n  solanaProvider: SolanaExternalProvider\n): Promise<string> {\n  const DefaultSolanaSigner: SolanaWeb3Signer = async (\n    solanaWeb3Transaction\n  ) => {\n    try {\n      const signedTransaction = await solanaProvider.signTransaction(\n        solanaWeb3Transaction\n      );\n      return signedTransaction.serialize();\n    } catch (e) {\n      // if (e && (e as any).hasOwnProperty('code') && (e as any).code === 4001)\n      // throw new SignerError(SignerErrorCode  .REJECTED_BY_USER, undefined, e);\n      throw new SignerError(SignerErrorCode.SIGN_TX_ERROR, undefined, e);\n    }\n  };\n  return await generalSolanaTransactionExecutor(tx, DefaultSolanaSigner);\n}\n", "import type { GenericSigner, SolanaTransaction } from 'rango-types';\n\nimport { executeSolanaTransaction } from './helpers';\nimport {\n  PublicKey,\n  SendOptions,\n  Transaction,\n  TransactionSignature,\n  VersionedTransaction,\n} from '@solana/web3.js';\n\nimport { SignerError, SignerErrorCode } from 'rango-types';\n\n// https://github.com/solana-labs/wallet-adapter/blob/01c6316ce0725e0a075d6adb237bbcb4128e76ad/packages/wallets/phantom/src/adapter.ts#L30\nexport interface SolanaExternalProvider {\n  isPhantom?: boolean;\n  publicKey?: { toBytes(): Uint8Array };\n  isConnected: boolean;\n  signTransaction<T extends Transaction | VersionedTransaction>(\n    transaction: T\n  ): Promise<T>;\n  signAllTransactions<T extends Transaction | VersionedTransaction>(\n    transactions: T[]\n  ): Promise<T[]>;\n  signAndSendTransaction<T extends Transaction | VersionedTransaction>(\n    transaction: T,\n    options?: SendOptions\n  ): Promise<{ signature: TransactionSignature }>;\n  signMessage(message: Uint8Array): Promise<{ signature: Uint8Array }>;\n  request(...args: any[]): Promise<any>;\n  connect(...args: any[]): Promise<any>;\n  disconnect(): Promise<void>;\n  accountChanged(newPublicKey: PublicKey): any;\n}\n\nexport class DefaultSolanaSigner implements GenericSigner<SolanaTransaction> {\n  private provider: SolanaExternalProvider;\n\n  constructor(provider: SolanaExternalProvider) {\n    this.provider = provider;\n  }\n\n  async signMessage(msg: string): Promise<string> {\n    try {\n      const encodedMessage = new TextEncoder().encode(msg);\n      const { signature } = await this.provider.request({\n        method: 'signMessage',\n        params: {\n          message: encodedMessage,\n        },\n      });\n      return signature;\n    } catch (error) {\n      throw new SignerError(SignerErrorCode.SIGN_TX_ERROR, undefined, error);\n    }\n  }\n\n  async signAndSendTx(tx: SolanaTransaction): Promise<{ hash: string }> {\n    try {\n      const hash = await executeSolanaTransaction(tx, this.provider);\n      return { hash };\n    } catch (error) {\n      throw new SignerError(SignerErrorCode.SEND_TX_ERROR, undefined, error);\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["Connection", "PublicKey", "Transaction", "TransactionInstruction", "VersionedTransaction", "SignerError", "SignerErrorCode", "retryPromise", "promise", "count", "timeoutMs", "verifier", "remained", "result", "_", "reject", "er", "SignerError", "SignerErrorCode", "__name", "getFailedHash", "tx", "random", "IS_DEV", "SOLANA_RPC_URL", "getSolanaConnection", "Connection", "confirmTx", "signature", "resolve", "confirmRetry", "successfulConfirm", "confirmResult", "generalSolanaTransactionExecutor", "DefaultSolanaSigner", "connection", "versionedTransaction", "transaction", "VersionedTransaction", "blockhash", "Transaction", "PublicKey", "instruction", "TransactionInstruction", "accountMeta", "signatureItem", "publicKey", "finalTx", "raw", "executeSolanaTransaction", "solanaProvider", "solanaWeb3Transaction", "e", "SignerError", "SignerErrorCode", "DefaultSolanaSigner", "provider", "msg", "encodedMessage", "signature", "error", "SignerError", "SignerErrorCode", "tx", "executeSolanaTransaction", "__name"]
}
