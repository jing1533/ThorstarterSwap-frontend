{
  "version": 3,
  "sources": ["../src/types.ts", "../src/persistor.ts", "../src/helpers.ts", "../src/wallet.ts"],
  "sourcesContent": ["import { Network, WalletType, WalletInfo } from '@rango-dev/wallets-shared';\nimport { State as WalletState } from './wallet';\nimport { SignerFactory, BlockchainMeta } from 'rango-types';\n\nexport type State = {\n  [key: string]: WalletState | undefined;\n};\n\nexport type ConnectResult = {\n  accounts: string[] | null;\n  network: Network | null;\n  provider: any;\n};\n\nexport type Providers = { [type in WalletType]?: any };\n\nexport enum Events {\n  CONNECTED = 'connected',\n  CONNECTING = 'connecting',\n  REACHABLE = 'reachable',\n  INSTALLED = 'installed',\n  ACCOUNTS = 'accounts',\n  NETWORK = 'network',\n}\n\nexport type ProviderConnectResult = {\n  accounts: string[];\n  chainId: string;\n};\n\nexport type GetInstanceOptions = {\n  network?: Network;\n  currentProvider: any;\n  meta: BlockchainMeta[];\n  getState: () => WalletState;\n  /**\n   * We always get the instance once and reuse it whenever we needs. By using this option\n   * We can force the library to get a new instance and replace it with the old one.\n   *\n   * Originally, we used this option for wallet connect 1 and its switching network challenge.\n   */\n  force?: boolean;\n  updateChainId: (chainId: number | string) => void;\n};\n\nexport type GetInstance =\n  | (() => any)\n  | ((options: GetInstanceOptions) => Promise<any>);\n\nexport type TryGetInstance =\n  | (() => any)\n  | ((options: Pick<GetInstanceOptions, 'force' | 'network'>) => Promise<any>);\n\nexport type Connect = (options: {\n  instance: any;\n  network?: Network;\n  meta: BlockchainMeta[];\n}) => Promise<ProviderConnectResult | ProviderConnectResult[]>;\n\nexport type Disconnect = (options: {\n  instance: any;\n  destroyInstance: () => void;\n}) => Promise<void>;\n\nexport type Subscribe = (options: {\n  instance: any;\n  state: WalletState;\n  meta: BlockchainMeta[];\n  updateChainId: (chainId: string) => void;\n  updateAccounts: (accounts: string[], chainId?: string) => void;\n  connect: (network?: Network) => void;\n  disconnect: () => void;\n}) => void;\n\nexport type SwitchNetwork = (options: {\n  instance: any;\n  network: Network;\n  meta: BlockchainMeta[];\n  newInstance?: TryGetInstance;\n}) => Promise<void>;\n\nexport type CanSwitchNetwork = (options: {\n  network: Network;\n  meta: BlockchainMeta[];\n  provider: any;\n}) => boolean;\n\nexport type CanEagerConnect = (options: {\n  instance: any;\n  meta: BlockchainMeta[];\n}) => Promise<boolean>;\n\nexport interface WalletActions {\n  connect: Connect;\n  getInstance: any;\n  disconnect?: Disconnect;\n  subscribe?: Subscribe;\n  // unsubscribe, // coupled to subscribe.\n\n  // Optional, but should be provided at the same time.\n  switchNetwork?: SwitchNetwork;\n  getSigners: (provider: any) => SignerFactory;\n  canSwitchNetworkTo?: CanSwitchNetwork;\n  canEagerConnect?: CanEagerConnect;\n  getWalletInfo(allBlockChains: BlockchainMeta[]): WalletInfo;\n}\n\nexport interface WalletConfig {\n  type: WalletType;\n  defaultNetwork?: Network;\n  checkInstallation?: boolean;\n  isAsyncInstance?: boolean;\n}\n\nexport type WalletProviders = Map<\n  WalletType,\n  {\n    actions: WalletActions;\n    config: WalletConfig;\n  }\n>;\n\nexport type ProviderInterface = { config: WalletConfig } & WalletActions;\n", "export interface PersistStorage<T> {\n  getItem: (name: string) => T | null;\n  setItem: (name: string, value: T) => void;\n  removeItem: (name: string) => void;\n}\n\nexport class Persistor<T> implements PersistStorage<T> {\n  getItem(name: string) {\n    const item = localStorage.getItem(name);\n    const parsedItem = item ? (JSON.parse(item) as T) : null;\n    return parsedItem;\n  }\n  setItem(name: string, value: T) {\n    localStorage.setItem(name, JSON.stringify(value));\n  }\n  removeItem(name: string) {\n    localStorage.removeItem(name);\n  }\n}\n", "import { Network } from '@rango-dev/wallets-shared';\nimport { Options } from './wallet';\n\nexport function formatAddressWithNetwork(\n  address: string,\n  network?: Network | null\n) {\n  return `${network || ''}:${address}`;\n}\n\nexport function accountAddressesWithNetwork(\n  addresses: string[] | null,\n  network?: Network | null\n) {\n  if (!addresses) return [];\n\n  return addresses.map((address) => {\n    return formatAddressWithNetwork(address, network);\n  });\n}\n\nexport function readAccountAddress(addressWithNetwork: string): {\n  address: string;\n  network: Network;\n} {\n  const [network, address] = addressWithNetwork.split(':');\n\n  return {\n    network,\n    address,\n  };\n}\n\nexport function needsCheckInstallation(options: Options) {\n  const { checkInstallation = true } = options.config;\n  return checkInstallation;\n}\n", "import type { GetInstanceOptions, WalletActions, WalletConfig } from './types';\nimport type { Network, WalletType } from '@rango-dev/wallets-shared';\nimport type { BlockchainMeta } from 'rango-types';\n\nimport { getBlockChainNameFromId, Networks } from '@rango-dev/wallets-shared';\n\nimport { accountAddressesWithNetwork, needsCheckInstallation } from './helpers';\nimport { Events } from './types';\n\nexport type EventHandler = (\n  type: WalletType,\n  event: Events,\n  value: any,\n  coreState: State,\n  supportedChains: BlockchainMeta[]\n) => void;\n\nexport interface State {\n  connected: boolean;\n  connecting: boolean;\n  reachable: boolean;\n  installed: boolean;\n  accounts: string[] | null;\n  network: Network | null;\n}\n\nexport interface Options {\n  config: WalletConfig;\n  handler: EventHandler;\n}\n\nclass Wallet<InstanceType = any> {\n  private actions: WalletActions;\n  private state: State;\n  private options: Options;\n  private meta: BlockchainMeta[];\n  public provider: InstanceType | null;\n\n  constructor(options: Options, actions: WalletActions) {\n    this.actions = actions;\n    this.options = options;\n    this.provider = null;\n    this.meta = [];\n    this.state = {\n      connected: false,\n      connecting: false,\n      // TODO: Remove\n      reachable: false,\n      installed: false,\n      accounts: null,\n      network: null,\n    };\n\n    if (!needsCheckInstallation(options)) {\n      this.setInstalledAs(true);\n    }\n  }\n\n  private async getConnectionFromState() {\n    // Already connected, so we return provider that we have in memory.\n\n    /*\n     * For switching network on Trust Wallet (WalletConnect),\n     * We only kill the session (and not restting the whole state)\n     * So we are relying on this.provider for achieving this functionality.\n     */\n    if (this.state.connected && !!this.provider) {\n      return {\n        accounts: this.state.accounts,\n        network: this.state.network,\n        provider: this.provider,\n      };\n    }\n\n    return null;\n  }\n  async connect(network?: Network) {\n    // If it's connecting, nothing do.\n    if (this.state.connecting) {\n      throw new Error('Connecting...');\n    }\n\n    const connectionFromState = await this.getConnectionFromState();\n    const currentNetwork = this.state.network;\n    /*\n     * If a network hasn't been provided and also we have `lastNetwork`\n     * We will use lastNetwork to make sure we will not\n     * Ask the user to switch his network wrongly.\n     */\n    const requestedNetwork =\n      network || currentNetwork || this.options.config.defaultNetwork;\n\n    if (connectionFromState) {\n      const networkChanged =\n        currentNetwork !== requestedNetwork && !!requestedNetwork;\n\n      // Reuse current connection if nothing has changed and we already have the connection in memory.\n      if (currentNetwork === requestedNetwork) {\n        return connectionFromState;\n      }\n\n      let canSwitch = true;\n      if (this.actions.canSwitchNetworkTo) {\n        canSwitch = this.actions.canSwitchNetworkTo({\n          provider: this.provider,\n          meta: this.meta,\n          network: requestedNetwork || '',\n        });\n      }\n\n      if (networkChanged && canSwitch && !!this.actions.switchNetwork) {\n        await this.actions.switchNetwork({\n          instance: this.provider,\n          meta: this.meta,\n          // TODO: Fix type error\n          // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n          // @ts-ignore\n          network: requestedNetwork,\n          newInstance: this.tryGetInstance.bind(this),\n        });\n\n        // We assume if we reach here (`switchNetwork` not throwing error), Switch successfully has been done.\n        if (requestedNetwork !== this.state.network) {\n          this.updateState({\n            network,\n          });\n        }\n\n        return {\n          // Only network has been changed, so we reuse accounts from what we have already.\n          accounts: connectionFromState.accounts,\n          network: requestedNetwork,\n          provider: this.provider,\n        };\n      }\n\n      // If none of the above conditions didn't match, continute to connect.\n    }\n\n    // We are connecting to wallet for the first time\n\n    // Trying to get wallet's instance, if it's not available, raise an error.\n    const instance = await this.tryGetInstance({ network });\n\n    // Instance exists, trying to connect\n    this.updateState({\n      connecting: true,\n    });\n    this.setInstalledAs(true);\n\n    try {\n      // eslint-disable-next-line no-var\n      var connectResult = await this.actions.connect({\n        instance,\n        network: requestedNetwork || undefined,\n        meta: this.meta || [],\n      });\n    } catch (e) {\n      this.resetState();\n      throw e;\n    }\n\n    this.updateState({\n      connected: true,\n      reachable: true,\n      connecting: false,\n    });\n\n    // TODO: Handle accounts.length > 0\n\n    // Inserting accounts into our state.\n    let nextAccounts: string[] = [];\n    let nextNetwork: Network | null | undefined = null;\n    if (Array.isArray(connectResult)) {\n      const accounts = connectResult.flatMap((blockchain) => {\n        const chainId = blockchain.chainId || Networks.Unknown;\n        // Try to map chainId with a Network, if not found, we use chainId directly.\n        const network =\n          getBlockChainNameFromId(chainId, this.meta) || Networks.Unknown;\n        // TODO: second parameter should be `string` when we decided to open source the package.\n        return accountAddressesWithNetwork(blockchain.accounts, network);\n      });\n      // Typescript can not detect we are filtering out null values:(\n      nextAccounts = accounts.filter(Boolean);\n      nextNetwork = requestedNetwork || this.options.config.defaultNetwork;\n    } else {\n      const chainId = connectResult.chainId || Networks.Unknown;\n      const network =\n        getBlockChainNameFromId(chainId, this.meta) || Networks.Unknown;\n      // We fallback to current active network if `chainId` not provided.\n      nextAccounts = accountAddressesWithNetwork(\n        connectResult.accounts,\n        network\n      );\n      nextNetwork = network;\n    }\n\n    if (nextAccounts.length > 0) {\n      this.updateState({\n        accounts: nextAccounts,\n        network: nextNetwork,\n      });\n    }\n\n    return {\n      accounts: this.state.accounts,\n      network: this.state.network,\n      provider: this.provider,\n    };\n  }\n\n  async disconnect() {\n    this.resetState();\n\n    if (this.actions.disconnect) {\n      this.actions.disconnect({\n        instance: this.provider,\n        // On wallet connect, we need to destory the instance and get a whole new instance when we are going to connect\n        destroyInstance: () => {\n          this.setProvider(null);\n        },\n      });\n    }\n  }\n\n  // This method is only used for auto connection\n  async eagerConnect() {\n    const instance = await this.tryGetInstance({ network: undefined });\n    const { canEagerConnect } = this.actions;\n    const error_message = `can't restore connection for ${this.options.config.type} .`;\n\n    if (canEagerConnect) {\n      // Check if we can eagerly connect to the wallet\n      const eagerConnection = await canEagerConnect({\n        instance: instance,\n        meta: this.meta,\n      });\n\n      if (eagerConnection) {\n        // Connect to wallet as usual\n        return this.connect();\n      }\n      throw new Error(error_message);\n    } else {\n      throw new Error(error_message);\n    }\n  }\n\n  getSigners(provider: any) {\n    return this.actions.getSigners(provider);\n  }\n  getWalletInfo(allBlockChains: BlockchainMeta[]) {\n    return this.actions.getWalletInfo(allBlockChains);\n  }\n  canSwitchNetworkTo(network: Network, provider: any) {\n    const switchTo = this.actions.canSwitchNetworkTo;\n    if (!switchTo) {\n      return false;\n    }\n\n    return switchTo({\n      network,\n      meta: this.meta,\n      provider,\n    });\n  }\n\n  onInit() {\n    if (!this.options.config.isAsyncInstance) {\n      const instance = this.actions.getInstance();\n      if (!!instance && !this.state.installed) {\n        this.setInstalledAs(true);\n      }\n    } else if (needsCheckInstallation(this.options)) {\n      this.actions.getInstance().then((data: any) => {\n        if (data) {\n          this.setInstalledAs(true);\n        }\n      });\n    }\n  }\n\n  setProvider(value: any) {\n    this.provider = value;\n    if (!!value && !!this.actions.subscribe) {\n      this.actions.subscribe({\n        instance: value,\n        state: this.state,\n        meta: this.meta,\n        connect: this.connect.bind(this),\n        disconnect: this.disconnect.bind(this),\n        updateAccounts: (accounts, chainId) => {\n          let network = this.state.network;\n          if (chainId) {\n            network =\n              getBlockChainNameFromId(chainId, this.meta) || Networks.Unknown;\n          }\n\n          const nextAccounts = accountAddressesWithNetwork(accounts, network);\n          if (nextAccounts.length > 0) {\n            this.updateState({\n              accounts: nextAccounts,\n            });\n          }\n        },\n        updateChainId: this.updateChainId.bind(this),\n      });\n    }\n  }\n\n  setMeta(value: BlockchainMeta[]) {\n    this.meta = value;\n  }\n\n  setHandler(handler: EventHandler) {\n    this.options.handler = handler;\n  }\n\n  getState(): State {\n    return this.state;\n  }\n  updateState(states: Partial<State>) {\n    /*\n     * We will notify handler after updating all the states.\n     * Because when we call `handler` it will has latest states.\n     */\n    const updates: [Events, any][] = [];\n\n    if (typeof states.connected !== 'undefined') {\n      this.state.connected = states.connected;\n      updates.push([Events.CONNECTED, states.connected]);\n    }\n    if (typeof states.connecting !== 'undefined') {\n      this.state.connecting = states.connecting;\n      updates.push([Events.CONNECTING, states.connecting]);\n    }\n    if (typeof states.reachable !== 'undefined') {\n      this.state.reachable = states.reachable;\n      updates.push([Events.REACHABLE, states.reachable]);\n    }\n    if (typeof states.installed !== 'undefined') {\n      this.state.installed = states.installed;\n      updates.push([Events.INSTALLED, states.installed]);\n    }\n    if (typeof states.accounts !== 'undefined') {\n      this.state.accounts = states.accounts;\n      updates.push([Events.ACCOUNTS, states.accounts]);\n    }\n    if (typeof states.network !== 'undefined') {\n      this.state.network = states.network;\n      updates.push([Events.NETWORK, states.network]);\n    }\n\n    const state = this.getState();\n    updates.forEach(([name, value]) => {\n      this.options.handler(\n        this.options.config.type,\n        name,\n        value,\n        state,\n        this.meta\n      );\n    });\n  }\n\n  resetState() {\n    this.updateState({\n      connected: false,\n      connecting: false,\n      reachable: false,\n      accounts: null,\n      network: null,\n    });\n  }\n\n  private updateChainId(chainId: string | number) {\n    const network = chainId\n      ? getBlockChainNameFromId(chainId, this.meta)\n      : Networks.Unknown;\n\n    this.updateState({\n      network,\n    });\n  }\n\n  private setInstalledAs(value: boolean) {\n    if (!needsCheckInstallation(this.options) && value === false) {\n      return;\n    }\n\n    this.updateState({\n      installed: value,\n    });\n  }\n  private async tryGetInstance({\n    network,\n    force,\n  }: {\n    network?: Network;\n    force?: boolean;\n  }) {\n    let instance = null;\n    /*\n     * For switching network on Trust Wallet (WalletConnect),\n     * We only kill the session (and not restting the whole state)\n     * So we are relying on this.provider for achieving this functionality.\n     */\n    this.setProvider(null);\n    if (this.options.config.isAsyncInstance) {\n      // Trying to connect\n      const instanceOptions: GetInstanceOptions = {\n        currentProvider: this.provider,\n        meta: this.meta,\n        force: force || false,\n        updateChainId: this.updateChainId.bind(this),\n        getState: this.getState.bind(this),\n      };\n\n      if (network) {\n        instanceOptions.network = network;\n      }\n      instance = await this.actions.getInstance(instanceOptions);\n    } else {\n      instance = this.actions.getInstance();\n    }\n\n    if (!instance) {\n      this.setInstalledAs(false);\n      this.resetState();\n\n      const error_message = `It seems your selected wallet (${this.options.config.type}) isn't installed.`;\n      throw new Error(error_message);\n    }\n\n    this.setProvider(instance);\n    return instance;\n  }\n}\n\nexport default Wallet;\n"],
  "mappings": "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",
  "names": ["Events", "Persistor", "name", "item", "value", "__name", "formatAddressWithNetwork", "address", "network", "__name", "accountAddressesWithNetwork", "addresses", "readAccountAddress", "addressWithNetwork", "needsCheckInstallation", "options", "checkInstallation", "getBlockChainNameFromId", "Networks", "Wallet", "options", "actions", "needsCheckInstallation", "network", "connectionFromState", "currentNetwork", "requestedNetwork", "networkChanged", "canSwitch", "instance", "connectResult", "e", "nextAccounts", "nextNetwork", "blockchain", "chainId", "Networks", "getBlockChainNameFromId", "accountAddressesWithNetwork", "canEagerConnect", "error_message", "provider", "allBlockChains", "switchTo", "data", "value", "accounts", "handler", "states", "updates", "state", "name", "force", "instanceOptions", "__name", "wallet_default"]
}
