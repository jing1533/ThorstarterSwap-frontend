var N=Object.defineProperty;var c=(e,t)=>N(e,"name",{value:t,configurable:!0});import{Persistor as m}from"@rango-dev/wallets-core";var p="last-connected-wallets";function K(e,t){return e.find(i=>i.type===t)||null}c(K,"choose");var g={connected:!1,connecting:!1,reachable:!1,installed:!1,accounts:null,network:null};function P(e,t){if(t.type==="new_state"){let i=e[t.wallet];return i?{...e,[t.wallet]:{...i,[t.name]:t.value}}:{...e,[t.wallet]:{...g,[t.name]:t.value}}}return e}c(P,"state_reducer");function I(e){return Object.entries(e).filter(([,t])=>t?.connected).map(([t])=>t)}c(I,"connectedWallets");function k(e){return Object.entries(e).map(([t])=>t)}c(k,"availableWallets");function x(e){let t=new Map;return e.forEach(i=>{let{config:a,...o}=i;t.set(a.type,{actions:o,config:a})}),t}c(x,"checkWalletProviders");function q(e){return e?.constructor?.name==="AsyncFunction"}c(q,"isAsync");function J(e){let{checkInstallation:t=!0}=e.config;return t}c(J,"needsCheckInstallation");async function S({type:e,walletActions:t,getState:i}){if(t.canEagerConnect){let a=new m,o=a.getItem(p);o?.find(s=>!i(s).connected)&&C();let d=!!o?.find(s=>s===e);o&&!d?a.setItem(p,o.concat(e)):a.setItem(p,[e])}}c(S,"tryPersistWallet");function E({type:e,walletActions:t}){if(t.canEagerConnect){let i=new m,a=i.getItem(p);a&&i.setItem(p,a.filter(o=>o!==e))}}c(E,"tryRemoveWalletFromPersistance");function C(){let e=new m;e.getItem(p)&&e.removeItem(p)}c(C,"clearPersistance");async function T(e,t){let i=new m,a=i.getItem(p);if(a&&a.length){let o=[];a.forEach(s=>{let n=e.get(s);if(n){let r=t(n);o.push({walletType:s,eagerConnect:r.eagerConnect.bind(r)})}});let u=await Promise.allSettled(o.map(({eagerConnect:s})=>s()));if(!!u.find(({status:s})=>s==="fulfilled")){let s=[];u.forEach(({status:n},r)=>{n==="rejected"&&s.push(o[r].walletType)}),s.length&&i.setItem(p,a.filter(n=>!s.includes(n)))}}}c(T,"autoConnect");function v(e,t){return c((a,o,u,d,s)=>{e({type:"new_state",wallet:a,name:o,value:u}),t&&t(a,o,u,d,s)},"handler")}c(v,"makeEventHandler");import L,{useEffect as h,useReducer as _,useRef as F}from"react";import{useContext as R,useRef as H}from"react";import{createContext as b}from"react";var w="Context hasn't been initialized yet.",B={async connect(){throw new Error(w)},async disconnect(){throw new Error(w)},async disconnectAll(){throw new Error(w)},state(){throw new Error(w)},canSwitchNetworkTo(){throw new Error(w)},providers(){throw new Error(w)},getWalletInfo(){throw new Error(w)},getSigners(){throw new Error(w)}},W=b(B);import O from"@rango-dev/wallets-core";function A(e){let t=H({});function i(a){let o=a.config.type;return typeof t.current[o]>"u"&&(t.current[o]=new O({config:a.config,handler:e},a.actions)),t.current[o]}return c(i,"updater"),i}c(A,"useInitializers");function M(){let e=R(W);if(!e)throw Error("useWallet can only be used within the Provider component");return e}c(M,"useWallets");function D(e){let[t,i]=_(P,{}),a=F(!1),o=A(v(i,e.onUpdateState)),u=e.providers,d=x(u),s={async connect(n,r){let l=d.get(n);if(!l)throw new Error(`You should add ${n} to provider first.`);let y=await o(l).connect(r);return e.autoConnect&&S({type:n,walletActions:l.actions,getState:s.state}),y},async disconnect(n){let r=d.get(n);if(!r)throw new Error(`You should add ${n} to provider first.`);await o(r).disconnect(),e.autoConnect&&E({type:n,walletActions:r.actions})},async disconnectAll(){let n=[];return I(t).forEach(r=>{let l=d.get(r);if(l){let f=o(l);n.push(f.disconnect())}}),e.autoConnect&&C(),await Promise.allSettled(n)},state(n){return t[n]||g},canSwitchNetworkTo(n,r){let l=d.get(n);if(!l)return!1;let f=o(l);return f.canSwitchNetworkTo?f.canSwitchNetworkTo(r,f.provider):!1},providers(){let n={};return k(t).forEach(r=>{let l=d.get(r);if(l){let f=o(l);n[r]=f.provider}}),n},getWalletInfo(n){let r=d.get(n);if(!r)throw new Error(`You should add ${n} to provider first.`);return r.actions.getWalletInfo(e.allBlockChains||[])},getSigners(n){let r=d.get(n);if(!r)throw new Error(`You should add ${n} to provider first.`);let l=o(r),f=l.provider;return l.getSigners(f)}};return h(()=>{d.forEach(n=>{let r=o(n),l=c(()=>{r.onInit&&r.onInit()},"runOnInit"),f=c(y=>{y.target&&y.target.readyState==="complete"&&(l(),document.removeEventListener("readystatechange",f))},"initWhenPageIsReady");l(),document.addEventListener("readystatechange",f)})},[]),h(()=>{e.allBlockChains&&d.forEach(r=>{let l=o(r),f=l.getWalletInfo(e.allBlockChains||[]).supportedChains;l.setMeta(f)})},[e.allBlockChains]),h(()=>{d.forEach(n=>{o(n).setHandler(v(i,e.onUpdateState))})},[e.onUpdateState]),h(()=>{e.allBlockChains&&e.allBlockChains.length&&e.autoConnect&&!a.current&&(a.current=!0,(async()=>await T(d,o))())},[e.autoConnect,e.allBlockChains]),L.createElement(W.Provider,{value:s},e.children)}c(D,"Provider");var G=D;import{Events as ge,readAccountAddress as Ce}from"@rango-dev/wallets-core";export{ge as Events,G as Provider,T as autoConnect,k as availableWallets,x as checkWalletProviders,K as choose,C as clearPersistance,I as connectedWallets,g as defaultWalletState,q as isAsync,v as makeEventHandler,J as needsCheckInstallation,Ce as readAccountAddress,P as state_reducer,S as tryPersistWallet,E as tryRemoveWalletFromPersistance,M as useWallets};
//# sourceMappingURL=index.js.map
