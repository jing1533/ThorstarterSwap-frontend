{
  "version": 3,
  "sources": ["../src/helpers.ts", "../src/signer.ts"],
  "sourcesContent": ["import type { AminoSignResponse } from '@cosmjs/launchpad';\nimport type { Keplr, KeplrSignOptions } from '@keplr-wallet/types';\nimport type { CosmosTransaction } from 'rango-types';\n\nimport { BroadcastMode, makeSignDoc } from '@cosmjs/launchpad';\nimport { SigningStargateClient } from '@cosmjs/stargate';\nimport { cosmos } from '@keplr-wallet/cosmos';\nimport { MsgExecuteContract } from 'cosmjs-types/cosmwasm/wasm/v1/tx.js';\nimport Long from 'long';\nimport { SignerError, SignerErrorCode } from 'rango-types';\n\nconst STARGATE_CLIENT_OPTIONS = {\n  gasLimits: {\n    transfer: 250000,\n  },\n};\n\nconst uint8ArrayToHex = (buffer: Uint8Array): string => {\n  return Buffer.from(buffer).toString('hex');\n};\n\nexport const executeCosmosTransaction = async (\n  cosmosTx: CosmosTransaction,\n  cosmosProvider: Keplr\n): Promise<string> => {\n  if (!cosmosProvider) {\n    throw SignerError.AssertionFailed('wallet is null!');\n  }\n  try {\n    const {\n      memo,\n      sequence,\n      account_number,\n      chainId,\n      msgs,\n      fee,\n      signType,\n      rpcUrl,\n    } = cosmosTx.data;\n    const msgsWithoutType = msgs.map((m) => ({\n      ...m,\n      __type: undefined,\n      '@type': undefined,\n    }));\n    if (!chainId) {\n      throw SignerError.AssertionFailed('chainId is undefined from server');\n    }\n    if (!account_number) {\n      throw SignerError.AssertionFailed(\n        'account_number is undefined from server'\n      );\n    }\n    if (!sequence) {\n      throw SignerError.AssertionFailed('sequence is undefined from server');\n    }\n\n    if (signType === 'AMINO') {\n      const signDoc = makeSignDoc(\n        msgsWithoutType as any,\n        fee as any,\n        chainId,\n        memo || undefined,\n        account_number,\n        sequence\n      );\n      let signOptions = {};\n      if (\n        cosmosTx.data.chainId === 'osmosis-1' &&\n        fee?.amount[0]?.amount === '0'\n      ) {\n        signOptions = { preferNoSetFee: true };\n      }\n      let signResponse;\n      try {\n        signResponse = await cosmosProvider.signAmino(\n          chainId,\n          cosmosTx.fromWalletAddress,\n          signDoc,\n          signOptions as KeplrSignOptions\n        );\n      } catch (err) {\n        throw new SignerError(SignerErrorCode.SIGN_TX_ERROR, undefined, err);\n      }\n      const signedTx = getsignedTx(cosmosTx, signResponse);\n      const result = await cosmosProvider.sendTx(\n        chainId,\n        signedTx,\n        BroadcastMode.Async\n      );\n      return uint8ArrayToHex(result);\n    } else if (signType === 'DIRECT') {\n      const sendingSigner = cosmosProvider?.getOfflineSigner(chainId);\n      const sendingStargateClient =\n        await SigningStargateClient?.connectWithSigner(\n          rpcUrl,\n          sendingSigner,\n          {}\n        );\n      sendingStargateClient.registry.register(\n        '/cosmwasm.wasm.v1.MsgExecuteContract',\n        MsgExecuteContract\n      );\n      const feeArray = !!fee?.amount[0]\n        ? [{ denom: fee.amount[0].denom, amount: fee?.amount[0].amount }]\n        : [];\n\n      const defaultGas = STARGATE_CLIENT_OPTIONS.gasLimits.transfer.toString();\n      const gasLimit =\n        typeof fee?.gas === 'string'\n          ? Long.fromString(fee?.gas).toString()\n          : defaultGas;\n      const broadcastTxRes = await sendingStargateClient.signAndBroadcast(\n        cosmosTx.fromWalletAddress,\n        msgsWithoutType,\n        {\n          gas: gasLimit,\n          amount: feeArray,\n        }\n      );\n      return broadcastTxRes.transactionHash;\n    }\n    throw new SignerError(\n      SignerErrorCode.OPERATION_UNSUPPORTED,\n      `Sign type for cosmos not supported, type: ${signType}`\n    );\n  } catch (err) {\n    console.log({ err });\n    if (SignerError.isSignerError(err)) {\n      throw err;\n    } else {\n      throw new SignerError(SignerErrorCode.SEND_TX_ERROR, undefined, err);\n    }\n  }\n};\n\nexport function getsignedTx(\n  cosmosTx: CosmosTransaction,\n  signResponse: AminoSignResponse\n) {\n  let signedTx;\n\n  if (cosmosTx.data.protoMsgs.length > 0) {\n    /*\n     * based on this link:\n     * https://github.com/chainapsis/keplr-wallet/blob/40211c8dd75ccbdc4c868db9dc22599f4cb952e9/packages/stores/src/account/cosmos.ts#L508\n     */\n    signedTx = cosmos.tx.v1beta1.TxRaw.encode({\n      bodyBytes: cosmos.tx.v1beta1.TxBody.encode({\n        messages: cosmosTx.data.protoMsgs.map((m) => ({\n          type_url: m.type_url,\n          value: new Uint8Array(m.value),\n        })),\n        memo: signResponse.signed.memo,\n      }).finish(),\n      authInfoBytes: cosmos.tx.v1beta1.AuthInfo.encode({\n        signerInfos: [\n          {\n            publicKey: {\n              type_url: '/cosmos.crypto.secp256k1.PubKey',\n              value: cosmos.crypto.secp256k1.PubKey.encode({\n                key: Buffer.from(\n                  signResponse.signature.pub_key.value,\n                  'base64'\n                ),\n              }).finish(),\n            },\n            modeInfo: {\n              single: {\n                mode: cosmos.tx.signing.v1beta1.SignMode\n                  .SIGN_MODE_LEGACY_AMINO_JSON,\n              },\n            },\n            sequence: Long.fromString(signResponse.signed.sequence),\n          },\n        ],\n        fee: {\n          amount: signResponse.signed.fee.amount as any[],\n          gasLimit: Long.fromString(signResponse.signed.fee.gas),\n        },\n      }).finish(),\n      signatures: [Buffer.from(signResponse.signature.signature, 'base64')],\n    }).finish();\n  } else {\n    throw SignerError.AssertionFailed(\n      'protoMsgs is required in Amino messages'\n    );\n  }\n  return signedTx;\n}\n", "import type { GenericSigner, CosmosTransaction } from 'rango-types';\nimport { executeCosmosTransaction } from './helpers';\nimport { Keplr } from '@keplr-wallet/types';\n\ntype CosmosExternalProvider = Keplr;\n\nexport class DefaultCosmosSigner implements GenericSigner<CosmosTransaction> {\n  private provider: CosmosExternalProvider;\n\n  constructor(provider: CosmosExternalProvider) {\n    this.provider = provider;\n  }\n\n  async signMessage(\n    msg: string,\n    address: string,\n    chainId: string | null\n  ): Promise<string> {\n    if (!chainId) throw Error('ChainId is required');\n    const { signature } = await this.provider.signArbitrary(\n      chainId,\n      address,\n      msg\n    );\n    return signature;\n  }\n\n  async signAndSendTx(tx: CosmosTransaction): Promise<{ hash: string }> {\n    const hash = await executeCosmosTransaction(tx, this.provider);\n    return { hash };\n  }\n}\n"],
  "mappings": "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",
  "names": ["BroadcastMode", "makeSignDoc", "SigningStargateClient", "cosmos", "MsgExecuteContract", "Long", "SignerError", "SignerErrorCode", "STARGATE_CLIENT_OPTIONS", "uint8ArrayToHex", "__name", "buffer", "executeCosmosTransaction", "cosmosTx", "cosmosProvider", "SignerError", "memo", "sequence", "account_number", "chainId", "msgs", "fee", "signType", "rpcUrl", "msgsWithoutType", "signDoc", "makeSignDoc", "signOptions", "signResponse", "err", "SignerErrorCode", "signedTx", "getsignedTx", "result", "BroadcastMode", "sendingSigner", "sendingStargateClient", "SigningStargateClient", "MsgExecuteContract", "feeArray", "defaultGas", "gasLimit", "Long", "cosmos", "m", "DefaultCosmosSigner", "provider", "msg", "address", "chainId", "signature", "tx", "executeCosmosTransaction", "__name"]
}
