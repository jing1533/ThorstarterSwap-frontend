{
  "version": 3,
  "sources": ["../src/rango.ts", "../src/helpers.ts", "../src/providers.ts", "../src/getCosmosAccounts.ts"],
  "sourcesContent": ["import type { BlockchainMeta, EvmBlockchainMeta } from 'rango-types';\n\nexport const IS_DEV =\n  !process.env.NODE_ENV || process.env.NODE_ENV === 'development';\n\nexport const getBlockChainNameFromId = (\n  chainId: string | number,\n  blockchains: BlockchainMeta[]\n): Network | null => {\n  chainId =\n    typeof chainId === 'string' && chainId.startsWith('0x')\n      ? parseInt(chainId)\n      : chainId;\n\n  /*\n   * Sometimes providers are passing `Network` as chainId.\n   * If chainId is a `Network`, we return itself.\n   */\n  const allNetworks = Object.values(Networks) as string[];\n  if (allNetworks.includes(String(chainId))) {\n    return chainId as Networks;\n  }\n\n  if (chainId === 'Binance-Chain-Tigris') {\n    return Networks.BINANCE;\n  }\n  return (\n    blockchains\n      .filter((blockchainMeta) => !!blockchainMeta.chainId)\n      .find((blockchainMeta) => {\n        const blockchainChainId = blockchainMeta.chainId?.startsWith('0x')\n          ? parseInt(blockchainMeta.chainId)\n          : blockchainMeta.chainId;\n        return blockchainChainId == chainId;\n      })?.name || null\n  );\n};\n\nexport const getBlockchainChainIdByName = (\n  netwok: Network,\n  allBlockChains: AllBlockchains\n) => allBlockChains[netwok]?.chainId || null;\n\nexport const uint8ArrayToHex = (buffer: Uint8Array): string => {\n  return Buffer.from(buffer).toString('hex');\n};\n\nexport type WalletType = string;\nexport type Network = string;\n\nexport enum WalletTypes {\n  META_MASK = 'metamask',\n  WALLET_CONNECT_2 = 'wallet-connect-2',\n  TRUST_WALLET = 'trust-wallet',\n  KEPLR = 'keplr',\n  PHANTOM = 'phantom',\n  BINANCE_CHAIN = 'binance-chain',\n  BITGET = 'bitget',\n  TRON_LINK = 'tron-link',\n  COINBASE = 'coinbase',\n  XDEFI = 'xdefi',\n  CLOVER = 'clover',\n  ARGENTX = 'argentx',\n  FRONTIER = 'frontier',\n  COSMOSTATION = 'cosmostation',\n  COIN98 = 'coin98',\n  SAFEPAL = 'safepal',\n  SAFE = 'safe',\n  TOKEN_POCKET = 'token-pocket',\n  BRAVE = 'brave',\n  BRAAVOS = 'braavos',\n  MATH = 'math',\n  EXODUS = 'exodus',\n  OKX = 'okx',\n  HALO = 'halo',\n  LEAP = 'leap',\n  LEAP_COSMOS = 'leap-cosmos',\n  STATION = 'station',\n  ENKRYPT = 'enkrypt',\n  TAHO = 'taho',\n  MY_TON_WALLET = 'mytonwallet',\n}\n\nexport enum Networks {\n  BTC = 'BTC',\n  BSC = 'BSC',\n  LTC = 'LTC',\n  THORCHAIN = 'THOR',\n  BCH = 'BCH',\n  BINANCE = 'BNB',\n  ETHEREUM = 'ETH',\n  POLYGON = 'POLYGON',\n  TERRA = 'TERRA',\n  POLKADOT = '',\n  TRON = 'TRON',\n  DOGE = 'DOGE',\n  HARMONY = 'HARMONY',\n  AVAX_CCHAIN = 'AVAX_CCHAIN',\n  FANTOM = 'FANTOM',\n  MOONBEAM = 'MOONBEAM',\n  ARBITRUM = 'ARBITRUM',\n  BOBA = 'BOBA',\n  OPTIMISM = 'OPTIMISM',\n  FUSE = 'FUSE',\n  CRONOS = 'CRONOS',\n  SOLANA = 'SOLANA',\n  MOONRIVER = 'MOONRIVER',\n  GNOSIS = 'GNOSIS',\n  COSMOS = 'COSMOS',\n  OSMOSIS = 'OSMOSIS',\n  AKASH = 'AKASH',\n  IRIS = 'IRIS',\n  PERSISTENCE = 'PERSISTENCE',\n  SENTINEL = 'SENTINEL',\n  REGEN = 'REGEN',\n  CRYPTO_ORG = 'CRYPTO_ORG',\n  SIF = 'SIF',\n  CHIHUAHUA = 'CHIHUAHUA',\n  JUNO = 'JUNO',\n  KUJIRA = 'KUJIRA',\n  STARNAME = 'STARNAME',\n  COMDEX = 'COMDEX',\n  STARGAZE = 'STARGAZE',\n  DESMOS = 'DESMOS',\n  BITCANNA = 'BITCANNA',\n  SECRET = 'SECRET',\n  INJECTIVE = 'INJECTIVE',\n  LUMNETWORK = 'LUMNETWORK',\n  BANDCHAIN = 'BANDCHAIN',\n  EMONEY = 'EMONEY',\n  BITSONG = 'BITSONG',\n  KI = 'KI',\n  MEDIBLOC = 'MEDIBLOC',\n  KONSTELLATION = 'KONSTELLATION',\n  UMEE = 'UMEE',\n  STARKNET = 'STARKNET',\n  TON = 'TON',\n\n  // Using instead of null\n  Unknown = 'Unkown',\n}\n\nexport const XDEFI_WALLET_SUPPORTED_NATIVE_CHAINS: string[] = [\n  Networks.BTC,\n  Networks.LTC,\n  Networks.THORCHAIN,\n  Networks.BCH,\n  Networks.BINANCE,\n];\n\nexport const KEPLR_COMPATIBLE_WALLETS: string[] = [\n  WalletTypes.KEPLR,\n  WalletTypes.COSMOSTATION,\n];\n\nexport type Asset = {\n  blockchain: Network;\n  symbol: string;\n  address: string | null;\n};\n\nexport type AllBlockchains = { [key: string]: BlockchainMeta };\n\nexport type AddEthereumChainParameter = {\n  chainId: string; // A 0x-prefixed hexadecimal string\n  chainName: string;\n  nativeCurrency: {\n    name: string;\n    symbol: string; // 2-6 characters long\n    decimals: number;\n  };\n  rpcUrls: string[];\n  blockExplorerUrls?: string[];\n  iconUrls?: string[]; // Currently ignored.\n};\n\nexport type EvmNetworksChainInfo = { [key: string]: AddEthereumChainParameter };\n\nexport interface Meta {\n  blockchains: AllBlockchains;\n  evmNetworkChainInfo: EvmNetworksChainInfo;\n  getSupportedChainNames: (type: WalletType) => Network[] | null;\n  evmBasedChains: EvmBlockchainMeta[];\n}\n\n// core\n\n// wallets/core/src/wallet.ts -> State\nexport interface WalletState {\n  connected: boolean;\n  connecting: boolean;\n  reachable: boolean;\n  installed: boolean;\n  accounts: string[] | null;\n  network: Network | null;\n}\n\nexport interface WalletConfig {\n  type: WalletType;\n  defaultNetwork?: Network;\n  checkInstallation?: boolean;\n  isAsyncInstance?: boolean;\n}\n\nexport type GetInstanceOptions = {\n  network?: Network;\n  currentProvider: any;\n  meta: BlockchainMeta[];\n  force?: boolean;\n  updateChainId: (chainId: number | string) => void;\n  getState: () => WalletState;\n};\n\nexport type TryGetInstance =\n  | (() => any)\n  | ((options: Pick<GetInstanceOptions, 'force' | 'network'>) => Promise<any>);\n\nexport type GetInstance =\n  | (() => any)\n  | ((options: GetInstanceOptions) => Promise<any>);\n\nexport type ProviderConnectResult = {\n  accounts: string[];\n  chainId: string;\n};\n\nexport type Connect = (options: {\n  instance: any;\n  network?: Network;\n  meta: BlockchainMeta[];\n}) => Promise<ProviderConnectResult | ProviderConnectResult[]>;\n\nexport type Disconnect = (options: {\n  instance: any;\n  destroyInstance: () => void;\n}) => Promise<void>;\n\nexport type Subscribe = (options: {\n  instance: any;\n  state: WalletState;\n  meta: BlockchainMeta[];\n  updateChainId: (chainId: string) => void;\n  updateAccounts: (accounts: string[], chainId?: string) => void;\n  connect: (network?: Network) => void;\n  disconnect: () => void;\n}) => void;\n\nexport type CanEagerConnect = (options: {\n  instance: any;\n  meta: BlockchainMeta[];\n}) => Promise<boolean>;\n\nexport type SwitchNetwork = (options: {\n  instance: any;\n  network: Network;\n  meta: BlockchainMeta[];\n  newInstance?: TryGetInstance;\n}) => Promise<void>;\n\nexport type CanSwitchNetwork = (options: {\n  network: Network;\n  meta: BlockchainMeta[];\n  provider: any;\n}) => boolean;\n\nexport type InstallObjects = {\n  CHROME?: string;\n  FIREFOX?: string;\n  EDGE?: string;\n  BRAVE?: string;\n  DEFAULT: string;\n};\n\nexport type WalletInfo = {\n  name: string;\n  img: string;\n  installLink: InstallObjects | string;\n  color: string;\n  supportedChains: BlockchainMeta[];\n  showOnMobile?: boolean;\n  mobileWallet?: boolean;\n};\n\nexport interface Wallet {\n  type: WalletType;\n  extensionAvailable: boolean;\n  connected: boolean;\n  info: Omit<WalletInfo, 'color' | 'supportedChains'>;\n}\n", "import type { EvmBlockchainMeta } from 'rango-types';\nimport {\n  EvmNetworksChainInfo,\n  AddEthereumChainParameter,\n  Network,\n  Networks,\n  Connect,\n  Wallet,\n  InstallObjects,\n} from './rango';\n\nexport { isAddress as isEvmAddress } from 'ethers/lib/utils.js';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function deepCopy(obj: any): any {\n  let copy;\n\n  // Handle the 3 simple types, and null or undefined\n  if (null == obj || 'object' != typeof obj) return obj;\n\n  // Handle Date\n  if (obj instanceof Date) {\n    copy = new Date();\n    copy.setTime(obj.getTime());\n    return copy;\n  }\n\n  // Handle Array\n  if (obj instanceof Array) {\n    copy = [];\n    for (let i = 0, len = obj.length; i < len; i++) {\n      copy[i] = deepCopy(obj[i]);\n    }\n    return copy;\n  }\n\n  // Handle Object\n  if (obj instanceof Object) {\n    copy = {} as any;\n    for (const attr in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, attr))\n        copy[attr] = deepCopy(obj[attr]);\n    }\n    return copy;\n  }\n\n  throw new Error(\"Unable to copy obj! Its type isn't supported.\");\n}\n\nexport async function switchOrAddNetworkForMetamaskCompatibleWallets(\n  instance: any,\n  network: Network,\n  evmNetworksChainInfo: EvmNetworksChainInfo\n) {\n  const targetChain = evmNetworksChainInfo[network];\n\n  try {\n    await instance.request({\n      method: 'wallet_switchEthereumChain',\n      params: [{ chainId: targetChain?.chainId }],\n    });\n  } catch (switchError) {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    // To resolve this error: Catch clause variable type annotation must be any or unknown if specified\n    const error = switchError as { code: number };\n\n    if (!targetChain) {\n      throw new Error(\n        `It seems you don't have ${network} network on your wallet. Please add it manually.`\n      );\n    } else if (error.code === 4902 || !error.code) {\n      // Note: on WalletConnect `code` is undefined so we have to use !switchError.code as fallback.\n      // This error code indicates that the chain has not been added to wallet.\n      await instance.request({\n        method: 'wallet_addEthereumChain',\n        params: [targetChain],\n      });\n    }\n    throw switchError;\n  }\n}\n\nexport function timeout<T = any>(\n  forPromise: Promise<any>,\n  time: number\n): Promise<T> {\n  const timeoutPromise = new Promise((_, reject) => {\n    setTimeout(() => {\n      reject('Timeout!');\n    }, time);\n  });\n\n  return Promise.race([forPromise, timeoutPromise]);\n}\n\nexport const convertEvmBlockchainMetaToEvmChainInfo = (\n  evmBlockchains: EvmBlockchainMeta[]\n) =>\n  evmBlockchains.reduce(\n    (\n      evmNetWorksChainInfo: { [key: string]: AddEthereumChainParameter },\n      blockchainMeta\n    ) => (\n      (evmNetWorksChainInfo[blockchainMeta.name] = {\n        chainName: blockchainMeta.info.chainName,\n        chainId: blockchainMeta.chainId,\n        nativeCurrency: blockchainMeta.info.nativeCurrency,\n        rpcUrls: blockchainMeta.info.rpcUrls,\n        blockExplorerUrls: blockchainMeta.info.blockExplorerUrls,\n      }),\n      evmNetWorksChainInfo\n    ),\n    {}\n  );\n\nexport const evmChainsToRpcMap = (\n  evmNetworkChainInfo: EvmNetworksChainInfo\n) => {\n  return Object.fromEntries(\n    new Map(\n      Object.keys(evmNetworkChainInfo).map((chainName) => {\n        const info = evmNetworkChainInfo[chainName];\n\n        // This `if` is only used for satisfying typescript,\n        // Because we iterating over Object.keys(EVM_NETWORKS_CHAIN_INFO)\n        // And obviously it cannot be `undefined` and always has a value.\n        if (info) {\n          return [parseInt(info.chainId), info.rpcUrls[0]];\n        }\n        return [0, ''];\n      })\n    )\n  );\n};\n\nexport const getSolanaAccounts: Connect = async ({ instance }) => {\n  // Asking for account from wallet.\n  const solanaResponse = await instance.connect();\n\n  const account = solanaResponse.publicKey.toString();\n  return {\n    accounts: [account],\n    chainId: Networks.SOLANA,\n  };\n};\n\nexport function getCoinbaseInstance(\n  lookingFor: 'coinbase' | 'metamask' = 'coinbase'\n) {\n  const { ethereum, coinbaseSolana } = window;\n  const instances = new Map();\n  if (ethereum) {\n    const checker =\n      lookingFor === 'metamask' ? 'isMetaMask' : 'isCoinbaseWallet';\n\n    // If only Coinbase Wallet is installed\n    if (lookingFor === 'coinbase' && ethereum[checker]) {\n      instances.set(Networks.ETHEREUM, ethereum);\n    }\n    // If Coinbase Wallet and Metamask is installed at the same time.\n    else if (ethereum.providers?.length) {\n      const ethInstance = ethereum.providers.find((provider: any) => {\n        return provider[checker];\n      });\n      instances.set(Networks.ETHEREUM, ethInstance);\n    }\n  }\n  if (!!coinbaseSolana && lookingFor === 'coinbase')\n    instances.set(Networks.SOLANA, coinbaseSolana);\n\n  if (instances.size === 0) return null;\n\n  if (lookingFor === 'metamask') return instances.get(Networks.ETHEREUM);\n\n  return instances;\n}\n\nexport function sortWalletsBasedOnState(wallets: Wallet[]): Wallet[] {\n  return wallets.sort(\n    (a, b) =>\n      Number(b.connected) - Number(a.connected) ||\n      Number(b.extensionAvailable) - Number(a.extensionAvailable)\n  );\n}\n\nfunction isBrave() {\n  let isBrave = false;\n  const nav: any = navigator;\n  if (nav.brave && nav.brave.isBrave) {\n    nav.brave.isBrave().then((res: boolean) => {\n      if (res) isBrave = true;\n    });\n  }\n\n  return isBrave;\n}\n\nexport function detectInstallLink(install: InstallObjects | string): string {\n  if (typeof install !== 'object') {\n    return install;\n  } else {\n    let link;\n    if (isBrave()) {\n      link = install.BRAVE;\n    } else if (navigator.userAgent?.toLowerCase().indexOf('chrome') !== -1) {\n      link = install.CHROME;\n    } else if (navigator.userAgent?.toLowerCase().indexOf('firefox') !== -1) {\n      link = install.FIREFOX;\n    } else if (navigator.userAgent?.toLowerCase().indexOf('edge') !== -1) {\n      link = install.EDGE;\n    }\n    return link || install.DEFAULT;\n  }\n}\n\nexport function detectMobileScreens(): boolean {\n  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(\n    navigator.userAgent\n  );\n}\n", "import {\n  Network,\n  CanSwitchNetwork,\n  Subscribe,\n  SwitchNetwork,\n  Networks,\n  CanEagerConnect,\n} from './rango';\nimport { convertEvmBlockchainMetaToEvmChainInfo } from './helpers';\nimport { switchOrAddNetworkForMetamaskCompatibleWallets } from './helpers';\nimport type { BlockchainMeta } from 'rango-types';\nimport { isEvmBlockchain } from 'rango-types';\n\nexport async function getEvmAccounts(instance: any) {\n  const [accounts, chainId] = await Promise.all([\n    instance.request({ method: 'eth_requestAccounts' }) as Promise<string[]>,\n    instance.request({ method: 'eth_chainId' }) as Promise<string>,\n  ]);\n\n  return {\n    accounts,\n    chainId,\n  };\n}\n\nexport const subscribeToEvm: Subscribe = ({\n  instance,\n  state,\n  updateChainId,\n  updateAccounts,\n}) => {\n  instance?.on('accountsChanged', (addresses: string[]) => {\n    // TODO: after enabling autoconnect, we can consider this condition\n    // to be removed.\n    // The problem was if a user already connected its wallet,\n    // Metamask is triggering this event on first load, so when autoconnect is disabled,\n    // it's automaticlally change the state of wallet to `connected`.\n    if (state.connected) {\n      updateAccounts(addresses);\n    }\n  });\n\n  instance?.on('chainChanged', (chainId: string) => {\n    updateChainId(chainId);\n  });\n};\n\nexport const canEagerlyConnectToEvm: CanEagerConnect = async ({ instance }) => {\n  try {\n    const accounts: string[] = await instance.request({\n      method: 'eth_accounts',\n    });\n    if (accounts.length) return true;\n    else return false;\n  } catch (error) {\n    return false;\n  }\n};\n\nexport const switchNetworkForEvm: SwitchNetwork = async ({\n  instance,\n  network,\n  meta,\n}) => {\n  const evmBlockchains = meta.filter(isEvmBlockchain);\n  const evmInstance = getNetworkInstance(instance, Networks.ETHEREUM);\n  await switchOrAddNetworkForMetamaskCompatibleWallets(\n    evmInstance,\n    network,\n    convertEvmBlockchainMetaToEvmChainInfo(evmBlockchains)\n  );\n};\n\nexport const canSwitchNetworkToEvm: CanSwitchNetwork = ({ network, meta }) => {\n  return evmNetworkNames(meta).includes(network);\n};\n\nexport function evmNetworkNames(meta: BlockchainMeta[]) {\n  return meta.filter(isEvmBlockchain).map((blockchain) => blockchain.name);\n}\nexport function getEthChainsInstance(\n  network: Network | null,\n  meta: BlockchainMeta[]\n): Network | null {\n  if (!network) return null;\n  const evmBlockchains = evmNetworkNames(meta);\n  return evmBlockchains.includes(network) ? Networks.ETHEREUM : null;\n}\n\nfunction isEvmNetwork(network: Network | null, meta: BlockchainMeta[]) {\n  if (!network) return false;\n\n  return evmNetworkNames(meta).includes(network);\n}\n\nexport function chooseInstance(\n  instances: null | Map<any, any>,\n  meta: BlockchainMeta[],\n  network?: Network | null\n) {\n  // If there is no `network` we fallback to default network.\n  network = network || Networks.ETHEREUM;\n  const instance_network_name = isEvmNetwork(network, meta)\n    ? getEthChainsInstance(network, meta)\n    : network;\n  const instance =\n    !!instances && !!instance_network_name\n      ? instances.get(instance_network_name)\n      : null;\n\n  return instance;\n}\n\nexport function getNetworkInstance(provider: any, network: Network) {\n  return provider.size ? provider.get(network) : provider;\n}\n", "import type {\n  BlockchainMeta,\n  CosmosBlockchainMeta,\n  CosmosChainInfo,\n} from 'rango-types';\nimport { deepCopy } from './helpers';\nimport { Connect, ProviderConnectResult } from './rango';\nimport { Keplr as InstanceType } from '@keplr-wallet/types';\n\nexport interface CosmosInfo extends Omit<CosmosChainInfo, 'experimental'> {\n  chainId: string;\n}\n\nexport type CosmosExperimentalChainsInfo = {\n  [k: string]: { id: string; info: CosmosInfo; experimental: boolean };\n};\n\ninterface CosmosBlockchainMetaWithChainId\n  extends Omit<CosmosBlockchainMeta, 'chainId'> {\n  chainId: string;\n}\n\nconst getCosmosMainChainsIds = (blockchains: CosmosBlockchainMeta[]) =>\n  blockchains\n    .filter((blockchain) => !blockchain.info?.experimental)\n    .map((blockchain) => blockchain.chainId)\n    .filter((chainId): chainId is string => !!chainId);\n\nconst getCosmosMiscChainsIds = (blockchains: CosmosBlockchainMeta[]) =>\n  blockchains\n    .filter((blockchain) => blockchain.info?.experimental)\n    .map((blockchain) => blockchain.chainId)\n    .filter((chainId): chainId is string => !!chainId);\n\nexport const getCosmosExperimentalChainInfo = (\n  blockchains: CosmosBlockchainMeta[]\n) =>\n  blockchains\n    .filter((blockchain) => !!blockchain.info)\n    .filter(\n      (blockchain): blockchain is CosmosBlockchainMetaWithChainId =>\n        !!blockchain.chainId\n    )\n    .reduce(\n      (\n        cosmosExperimentalChainsInfo: CosmosExperimentalChainsInfo,\n        blockchain\n      ) => {\n        const info = deepCopy(blockchain.info) as CosmosChainInfo;\n        info.stakeCurrency.coinImageUrl =\n          window.location.origin + info.stakeCurrency.coinImageUrl;\n        info.currencies = info.currencies.map((currency) => ({\n          ...currency,\n          coinImageUrl: window.location.origin + currency.coinImageUrl,\n        }));\n        info.feeCurrencies = info.feeCurrencies.map((currency) => ({\n          ...currency,\n          coinImageUrl: window.location.origin + currency.coinImageUrl,\n        }));\n        if (!info.gasPriceStep) delete info.gasPriceStep;\n        const { experimental, ...otherProperties } = info;\n        return (\n          (cosmosExperimentalChainsInfo[blockchain.name] = {\n            id: blockchain.chainId,\n            info: { ...otherProperties, chainId: blockchain.chainId },\n            experimental: experimental,\n          }),\n          cosmosExperimentalChainsInfo\n        );\n      },\n      {}\n    );\n\nasync function getMainAccounts({\n  desiredChainIds,\n  instance,\n}: {\n  desiredChainIds: string[];\n  instance: any;\n}): Promise<ProviderConnectResult[]> {\n  // Trying to get accounts from all chains\n  const offlineSigners = desiredChainIds\n    .map((chainId) => {\n      const signer = instance.getOfflineSigner(chainId);\n      return {\n        signer,\n        chainId,\n      };\n    })\n    .filter(Boolean);\n  const accountsPromises = offlineSigners.map(({ signer }) =>\n    signer.getAccounts()\n  );\n  const availableAccountForChains = await Promise.allSettled(accountsPromises);\n  const resolvedAccounts: ProviderConnectResult[] = [];\n  availableAccountForChains.forEach((result, index) => {\n    if (result.status !== 'fulfilled') return;\n\n    const accounts = result.value;\n    const { chainId } = offlineSigners[index];\n    const addresses = accounts.map(\n      (account: { address: any }) => account.address\n    );\n\n    resolvedAccounts.push({ accounts: addresses, chainId });\n  });\n  return resolvedAccounts;\n}\n\nasync function tryRequestMiscAccounts({\n  excludedChain,\n  instance,\n  meta,\n}: {\n  excludedChain?: string;\n  instance: InstanceType;\n  meta: BlockchainMeta[];\n}): Promise<ProviderConnectResult[]> {\n  const offlineSigners = getCosmosMiscChainsIds(meta as CosmosBlockchainMeta[])\n    .filter((id) => id !== excludedChain)\n    .map((chainId) => {\n      const signer = instance.getOfflineSigner(chainId);\n      return {\n        signer,\n        chainId,\n      };\n    });\n  const accountsPromises = offlineSigners.map(({ signer }) =>\n    signer.getAccounts()\n  );\n  const availableAccountForChains = await Promise.allSettled(accountsPromises);\n\n  const resolvedAccounts: ProviderConnectResult[] = [];\n  availableAccountForChains.forEach((result, index) => {\n    if (result.status !== 'fulfilled') return;\n\n    const accounts = result.value;\n    const { chainId } = offlineSigners[index];\n    const addresses = accounts.map((account) => account.address);\n\n    resolvedAccounts.push({ accounts: addresses, chainId });\n  });\n\n  return resolvedAccounts;\n}\n\nexport const getCosmosAccounts: Connect = async ({\n  instance,\n  network,\n  meta,\n}) => {\n  const chainInfo = network\n    ? getCosmosExperimentalChainInfo(meta as CosmosBlockchainMeta[])[network]\n    : null;\n\n  if (!!network && !chainInfo) {\n    throw new Error(\n      `You need to add ${network} to \"COSMOS_EXPERIMENTAL_CHAINS_INFO\" first.`\n    );\n  }\n\n  // Asking for connect to wallet.\n  if (!!chainInfo) {\n    await instance.experimentalSuggestChain(chainInfo.info);\n  }\n\n  // Getting main chains + target network\n  let desiredChainIds: string[] = getCosmosMainChainsIds(\n    meta as CosmosBlockchainMeta[]\n  );\n  if (!!chainInfo) {\n    desiredChainIds.push(chainInfo!.id);\n  }\n  desiredChainIds = Array.from(new Set(desiredChainIds)).filter(Boolean);\n\n  await instance.enable(desiredChainIds);\n\n  const mainAccounts = await getMainAccounts({\n    desiredChainIds,\n    instance,\n  });\n\n  const exclude = !!chainInfo ? chainInfo.id : undefined;\n  const miscAccounts = exclude\n    ? await tryRequestMiscAccounts({\n        instance,\n        meta,\n        excludedChain: exclude,\n      })\n    : [];\n\n  const results = [...mainAccounts, ...miscAccounts];\n  return results;\n};\n"],
  "mappings": "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",
  "names": ["IS_DEV", "getBlockChainNameFromId", "__name", "chainId", "blockchains", "Networks", "blockchainMeta", "getBlockchainChainIdByName", "netwok", "allBlockChains", "uint8ArrayToHex", "buffer", "WalletTypes", "XDEFI_WALLET_SUPPORTED_NATIVE_CHAINS", "KEPLR_COMPATIBLE_WALLETS", "isAddress", "deepCopy", "obj", "copy", "i", "len", "attr", "__name", "switchOrAddNetworkForMetamaskCompatibleWallets", "instance", "network", "evmNetworksChainInfo", "targetChain", "switchError", "error", "timeout", "forPromise", "time", "timeoutPromise", "_", "reject", "convertEvmBlockchainMetaToEvmChainInfo", "evmBlockchains", "evmNetWorksChainInfo", "blockchainMeta", "evmChainsToRpcMap", "evmNetworkChainInfo", "chainName", "info", "getSolanaAccounts", "getCoinbaseInstance", "lookingFor", "ethereum", "coinbaseSolana", "instances", "checker", "ethInstance", "provider", "sortWalletsBasedOnState", "wallets", "a", "b", "isBrave", "nav", "res", "detectInstallLink", "install", "link", "detectMobileScreens", "isEvmBlockchain", "getEvmAccounts", "instance", "accounts", "chainId", "__name", "subscribeToEvm", "state", "updateChainId", "updateAccounts", "addresses", "canEagerlyConnectToEvm", "switchNetworkForEvm", "network", "meta", "evmBlockchains", "isEvmBlockchain", "evmInstance", "getNetworkInstance", "switchOrAddNetworkForMetamaskCompatibleWallets", "convertEvmBlockchainMetaToEvmChainInfo", "canSwitchNetworkToEvm", "evmNetworkNames", "blockchain", "getEthChainsInstance", "isEvmNetwork", "chooseInstance", "instances", "instance_network_name", "provider", "getCosmosMainChainsIds", "__name", "blockchains", "blockchain", "chainId", "getCosmosMiscChainsIds", "getCosmosExperimentalChainInfo", "cosmosExperimentalChainsInfo", "info", "deepCopy", "currency", "experimental", "otherProperties", "getMainAccounts", "desiredChainIds", "instance", "offlineSigners", "accountsPromises", "signer", "availableAccountForChains", "resolvedAccounts", "result", "index", "accounts", "addresses", "account", "tryRequestMiscAccounts", "excludedChain", "meta", "id", "getCosmosAccounts", "network", "chainInfo", "mainAccounts", "exclude", "miscAccounts"]
}
