var _=Object.defineProperty;var i=(r,e)=>_(r,"name",{value:e,configurable:!0});import{BroadcastMode as v,makeSignDoc as b}from"@cosmjs/launchpad";import{SigningStargateClient as I}from"@cosmjs/stargate";import{cosmos as c}from"@keplr-wallet/cosmos";import{MsgExecuteContract as O}from"cosmjs-types/cosmwasm/wasm/v1/tx.js";import S from"long";import{SignerError as n,SignerErrorCode as h}from"rango-types";var M={gasLimits:{transfer:25e4}},N=i(r=>Buffer.from(r).toString("hex"),"uint8ArrayToHex"),A=i(async(r,e)=>{if(!e)throw n.AssertionFailed("wallet is null!");try{let{memo:t,sequence:s,account_number:d,chainId:a,msgs:C,fee:o,signType:p,rpcUrl:E}=r.data,T=C.map(m=>({...m,__type:void 0,"@type":void 0}));if(!a)throw n.AssertionFailed("chainId is undefined from server");if(!d)throw n.AssertionFailed("account_number is undefined from server");if(!s)throw n.AssertionFailed("sequence is undefined from server");if(p==="AMINO"){let m=b(T,o,a,t||void 0,d,s),g={};r.data.chainId==="osmosis-1"&&o?.amount[0]?.amount==="0"&&(g={preferNoSetFee:!0});let f;try{f=await e.signAmino(a,r.fromWalletAddress,m,g)}catch(w){throw new n(h.SIGN_TX_ERROR,void 0,w)}let l=x(r,f),y=await e.sendTx(a,l,v.Async);return N(y)}else if(p==="DIRECT"){let m=e?.getOfflineSigner(a),g=await I?.connectWithSigner(E,m,{});g.registry.register("/cosmwasm.wasm.v1.MsgExecuteContract",O);let f=o?.amount[0]?[{denom:o.amount[0].denom,amount:o?.amount[0].amount}]:[],l=M.gasLimits.transfer.toString(),y=typeof o?.gas=="string"?S.fromString(o?.gas).toString():l;return(await g.signAndBroadcast(r.fromWalletAddress,T,{gas:y,amount:f})).transactionHash}throw new n(h.OPERATION_UNSUPPORTED,`Sign type for cosmos not supported, type: ${p}`)}catch(t){throw console.log({err:t}),n.isSignerError(t)?t:new n(h.SEND_TX_ERROR,void 0,t)}},"executeCosmosTransaction");function x(r,e){let t;if(r.data.protoMsgs.length>0)t=c.tx.v1beta1.TxRaw.encode({bodyBytes:c.tx.v1beta1.TxBody.encode({messages:r.data.protoMsgs.map(s=>({type_url:s.type_url,value:new Uint8Array(s.value)})),memo:e.signed.memo}).finish(),authInfoBytes:c.tx.v1beta1.AuthInfo.encode({signerInfos:[{publicKey:{type_url:"/cosmos.crypto.secp256k1.PubKey",value:c.crypto.secp256k1.PubKey.encode({key:Buffer.from(e.signature.pub_key.value,"base64")}).finish()},modeInfo:{single:{mode:c.tx.signing.v1beta1.SignMode.SIGN_MODE_LEGACY_AMINO_JSON}},sequence:S.fromString(e.signed.sequence)}],fee:{amount:e.signed.fee.amount,gasLimit:S.fromString(e.signed.fee.gas)}}).finish(),signatures:[Buffer.from(e.signature.signature,"base64")]}).finish();else throw n.AssertionFailed("protoMsgs is required in Amino messages");return t}i(x,"getsignedTx");var u=class{constructor(e){this.provider=e}async signMessage(e,t,s){if(!s)throw Error("ChainId is required");let{signature:d}=await this.provider.signArbitrary(s,t,e);return d}async signAndSendTx(e){return{hash:await A(e,this.provider)}}};i(u,"DefaultCosmosSigner");export{u as DefaultCosmosSigner,A as executeCosmosTransaction,x as getsignedTx};
//# sourceMappingURL=index.js.map
