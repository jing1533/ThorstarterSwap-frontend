{
  "version": 3,
  "sources": ["../src/helpers.ts", "../src/constants.ts", "../src/provider.tsx", "../src/hooks.ts", "../src/context.ts", "../src/index.ts"],
  "sourcesContent": ["import { WalletConfig, WalletType } from '@rango-dev/wallets-shared';\nimport Wallet, { Persistor } from '@rango-dev/wallets-core';\nimport type {\n  Options,\n  State as WalletState,\n  EventHandler as WalletEventHandler,\n} from '@rango-dev/wallets-core';\nimport {\n  State,\n  WalletActions,\n  ProviderInterface,\n  WalletProviders,\n} from './types';\nimport { LAST_CONNECTED_WALLETS } from './constants';\n\nexport function choose(wallets: any[], type: WalletType): any | null {\n  return wallets.find((wallet) => wallet.type === type) || null;\n}\n\nexport const defaultWalletState: WalletState = {\n  connected: false,\n  connecting: false,\n  reachable: false,\n  installed: false,\n  accounts: null,\n  network: null,\n};\n\nexport function state_reducer(state: State, action: any) {\n  if (action.type === 'new_state') {\n    // TODO fix problem and remove ts-ignore\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    const target_wallet = state[action.wallet];\n    if (!target_wallet) {\n      return {\n        ...state,\n        [action.wallet]: {\n          ...defaultWalletState,\n          [action.name]: action.value,\n        },\n      };\n    }\n\n    return {\n      ...state,\n      [action.wallet]: {\n        ...target_wallet,\n        [action.name]: action.value,\n      },\n    };\n  }\n\n  return state;\n}\n\nexport function connectedWallets(providersState: State): WalletType[] {\n  return Object.entries(providersState)\n    .filter(([, wallet_state]) => {\n      return wallet_state?.connected;\n    })\n    .map(([type]) => {\n      return type;\n    });\n}\n\nexport function availableWallets(providersState: State): WalletType[] {\n  return Object.entries(providersState).map(([type]) => {\n    return type;\n  });\n}\n\nexport function checkWalletProviders(\n  list: ProviderInterface[]\n): WalletProviders {\n  const wallets: WalletProviders = new Map();\n\n  list.forEach((provider) => {\n    const { config, ...actions } = provider;\n    wallets.set(config.type, {\n      actions,\n      config,\n    });\n  });\n\n  return wallets;\n}\n\n/* eslint-disable @typescript-eslint/ban-types */\nexport function isAsync(fn: Function) {\n  return fn?.constructor?.name === 'AsyncFunction';\n}\n\nexport function needsCheckInstallation(options: Options) {\n  const { checkInstallation = true } = options.config;\n  return checkInstallation;\n}\n\nexport async function tryPersistWallet({\n  type,\n  walletActions,\n  getState,\n}: {\n  type: WalletType;\n  walletActions: WalletActions;\n  getState: (walletType: WalletType) => WalletState;\n}) {\n  if (walletActions.canEagerConnect) {\n    const persistor = new Persistor<string[]>();\n    const wallets = persistor.getItem(LAST_CONNECTED_WALLETS);\n\n    /*\n      If on the last attempt we are unable to eagerly connect to any wallet and the user connects any wallet manualy,\n      persistance will be outdated and will need to be removed.\n    */\n    const shouldClearPersistance = wallets?.find(\n      (walletType) => !getState(walletType).connected\n    );\n\n    if (shouldClearPersistance) clearPersistance();\n\n    const walletAlreadyPersisted = !!wallets?.find((wallet) => wallet === type);\n    if (wallets && !walletAlreadyPersisted)\n      persistor.setItem(LAST_CONNECTED_WALLETS, wallets.concat(type));\n    else persistor.setItem(LAST_CONNECTED_WALLETS, [type]);\n  }\n}\n\nexport function tryRemoveWalletFromPersistance({\n  type,\n  walletActions,\n}: {\n  type: WalletType;\n  walletActions: WalletActions;\n}) {\n  if (walletActions.canEagerConnect) {\n    const persistor = new Persistor<string[]>();\n    const wallets = persistor.getItem(LAST_CONNECTED_WALLETS);\n    if (wallets)\n      persistor.setItem(\n        LAST_CONNECTED_WALLETS,\n        wallets.filter((wallet) => wallet !== type)\n      );\n  }\n}\n\nexport function clearPersistance() {\n  const persistor = new Persistor<string[]>();\n  const wallets = persistor.getItem(LAST_CONNECTED_WALLETS);\n  if (wallets) persistor.removeItem(LAST_CONNECTED_WALLETS);\n}\n\n/*\n  If a wallet has multiple providers and one of them can be eagerly connected,\n  then the whole wallet will support it at that point and we try to connect to that wallet as usual in eagerConnect method.\n*/\nexport async function autoConnect(\n  wallets: WalletProviders,\n  getWalletInstance: (wallet: {\n    actions: WalletActions;\n    config: WalletConfig;\n  }) => Wallet<any>\n) {\n  const persistor = new Persistor<string[]>();\n  const lastConnectedWallets = persistor.getItem(LAST_CONNECTED_WALLETS);\n  if (lastConnectedWallets && lastConnectedWallets.length) {\n    const connect_promises: {\n      walletType: WalletType;\n      eagerConnect: () => Promise<any>;\n    }[] = [];\n    lastConnectedWallets.forEach((walletType) => {\n      const wallet = wallets.get(walletType);\n\n      if (!!wallet) {\n        const walletInstance = getWalletInstance(wallet);\n        connect_promises.push({\n          walletType,\n          eagerConnect: walletInstance.eagerConnect.bind(walletInstance),\n        });\n      }\n    });\n\n    const result = await Promise.allSettled(\n      connect_promises.map(({ eagerConnect }) => eagerConnect())\n    );\n\n    const canRestoreAnyConnection = !!result.find(\n      ({ status }) => status === 'fulfilled'\n    );\n\n    /*\n      After successfully connecting to at least one wallet,\n      we will removing the other wallets from persistence.\n      If we are unable to connect to any wallet,\n      the persistence will not be removed and the eager connection will be retried with another page load.\n     */\n    if (canRestoreAnyConnection) {\n      const walletsToRemoveFromPersistance: WalletType[] = [];\n      result.forEach(({ status }, index) => {\n        if (status === 'rejected')\n          walletsToRemoveFromPersistance.push(\n            connect_promises[index].walletType\n          );\n      });\n\n      if (walletsToRemoveFromPersistance.length)\n        persistor.setItem(\n          LAST_CONNECTED_WALLETS,\n          lastConnectedWallets.filter(\n            (walletType) => !walletsToRemoveFromPersistance.includes(walletType)\n          )\n        );\n    }\n  }\n}\n/*\n  Our event handler includes an internal state updater, and a notifier\n  for the outside listener.\n  On creating first wallet refrence, and on chaning `props.onUpdateState`\n  we are using this function.\n*/\nexport function makeEventHandler(\n  dispatcher: any,\n  onUpdateState?: WalletEventHandler\n) {\n  const handler: WalletEventHandler = (\n    type,\n    name,\n    value,\n    coreState,\n    supportedChains\n  ) => {\n    const action = { type: 'new_state', wallet: type, name, value };\n    // Update state\n    dispatcher(action);\n\n    // Giving the event to the outside listener\n    if (onUpdateState) {\n      onUpdateState(type, name, value, coreState, supportedChains);\n    }\n  };\n\n  return handler;\n}\n", "export const LAST_CONNECTED_WALLETS = 'last-connected-wallets';\n", "import React, { useEffect, useReducer, useRef } from 'react';\nimport { WalletType } from '@rango-dev/wallets-shared';\n\nimport {\n  autoConnect,\n  availableWallets,\n  checkWalletProviders,\n  clearPersistance,\n  connectedWallets,\n  defaultWalletState,\n  tryPersistWallet,\n  tryRemoveWalletFromPersistance,\n  makeEventHandler,\n  state_reducer,\n} from './helpers';\nimport { ProviderProps, ProviderContext } from './types';\nimport { useInitializers } from './hooks';\nimport { WalletContext } from './context';\n\nfunction Provider(props: ProviderProps) {\n  const [providersState, dispatch] = useReducer(state_reducer, {});\n  const autoConnectInitiated = useRef(false);\n\n  // Get (or add) wallet instance (`provider`s will be wraped in a `Wallet`)\n  const getWalletInstance = useInitializers(\n    makeEventHandler(dispatch, props.onUpdateState)\n  );\n\n  // Getting providers from props and put all of them in a `Map` with an appropriate interface.\n  const listOfProviders = props.providers;\n  const wallets = checkWalletProviders(listOfProviders);\n\n  // Final API we put in context and it will be available to use for users.\n  const api: ProviderContext = {\n    async connect(type, network) {\n      const wallet = wallets.get(type);\n      if (!wallet) {\n        throw new Error(`You should add ${type} to provider first.`);\n      }\n      const walletInstance = getWalletInstance(wallet);\n      const result = await walletInstance.connect(network);\n      if (props.autoConnect)\n        tryPersistWallet({\n          type,\n          walletActions: wallet.actions,\n          getState: api.state,\n        });\n\n      return result;\n    },\n    async disconnect(type) {\n      const wallet = wallets.get(type);\n      if (!wallet) {\n        throw new Error(`You should add ${type} to provider first.`);\n      }\n\n      const walletInstance = getWalletInstance(wallet);\n      await walletInstance.disconnect();\n      if (props.autoConnect)\n        tryRemoveWalletFromPersistance({ type, walletActions: wallet.actions });\n    },\n    async disconnectAll() {\n      const disconnect_promises: Promise<any>[] = [];\n\n      // When a wallet is initializing, a record will be added to `providersState`\n      // So we use them to know what wallet has been initialized then we need to\n      // filter connected wallets only.\n      connectedWallets(providersState).forEach((type) => {\n        const wallet = wallets.get(type);\n\n        if (wallet) {\n          const walletInstance = getWalletInstance(wallet);\n          disconnect_promises.push(walletInstance.disconnect());\n        }\n      });\n\n      if (props.autoConnect) clearPersistance();\n      return await Promise.allSettled(disconnect_promises);\n    },\n    state(type) {\n      return providersState[type] || defaultWalletState;\n    },\n    canSwitchNetworkTo(type, network) {\n      const wallet = wallets.get(type);\n      if (!wallet) {\n        return false;\n      }\n\n      const walletInstance = getWalletInstance(wallet);\n      return walletInstance.canSwitchNetworkTo\n        ? walletInstance.canSwitchNetworkTo(network, walletInstance.provider)\n        : false;\n    },\n    providers() {\n      const providers: { [type in WalletType]?: any } = {};\n      availableWallets(providersState).forEach((type) => {\n        const wallet = wallets.get(type);\n        if (wallet) {\n          const walletInstance = getWalletInstance(wallet);\n          providers[type] = walletInstance.provider;\n        }\n      });\n\n      return providers;\n    },\n    getWalletInfo(type) {\n      const wallet = wallets.get(type);\n      if (!wallet) {\n        throw new Error(`You should add ${type} to provider first.`);\n      }\n\n      // Get wallet info could be used in render methods to show wallets data\n      // So, addWalletRef method shouldn't be called in this method\n\n      return wallet.actions.getWalletInfo(props.allBlockChains || []);\n    },\n    getSigners(type) {\n      const wallet = wallets.get(type);\n\n      if (!wallet) {\n        throw new Error(`You should add ${type} to provider first.`);\n      }\n      const walletInstance = getWalletInstance(wallet);\n      const provider = walletInstance.provider;\n      const result = walletInstance.getSigners(provider);\n\n      return result;\n    },\n  };\n\n  useEffect(() => {\n    wallets.forEach((wallet) => {\n      const walletInstance = getWalletInstance(wallet);\n      const runOnInit = () => {\n        if (walletInstance.onInit) {\n          walletInstance.onInit();\n        }\n      };\n\n      const initWhenPageIsReady = (event: Event) => {\n        if (\n          event.target &&\n          (event.target as Document).readyState === 'complete'\n        ) {\n          runOnInit();\n\n          document.removeEventListener('readystatechange', initWhenPageIsReady);\n        }\n      };\n\n      // Try to run, maybe it's ready.\n      runOnInit();\n\n      // Try again when the page has been completely loaded.\n      // Some of wallets, take some time to be fully injected and loaded.\n      document.addEventListener('readystatechange', initWhenPageIsReady);\n    });\n  }, []);\n\n  useEffect(() => {\n    const allBlockChains = props.allBlockChains;\n    if (allBlockChains) {\n      wallets.forEach((wallet) => {\n        const walletInstance = getWalletInstance(wallet);\n        const supportedChains = walletInstance.getWalletInfo(\n          props.allBlockChains || []\n        ).supportedChains;\n        walletInstance.setMeta(supportedChains);\n      });\n    }\n  }, [props.allBlockChains]);\n\n  useEffect(() => {\n    wallets.forEach((wallet) => {\n      const walletInstance = getWalletInstance(wallet);\n      walletInstance.setHandler(\n        makeEventHandler(dispatch, props.onUpdateState)\n      );\n    });\n  }, [props.onUpdateState]);\n\n  useEffect(() => {\n    const shouldTryAutoConnect =\n      props.allBlockChains &&\n      props.allBlockChains.length &&\n      props.autoConnect &&\n      !autoConnectInitiated.current;\n\n    if (shouldTryAutoConnect) {\n      autoConnectInitiated.current = true;\n      (async () => {\n        await autoConnect(wallets, getWalletInstance);\n      })();\n    }\n  }, [props.autoConnect, props.allBlockChains]);\n\n  return (\n    <WalletContext.Provider value={api}>\n      {props.children}\n    </WalletContext.Provider>\n  );\n}\n\nexport default Provider;\n", "import { useContext, useRef } from 'react';\nimport { WalletContext } from './context';\nimport { ProviderContext, WalletActions, WalletConfig } from './types';\nimport Wallet, {\n  EventHandler as WalletEventHandler,\n} from '@rango-dev/wallets-core';\n\n/**\n *\n *\n */\nexport function useInitializers(onChangeState: WalletEventHandler) {\n  const availableWallets = useRef<{\n    [key: string]: Wallet | undefined;\n  }>({});\n\n  // If `wallet` hasn't been added to `availableWallets`,\n  // Get a instance of `Wallet` and save the refrence in `availableWallets`.\n  // Otherwise, return the already created instance.\n  function updater(wallet: {\n    actions: WalletActions;\n    config: WalletConfig;\n  }): Wallet {\n    const type = wallet.config.type;\n    // We only update, if there is no instance available.\n    if (typeof availableWallets.current[type] === 'undefined') {\n      availableWallets.current[type] = new Wallet(\n        {\n          config: wallet.config,\n          handler: onChangeState,\n        },\n        wallet.actions\n      );\n    }\n\n    return availableWallets.current[type]!;\n  }\n\n  return updater;\n}\n\nexport function useWallets(): ProviderContext {\n  const context = useContext(WalletContext);\n  if (!context)\n    throw Error('useWallet can only be used within the Provider component');\n  return context;\n}\n", "import { createContext } from 'react';\nimport { ProviderContext } from './types';\n\nconst defaultErrorMesssage = \"Context hasn't been initialized yet.\";\nconst defaultContext: ProviderContext = {\n  async connect() {\n    throw new Error(defaultErrorMesssage);\n  },\n  async disconnect() {\n    throw new Error(defaultErrorMesssage);\n  },\n  async disconnectAll() {\n    throw new Error(defaultErrorMesssage);\n  },\n  state() {\n    throw new Error(defaultErrorMesssage);\n  },\n  canSwitchNetworkTo() {\n    throw new Error(defaultErrorMesssage);\n  },\n  providers() {\n    throw new Error(defaultErrorMesssage);\n  },\n  getWalletInfo() {\n    throw new Error(defaultErrorMesssage);\n  },\n  getSigners() {\n    throw new Error(defaultErrorMesssage);\n  },\n};\n\nexport const WalletContext = createContext<ProviderContext>(defaultContext);\n", "export * from './helpers';\nexport { default as Provider } from './provider';\nexport { useWallets } from './hooks';\nexport * from './types';\n\nexport type { EventHandler } from '@rango-dev/wallets-core';\nexport { Events, readAccountAddress } from '@rango-dev/wallets-core';\n"],
  "mappings": "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",
  "names": ["Persistor", "LAST_CONNECTED_WALLETS", "choose", "wallets", "type", "wallet", "__name", "defaultWalletState", "state_reducer", "state", "action", "target_wallet", "connectedWallets", "providersState", "wallet_state", "availableWallets", "checkWalletProviders", "list", "provider", "config", "actions", "isAsync", "fn", "needsCheckInstallation", "options", "checkInstallation", "tryPersistWallet", "walletActions", "getState", "persistor", "Persistor", "LAST_CONNECTED_WALLETS", "walletType", "clearPersistance", "walletAlreadyPersisted", "tryRemoveWalletFromPersistance", "autoConnect", "getWalletInstance", "lastConnectedWallets", "connect_promises", "walletInstance", "result", "eagerConnect", "status", "walletsToRemoveFromPersistance", "index", "makeEventHandler", "dispatcher", "onUpdateState", "name", "value", "coreState", "supportedChains", "React", "useEffect", "useReducer", "useRef", "useContext", "useRef", "createContext", "defaultErrorMesssage", "defaultContext", "WalletContext", "Wallet", "useInitializers", "onChangeState", "availableWallets", "useRef", "updater", "wallet", "type", "Wallet", "__name", "useWallets", "context", "useContext", "WalletContext", "Provider", "props", "providersState", "dispatch", "useReducer", "state_reducer", "autoConnectInitiated", "useRef", "getWalletInstance", "useInitializers", "makeEventHandler", "listOfProviders", "wallets", "checkWalletProviders", "api", "type", "network", "wallet", "result", "tryPersistWallet", "tryRemoveWalletFromPersistance", "disconnect_promises", "connectedWallets", "walletInstance", "clearPersistance", "defaultWalletState", "providers", "availableWallets", "provider", "useEffect", "runOnInit", "__name", "initWhenPageIsReady", "event", "supportedChains", "autoConnect", "React", "WalletContext", "provider_default", "Events", "readAccountAddress"]
}
