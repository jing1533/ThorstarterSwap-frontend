{
  "version": 3,
  "sources": ["../src/signer.ts", "../src/helper.ts", "../src/types.ts"],
  "sourcesContent": ["import {\n  TransactionRequest,\n  TransactionResponse,\n} from '@ethersproject/abstract-provider';\nimport type { GenericSigner } from 'rango-types';\nimport { EvmTransaction } from 'rango-types/lib/api/main';\nimport { providers } from 'ethers';\nimport { cleanEvmError, getTenderlyError, waitMs } from './helper';\nimport {\n  RPCErrorCode as RangoRPCErrorCode,\n  SignerError,\n  SignerErrorCode,\n} from 'rango-types';\nimport { RPCErrorCode } from './types';\n\ntype ProviderType = ConstructorParameters<typeof providers.Web3Provider>[0];\n\nconst waitWithMempoolCheck = async (\n  provider: providers.Web3Provider,\n  tx: TransactionResponse,\n  txHash: string,\n  confirmations?: number\n) => {\n  let finished = false;\n  return await Promise.race([\n    (async () => {\n      await tx.wait(confirmations);\n      finished = true;\n    })(),\n    (async () => {\n      while (!finished) {\n        await waitMs(3_000);\n        if (finished) return null;\n        try {\n          const mempoolTx = await provider.getTransaction(txHash);\n          if (!mempoolTx) return null;\n        } catch (error) {\n          console.log({ error });\n          return null;\n        }\n      }\n      return null;\n    })(),\n  ]);\n};\n\nexport class DefaultEvmSigner implements GenericSigner<EvmTransaction> {\n  private signer: providers.JsonRpcSigner;\n  private provider: providers.Web3Provider;\n\n  constructor(provider: ProviderType) {\n    this.provider = new providers.Web3Provider(provider);\n    this.signer = this.provider.getSigner();\n  }\n\n  async signMessage(msg: string): Promise<string> {\n    try {\n      return await this.signer.signMessage(msg);\n    } catch (error) {\n      throw new SignerError(SignerErrorCode.SIGN_TX_ERROR, undefined, error);\n    }\n  }\n\n  async signAndSendTx(\n    tx: EvmTransaction,\n    address: string,\n    chainId: string | null\n  ): Promise<{ hash: string; response: TransactionResponse }> {\n    try {\n      this.signer = this.provider.getSigner(tx.from ?? undefined);\n\n      const transaction = DefaultEvmSigner.buildTx(tx);\n\n      const signerChainId = await this.signer.getChainId();\n      const signerAddress = await this.signer.getAddress();\n      if (!!chainId && !!signerChainId && signerChainId !== parseInt(chainId)) {\n        throw new SignerError(\n          SignerErrorCode.UNEXPECTED_BEHAVIOUR,\n          undefined,\n          `Signer chainId: '${signerChainId}' doesn't match with required chainId: '${chainId}' for tx.`\n        );\n      }\n      if (\n        !!signerAddress &&\n        !!address &&\n        signerAddress.toLowerCase() !== address.toLowerCase()\n      ) {\n        throw new SignerError(\n          SignerErrorCode.UNEXPECTED_BEHAVIOUR,\n          undefined,\n          `Signer address: '${signerAddress.toLowerCase()}' doesn't match with required address: '${address.toLowerCase()}' for tx.`\n        );\n      }\n      try {\n        const response = await this.signer.sendTransaction(transaction);\n        return { hash: response.hash, response };\n      } catch (error: any) {\n        // retrying EIP-1559 without v2 related fields\n        if (\n          !!error?.message &&\n          typeof error.message === 'string' &&\n          error.message.indexOf('EIP-1559') !== -1\n        ) {\n          console.log('retrying EIP-1559 error without v2 fields ...');\n          const transaction = DefaultEvmSigner.buildTx(tx, true);\n          const response = await this.signer.sendTransaction(transaction);\n          return { hash: response.hash, response };\n        } else {\n          throw error;\n        }\n      }\n    } catch (error) {\n      throw cleanEvmError(error);\n    }\n  }\n\n  async wait(\n    txHash: string,\n    chainId?: string,\n    txResponse?: TransactionResponse,\n    confirmations?: number\n  ): Promise<{ hash: string; response?: TransactionResponse }> {\n    try {\n      // if we have transaction response, use that to wait\n      // otherwise, try to get tx response from the wallet provider\n      if (txResponse) {\n        // if we use waitWithMempoolCheck here, we can't detect replaced tx anymore\n        await txResponse?.wait(confirmations);\n        return { hash: txHash };\n      }\n\n      // ignore wait if wallet not connected yet\n      if (!this.provider) return { hash: txHash };\n      this.signer = this.provider.getSigner();\n\n      // don't proceed if signer chain changed or chain id is not specified\n      // because if user change the wallet network, we receive null on getTransaction\n      if (!chainId) return { hash: txHash };\n      const signerChainId = await this.signer.getChainId();\n      if (!signerChainId || parseInt(chainId) != signerChainId)\n        return { hash: txHash };\n\n      const tx = await this.provider.getTransaction(txHash);\n      if (!tx)\n        throw Error(`Transaction hash '${txHash}' not found in blockchain.`);\n\n      await waitWithMempoolCheck(this.provider, tx, txHash, confirmations);\n      return { hash: txHash };\n    } catch (err) {\n      const error = err as any; // TODO find a proper type\n      if (\n        error?.code === RPCErrorCode.TRANSACTION_REPLACED &&\n        error?.replacement\n      )\n        return { hash: error?.replacement?.hash, response: error?.replacement };\n      else if (error?.code === RPCErrorCode.CALL_EXCEPTION) {\n        const tError = await getTenderlyError(chainId, txHash);\n        if (!!tError) {\n          throw new SignerError(\n            SignerErrorCode.TX_FAILED_IN_BLOCKCHAIN,\n            'Trannsaction failed in blockchain',\n            tError,\n            RangoRPCErrorCode.CALL_EXCEPTION,\n            error\n          );\n        } else {\n          /**\n           * In cases where the is no error returen from tenderly, we could ignore\n           * the error and proceed with check status flow.\n           * */\n          return { hash: txHash };\n        }\n      }\n      throw cleanEvmError(error);\n    }\n  }\n\n  static buildTx(evmTx: EvmTransaction, disableV2 = false): TransactionRequest {\n    let tx: TransactionRequest = {};\n    if (evmTx.from) tx = { ...tx, from: evmTx.from };\n    if (evmTx.to) tx = { ...tx, to: evmTx.to };\n    if (evmTx.data) tx = { ...tx, data: evmTx.data };\n    if (evmTx.value) tx = { ...tx, value: evmTx.value };\n    if (evmTx.nonce) tx = { ...tx, nonce: evmTx.nonce };\n    if (evmTx.gasLimit) tx = { ...tx, gasLimit: evmTx.gasLimit };\n    if (evmTx.gasPrice)\n      tx = {\n        ...tx,\n        gasPrice: '0x' + parseInt(evmTx.gasPrice).toString(16),\n      };\n    if (evmTx.maxFeePerGas && !disableV2)\n      tx = { ...tx, maxFeePerGas: evmTx.maxFeePerGas };\n    if (evmTx.maxPriorityFeePerGas && !disableV2)\n      tx = { ...tx, maxPriorityFeePerGas: evmTx.maxPriorityFeePerGas };\n    return tx;\n  }\n}\n", "import type { SignerError as SignerErrorType } from 'rango-types';\n\nimport { getMessageFromCode } from 'eth-rpc-errors';\nimport {\n  RPCErrorCode as RangoRPCErrorCode,\n  SignerError,\n  SignerErrorCode,\n} from 'rango-types';\n\nimport { MetamaskErrorCodes, RPCErrorCode, RPCErrorMessage } from './types';\n\nexport const cleanEvmError = (error: any): SignerErrorType => {\n  if (!error) {\n    return new SignerError(SignerErrorCode.SEND_TX_ERROR);\n  }\n  if (SignerError.isSignerError(error)) {\n    return error;\n  }\n  const hasMessage = Object.prototype.hasOwnProperty.call(error, 'message');\n  const hasCode = Object.prototype.hasOwnProperty.call(error, 'code');\n  if (hasMessage && hasCode) {\n    const { message: errorMessage, code: errorCode } = error;\n    // rejection error\n    if (\n      RPCErrorCode.ACTION_REJECTED === errorCode ||\n      MetamaskErrorCodes.provider.userRejectedRequest === errorCode\n    ) {\n      return new SignerError(\n        SignerErrorCode.REJECTED_BY_USER,\n        undefined,\n        error,\n        RangoRPCErrorCode.REJECTION,\n        error\n      );\n    }\n    if (typeof errorCode === 'number') {\n      // provider errors\n      if (Object.values(MetamaskErrorCodes.provider).includes(errorCode)) {\n        const msg = getMessageFromCode(errorCode);\n        return new SignerError(\n          SignerErrorCode.SEND_TX_ERROR,\n          undefined,\n          msg,\n          RangoRPCErrorCode.UNKNOWN_ERROR,\n          error\n        );\n      }\n      // rpc errors\n      else if (Object.values(MetamaskErrorCodes.rpc).includes(errorCode)) {\n        // underpriced errors are sent as internal errors\n        if (\n          errorCode === MetamaskErrorCodes.rpc.internal &&\n          (errorMessage?.includes(RPCErrorMessage.UNDER_PRICED) ||\n            errorMessage?.includes(RPCErrorMessage.REPLACEMENT_FEE_TOO_LOW))\n        ) {\n          return new SignerError(\n            SignerErrorCode.SEND_TX_ERROR,\n            undefined,\n            'Transaction is underpriced.',\n            RangoRPCErrorCode.UNDER_PRICED,\n            error\n          );\n        }\n        // gas limit errors are sent as internal errors\n        if (\n          errorMessage?.includes(RPCErrorMessage.INTRINSIC_GAS_TOO_LOW) ||\n          errorMessage?.includes(RPCErrorMessage.OUT_OF_GAS)\n        ) {\n          return new SignerError(\n            SignerErrorCode.SEND_TX_ERROR,\n            undefined,\n            'Gas limit is low.',\n            RangoRPCErrorCode.OUT_OF_GAS,\n            error\n          );\n        }\n\n        const msg = getMessageFromCode(errorCode);\n        return new SignerError(\n          SignerErrorCode.SEND_TX_ERROR,\n          undefined,\n          msg ?? error,\n          RangoRPCErrorCode.UNKNOWN_ERROR,\n          error\n        );\n      }\n    }\n    switch (errorCode) {\n      case RPCErrorCode.INVALID_ARGUMENT: {\n        const msg = (error.reason || error.message) ?? error;\n        return new SignerError(\n          SignerErrorCode.SEND_TX_ERROR,\n          undefined,\n          msg,\n          RangoRPCErrorCode.UNKNOWN_ERROR,\n          error\n        );\n      }\n    }\n  }\n  return new SignerError(\n    SignerErrorCode.SEND_TX_ERROR,\n    undefined,\n    error,\n    RangoRPCErrorCode.UNKNOWN_ERROR,\n    error\n  );\n};\n\ninterface TenderlyResponse {\n  error_message: string;\n}\n\nexport async function getTenderlyError(\n  chainId: string | undefined,\n  txHash: string\n): Promise<string | undefined> {\n  if (!chainId || !txHash) {\n    return;\n  }\n  const chainIdInt = parseInt(chainId);\n  try {\n    const url = `https://api.tenderly.co/api/v1/public-contract/${chainIdInt}/tx/${txHash}`;\n    const response = await fetch(url, {\n      method: 'GET',\n    });\n    if (!response.ok) {\n      return;\n    }\n    const data: TenderlyResponse = await response.json();\n    return data?.error_message;\n  } catch (error) {\n    return;\n  }\n}\n\nexport const waitMs = async (ms: number) =>\n  new Promise((resolve) => setTimeout(resolve, ms));\n", "export const MetamaskErrorCodes = {\n  rpc: {\n    invalidInput: -32000,\n    resourceNotFound: -32001,\n    resourceUnavailable: -32002,\n    transactionRejected: -32003,\n    methodNotSupported: -32004,\n    limitExceeded: -32005,\n    parse: -32700,\n    invalidRequest: -32600,\n    methodNotFound: -32601,\n    invalidParams: -32602,\n    internal: -32603,\n  },\n  provider: {\n    userRejectedRequest: 4001,\n    unauthorized: 4100,\n    unsupportedMethod: 4200,\n    disconnected: 4900,\n    chainDisconnected: 4901,\n  },\n};\n\nexport enum RPCErrorCode {\n  ACTION_REJECTED = 'ACTION_REJECTED',\n  INVALID_ARGUMENT = 'INVALID_ARGUMENT',\n  CALL_EXCEPTION = 'CALL_EXCEPTION',\n  INSUFFICIENT_FUNDS = 'INSUFFICIENT_FUNDS',\n  TRANSACTION_REPLACED = 'TRANSACTION_REPLACED',\n}\n\nexport enum RPCErrorMessage {\n  UNDER_PRICED = 'underpriced',\n  REPLACEMENT_FEE_TOO_LOW = 'replacement fee too low',\n  INTRINSIC_GAS_TOO_LOW = 'intrinsic gas too low',\n  OUT_OF_GAS = 'out of gas',\n  INTERNAL_ERROR = 'Internal JSON-RPC error',\n}\n"],
  "mappings": "+EAMA,OAAS,aAAAA,MAAiB,SCJ1B,OAAS,sBAAAC,MAA0B,iBACnC,OACE,gBAAgBC,EAChB,eAAAC,EACA,mBAAAC,MACK,cCPA,IAAMC,EAAqB,CAChC,IAAK,CACH,aAAc,MACd,iBAAkB,OAClB,oBAAqB,OACrB,oBAAqB,OACrB,mBAAoB,OACpB,cAAe,OACf,MAAO,OACP,eAAgB,OAChB,eAAgB,OAChB,cAAe,OACf,SAAU,MACZ,EACA,SAAU,CACR,oBAAqB,KACrB,aAAc,KACd,kBAAmB,KACnB,aAAc,KACd,kBAAmB,IACrB,CACF,EDVO,IAAMC,EAAgBC,EAACC,GAAgC,CAC5D,GAAI,CAACA,EACH,OAAO,IAAIC,EAAYC,EAAgB,aAAa,EAEtD,GAAID,EAAY,cAAcD,CAAK,EACjC,OAAOA,EAET,IAAMG,EAAa,OAAO,UAAU,eAAe,KAAKH,EAAO,SAAS,EAClEI,EAAU,OAAO,UAAU,eAAe,KAAKJ,EAAO,MAAM,EAClE,GAAIG,GAAcC,EAAS,CACzB,GAAM,CAAE,QAASC,EAAc,KAAMC,CAAU,EAAIN,EAEnD,uBACmCM,GACjCC,EAAmB,SAAS,sBAAwBD,EAEpD,OAAO,IAAIL,EACTC,EAAgB,iBAChB,OACAF,EACAQ,EAAkB,UAClBR,CACF,EAEF,GAAI,OAAOM,GAAc,UAEvB,GAAI,OAAO,OAAOC,EAAmB,QAAQ,EAAE,SAASD,CAAS,EAAG,CAClE,IAAMG,EAAMC,EAAmBJ,CAAS,EACxC,OAAO,IAAIL,EACTC,EAAgB,cAChB,OACAO,EACAD,EAAkB,cAClBR,CACF,UAGO,OAAO,OAAOO,EAAmB,GAAG,EAAE,SAASD,CAAS,EAAG,CAElE,GACEA,IAAcC,EAAmB,IAAI,WACpCF,GAAc,sBAAqC,GAClDA,GAAc,kCAAgD,GAEhE,OAAO,IAAIJ,EACTC,EAAgB,cAChB,OACA,8BACAM,EAAkB,aAClBR,CACF,EAGF,GACEK,GAAc,gCAA8C,GAC5DA,GAAc,qBAAmC,EAEjD,OAAO,IAAIJ,EACTC,EAAgB,cAChB,OACA,oBACAM,EAAkB,WAClBR,CACF,EAGF,IAAMS,EAAMC,EAAmBJ,CAAS,EACxC,OAAO,IAAIL,EACTC,EAAgB,cAChB,OACAO,GAAOT,EACPQ,EAAkB,cAClBR,CACF,GAGJ,OAAQM,EAAW,CACjB,uBAAoC,CAClC,IAAMG,GAAOT,EAAM,QAAUA,EAAM,UAAYA,EAC/C,OAAO,IAAIC,EACTC,EAAgB,cAChB,OACAO,EACAD,EAAkB,cAClBR,CACF,CACF,CACF,EAEF,OAAO,IAAIC,EACTC,EAAgB,cAChB,OACAF,EACAQ,EAAkB,cAClBR,CACF,CACF,EAhG6B,iBAsG7B,eAAsBW,EACpBC,EACAC,EAC6B,CAC7B,GAAI,CAACD,GAAW,CAACC,EACf,OAEF,IAAMC,EAAa,SAASF,CAAO,EACnC,GAAI,CACF,IAAMG,EAAM,kDAAkDD,QAAiBD,IACzEG,EAAW,MAAM,MAAMD,EAAK,CAChC,OAAQ,KACV,CAAC,EACD,OAAKC,EAAS,IAGiB,MAAMA,EAAS,KAAK,IACtC,cAHX,MAIJ,MAAE,CACA,MACF,CACF,CArBsBjB,EAAAY,EAAA,oBAuBf,IAAMM,EAASlB,EAAA,MAAOmB,GAC3B,IAAI,QAASC,GAAY,WAAWA,EAASD,CAAE,CAAC,EAD5B,UDhItB,OACE,gBAAgBE,EAChB,eAAAC,EACA,mBAAAC,MACK,cAKP,IAAMC,EAAuBC,EAAA,MAC3BC,EACAC,EACAC,EACAC,IACG,CACH,IAAIC,EAAW,GACf,OAAO,MAAM,QAAQ,KAAK,EACvB,SAAY,CACX,MAAMH,EAAG,KAAKE,CAAa,EAC3BC,EAAW,EACb,GAAG,GACF,SAAY,CACX,KAAO,CAACA,GAAU,CAEhB,GADA,MAAMC,EAAO,GAAK,EACdD,EAAU,OAAO,KACrB,GAAI,CAEF,GAAI,CADc,MAAMJ,EAAS,eAAeE,CAAM,EACtC,OAAO,IACzB,OAASI,EAAP,CACA,eAAQ,IAAI,CAAE,MAAAA,CAAM,CAAC,EACd,IACT,EAEF,OAAO,IACT,GAAG,CACL,CAAC,CACH,EA3B6B,wBA6BhBC,EAAN,KAAgE,CAIrE,YAAYP,EAAwB,CAClC,KAAK,SAAW,IAAIQ,EAAU,aAAaR,CAAQ,EACnD,KAAK,OAAS,KAAK,SAAS,UAAU,CACxC,CAEA,MAAM,YAAYS,EAA8B,CAC9C,GAAI,CACF,OAAO,MAAM,KAAK,OAAO,YAAYA,CAAG,CAC1C,OAASH,EAAP,CACA,MAAM,IAAII,EAAYC,EAAgB,cAAe,OAAWL,CAAK,CACvE,CACF,CAEA,MAAM,cACJL,EACAW,EACAC,EAC0D,CAC1D,GAAI,CACF,KAAK,OAAS,KAAK,SAAS,UAAUZ,EAAG,MAAQ,MAAS,EAE1D,IAAMa,EAAcP,EAAiB,QAAQN,CAAE,EAEzCc,EAAgB,MAAM,KAAK,OAAO,WAAW,EAC7CC,EAAgB,MAAM,KAAK,OAAO,WAAW,EACnD,GAAMH,GAAaE,GAAiBA,IAAkB,SAASF,CAAO,EACpE,MAAM,IAAIH,EACRC,EAAgB,qBAChB,OACA,oBAAoBI,4CAAwDF,YAC9E,EAEF,GACIG,GACAJ,GACFI,EAAc,YAAY,IAAMJ,EAAQ,YAAY,EAEpD,MAAM,IAAIF,EACRC,EAAgB,qBAChB,OACA,oBAAoBK,EAAc,YAAY,4CAA4CJ,EAAQ,YAAY,YAChH,EAEF,GAAI,CACF,IAAMK,EAAW,MAAM,KAAK,OAAO,gBAAgBH,CAAW,EAC9D,MAAO,CAAE,KAAMG,EAAS,KAAM,SAAAA,CAAS,CACzC,OAASX,EAAP,CAEA,GACIA,GAAO,SACT,OAAOA,EAAM,SAAY,UACzBA,EAAM,QAAQ,QAAQ,UAAU,IAAM,GACtC,CACA,QAAQ,IAAI,+CAA+C,EAC3D,IAAMQ,EAAcP,EAAiB,QAAQN,EAAI,EAAI,EAC/CgB,EAAW,MAAM,KAAK,OAAO,gBAAgBH,CAAW,EAC9D,MAAO,CAAE,KAAMG,EAAS,KAAM,SAAAA,CAAS,MAEvC,OAAMX,CAEV,CACF,OAASA,EAAP,CACA,MAAMY,EAAcZ,CAAK,CAC3B,CACF,CAEA,MAAM,KACJJ,EACAW,EACAM,EACAhB,EAC2D,CAC3D,GAAI,CAGF,GAAIgB,EAEF,aAAMA,GAAY,KAAKhB,CAAa,EAC7B,CAAE,KAAMD,CAAO,EAIxB,GAAI,CAAC,KAAK,SAAU,MAAO,CAAE,KAAMA,CAAO,EAK1C,GAJA,KAAK,OAAS,KAAK,SAAS,UAAU,EAIlC,CAACW,EAAS,MAAO,CAAE,KAAMX,CAAO,EACpC,IAAMa,EAAgB,MAAM,KAAK,OAAO,WAAW,EACnD,GAAI,CAACA,GAAiB,SAASF,CAAO,GAAKE,EACzC,MAAO,CAAE,KAAMb,CAAO,EAExB,IAAMD,EAAK,MAAM,KAAK,SAAS,eAAeC,CAAM,EACpD,GAAI,CAACD,EACH,MAAM,MAAM,qBAAqBC,6BAAkC,EAErE,aAAMJ,EAAqB,KAAK,SAAUG,EAAIC,EAAQC,CAAa,EAC5D,CAAE,KAAMD,CAAO,CACxB,OAASkB,EAAP,CACA,IAAMd,EAAQc,EACd,GACEd,GAAO,+BACPA,GAAO,YAEP,MAAO,CAAE,KAAMA,GAAO,aAAa,KAAM,SAAUA,GAAO,WAAY,EACnE,GAAIA,GAAO,wBAAsC,CACpD,IAAMe,EAAS,MAAMC,EAAiBT,EAASX,CAAM,EACrD,GAAMmB,EACJ,MAAM,IAAIX,EACRC,EAAgB,wBAChB,oCACAU,EACAE,EAAkB,eAClBjB,CACF,EAMA,MAAO,CAAE,KAAMJ,CAAO,EAG1B,MAAMgB,EAAcZ,CAAK,CAC3B,CACF,CAEA,OAAO,QAAQkB,EAAuBC,EAAY,GAA2B,CAC3E,IAAIxB,EAAyB,CAAC,EAC9B,OAAIuB,EAAM,OAAMvB,EAAK,CAAE,GAAGA,EAAI,KAAMuB,EAAM,IAAK,GAC3CA,EAAM,KAAIvB,EAAK,CAAE,GAAGA,EAAI,GAAIuB,EAAM,EAAG,GACrCA,EAAM,OAAMvB,EAAK,CAAE,GAAGA,EAAI,KAAMuB,EAAM,IAAK,GAC3CA,EAAM,QAAOvB,EAAK,CAAE,GAAGA,EAAI,MAAOuB,EAAM,KAAM,GAC9CA,EAAM,QAAOvB,EAAK,CAAE,GAAGA,EAAI,MAAOuB,EAAM,KAAM,GAC9CA,EAAM,WAAUvB,EAAK,CAAE,GAAGA,EAAI,SAAUuB,EAAM,QAAS,GACvDA,EAAM,WACRvB,EAAK,CACH,GAAGA,EACH,SAAU,KAAO,SAASuB,EAAM,QAAQ,EAAE,SAAS,EAAE,CACvD,GACEA,EAAM,cAAgB,CAACC,IACzBxB,EAAK,CAAE,GAAGA,EAAI,aAAcuB,EAAM,YAAa,GAC7CA,EAAM,sBAAwB,CAACC,IACjCxB,EAAK,CAAE,GAAGA,EAAI,qBAAsBuB,EAAM,oBAAqB,GAC1DvB,CACT,CACF,EAtJaF,EAAAQ,EAAA",
  "names": ["providers", "getMessageFromCode", "RangoRPCErrorCode", "SignerError", "SignerErrorCode", "MetamaskErrorCodes", "cleanEvmError", "__name", "error", "SignerError", "SignerErrorCode", "hasMessage", "hasCode", "errorMessage", "errorCode", "MetamaskErrorCodes", "RangoRPCErrorCode", "msg", "getMessageFromCode", "getTenderlyError", "chainId", "txHash", "chainIdInt", "url", "response", "waitMs", "ms", "resolve", "RangoRPCErrorCode", "SignerError", "SignerErrorCode", "waitWithMempoolCheck", "__name", "provider", "tx", "txHash", "confirmations", "finished", "waitMs", "error", "DefaultEvmSigner", "providers", "msg", "SignerError", "SignerErrorCode", "address", "chainId", "transaction", "signerChainId", "signerAddress", "response", "cleanEvmError", "txResponse", "err", "tError", "getTenderlyError", "RangoRPCErrorCode", "evmTx", "disableV2"]
}
