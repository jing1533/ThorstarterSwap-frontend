{
  "version": 3,
  "sources": ["../src/configs.ts", "../src/types.ts", "../src/helpers.ts", "../src/constants.ts", "../src/shared-errors.ts", "../src/shared.ts", "../src/numbers.ts", "../src/shared-sentry.ts", "../src/services/httpService.ts", "../src/services/eventEmitter.ts", "../src/actions/checkStatus.ts", "../src/actions/createTransaction.ts", "../src/actions/executeTransaction.ts", "../src/actions/scheduleNextStep.ts", "../src/actions/start.ts", "../src/queueDef.ts", "../src/hooks.ts", "../src/migration.ts", "../src/index.ts"],
  "sourcesContent": ["export interface Configs {\n  API_KEY: string;\n  BASE_URL?: string;\n}\n\n// this API key is limited and\n// it is only for test purpose\n\nconst RANGO_PUBLIC_API_KEY = 'c6381a79-2817-4602-83bf-6a641a409e32';\n\nlet configs: Configs = {\n  API_KEY: RANGO_PUBLIC_API_KEY,\n};\n\nexport function getConfig(name: keyof Configs) {\n  return configs[name] || '';\n}\n\nexport function setConfig(name: keyof Configs, value: any) {\n  configs[name] = value;\n\n  return value;\n}\n\nexport function initConfig(nextConfigs: Configs) {\n  let clonedConfigs;\n  if (typeof structuredClone === 'function') {\n    clonedConfigs = structuredClone(nextConfigs);\n  } else {\n    clonedConfigs = JSON.parse(JSON.stringify(nextConfigs));\n  }\n  configs = clonedConfigs;\n  return configs;\n}\n", "import { QueueStorage, QueueDef } from '@rango-dev/queue-manager-core';\nimport { QueueContext } from '@rango-dev/queue-manager-core/dist/queue';\nimport { ConnectResult, Providers } from '@rango-dev/wallets-react';\nimport {\n  Meta,\n  Network,\n  WalletState,\n  WalletType,\n} from '@rango-dev/wallets-shared';\nimport { APIErrorCode, EvmBlockchainMeta, SignerFactory } from 'rango-types';\nimport { Transaction } from 'rango-sdk';\nimport { PendingSwap, PendingSwapStep, Wallet } from './shared';\n\nexport type RemoveNameField<T, U extends string> = {\n  [Property in keyof T as Exclude<Property, U>]: T[Property];\n};\n\nexport type ArrayElement<A> = A extends readonly (infer T)[] ? T : never;\n\nexport type SwapQueueDef = QueueDef<\n  SwapStorage,\n  SwapActionTypes,\n  SwapQueueContext\n>;\n\nexport interface SwapStorage extends QueueStorage {\n  swapDetails: PendingSwap;\n}\n\nexport enum SwapActionTypes {\n  START = 'START',\n  SCHEDULE_NEXT_STEP = 'SCHEDULE_NEXT_STEP',\n  CREATE_TRANSACTION = 'CREATE_TRANSACTION',\n  EXECUTE_TRANSACTION = 'EXECUTE_TRANSACTION',\n  CHECK_TRANSACTION_STATUS = 'CHECK_TRANSACTION_STATUS',\n}\n\nexport type GetCurrentAddress = (\n  type: WalletType,\n  network: Network\n) => string | undefined;\n\nexport enum BlockReason {\n  WAIT_FOR_CONNECT_WALLET = 'waiting_for_connecting_wallet',\n  WAIT_FOR_NETWORK_CHANGE = 'waiting_for_network_change',\n  DEPENDS_ON_OTHER_QUEUES = 'depends_on_other_queues',\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport interface Block<T = any> {\n  reason: BlockReason;\n  description: string;\n  details?: T;\n}\n\nexport interface SwapQueueContext extends QueueContext {\n  meta: Meta;\n  wallets: Wallet | null;\n  providers: Providers;\n  getSigners: (type: WalletType) => SignerFactory;\n  switchNetwork: (\n    wallet: WalletType,\n    network: Network\n  ) => Promise<ConnectResult> | undefined;\n  canSwitchNetworkTo: (type: WalletType, network: Network) => boolean;\n  connect: (\n    wallet: WalletType,\n    network: Network\n  ) => Promise<ConnectResult> | undefined;\n  state: (type: WalletType) => WalletState;\n  isMobileWallet: (type: WalletType) => boolean;\n\n  // Dynamically will be added to context.\n  claimedBy?: string;\n  resetClaimedBy?: () => void;\n}\n\nexport interface UseQueueManagerParams {\n  lastConnectedWallet: string;\n  disconnectedWallet: WalletType | undefined;\n  clearDisconnectedWallet: () => void;\n  evmChains: EvmBlockchainMeta[];\n  canSwitchNetworkTo: (type: WalletType, network: Network) => boolean;\n}\n\nexport enum MainEvents {\n  RouteEvent = 'routeEvent',\n  StepEvent = 'stepEvent',\n}\n\nexport type Step = Pick<\n  PendingSwapStep,\n  | 'diagnosisUrl'\n  | 'estimatedTimeInSeconds'\n  | 'explorerUrl'\n  | 'feeInUsd'\n  | 'executedTransactionId'\n  | 'executedTransactionTime'\n  | 'expectedOutputAmountHumanReadable'\n  | 'fromBlockchain'\n  | 'toBlockchain'\n  | 'fromSymbol'\n  | 'toSymbol'\n  | 'toSymbolAddress'\n  | 'fromSymbolAddress'\n  | 'swapperType'\n  | 'outputAmount'\n  | 'fromAmountMaxValue'\n  | 'fromAmountMinValue'\n  | 'fromAmountPrecision'\n  | 'fromAmountRestrictionType'\n  | 'fromDecimals'\n  | 'status'\n> & { swapperName: string; transaction: Transaction | null };\n\nexport type Route = Pick<\n  PendingSwap,\n  | 'creationTime'\n  | 'finishTime'\n  | 'requestId'\n  | 'inputAmount'\n  | 'status'\n  | 'wallets'\n> & { steps: Step[]; slippage: string; infiniteApproval?: boolean };\n\nexport type SwapEvent = RouteEvent | StepEvent;\n\nexport enum RouteEventType {\n  STARTED = 'started',\n  FAILED = 'failed',\n  SUCCEEDED = 'succeeded',\n}\n\nexport enum StepExecutionEventStatus {\n  CREATE_TX = 'create_tx',\n  SEND_TX = 'send_tx',\n  TX_SENT = 'tx_sent',\n}\n\nexport enum StepExecutionBlockedEventStatus {\n  WAITING_FOR_QUEUE = 'waiting_for_queue',\n  WAITING_FOR_WALLET_CONNECT = 'waiting_for_wallet_connect',\n  WAITING_FOR_NETWORK_CHANGE = 'waiting_for_network_change',\n  WAITING_FOR_CHANGE_WALLET_ACCOUNT = 'waiting_for_change_wallet_account',\n}\n\nexport enum StepEventType {\n  STARTED = 'started',\n  FAILED = 'failed',\n  SUCCEEDED = 'succeeded',\n  TX_EXECUTION = 'tx_execution',\n  TX_EXECUTION_BLOCKED = 'tx_execution_blocked',\n  APPROVAL_TX_SUCCEEDED = 'approval_tx_succeeded',\n  CHECK_STATUS = 'check_status',\n  OUTPUT_REVEALED = 'output_revealed',\n}\n\nexport enum EventSeverity {\n  ERROR = 'error',\n  SUCCESS = 'success',\n  WARNING = 'warning',\n  INFO = 'info',\n}\n\nexport type Event<\n  T extends StepEventType | RouteEventType,\n  U extends Record<string, unknown> = Record<string, unknown>\n> = {\n  type: T;\n  message: string;\n  messageSeverity: EventSeverity;\n} & U;\n\nexport type FailedRouteEventPayload = {\n  reason?: string;\n  reasonCode: APIErrorCode;\n};\n\nexport type FailedStepEventPayload = FailedRouteEventPayload;\n\nexport type SucceededRouteEventPayload = {\n  outputAmount: string;\n};\n\nexport type SucceededStepEventPayload = SucceededRouteEventPayload;\n\nexport type OutputRevealedEventPayload = SucceededRouteEventPayload;\n\nexport type StepExecutionEventPayload = {\n  status:\n    | StepExecutionEventStatus.CREATE_TX\n    | StepExecutionEventStatus.SEND_TX\n    | StepExecutionEventStatus.TX_SENT;\n};\n\nexport type StepBlockedEventPayload =\n  | { status: StepExecutionBlockedEventStatus.WAITING_FOR_QUEUE }\n  | {\n      status: StepExecutionBlockedEventStatus.WAITING_FOR_WALLET_CONNECT;\n      requiredWallet?: string;\n      requiredAccount?: string;\n    }\n  | {\n      status: StepExecutionBlockedEventStatus.WAITING_FOR_CHANGE_WALLET_ACCOUNT;\n      requiredAccount?: string;\n    }\n  | {\n      status: StepExecutionBlockedEventStatus.WAITING_FOR_NETWORK_CHANGE;\n      currentNetwork?: string;\n      requiredNetwork?: string;\n    };\n\nexport type RouteStartedEvent = Event<RouteEventType.STARTED>;\n\nexport type RouteFailedEvent = Event<\n  RouteEventType.FAILED,\n  FailedRouteEventPayload\n>;\n\nexport type RouteSucceededEvent = Event<\n  RouteEventType.SUCCEEDED,\n  SucceededRouteEventPayload\n>;\n\nexport type StepStartedEvent = Event<StepEventType.STARTED>;\n\nexport type StepSucceededEvent = Event<\n  StepEventType.SUCCEEDED,\n  SucceededStepEventPayload\n>;\nexport type StepFailedEvent = Event<\n  StepEventType.FAILED,\n  FailedStepEventPayload\n>;\n\nexport type StepTxExecutionUpdatedEvent = Event<\n  StepEventType.TX_EXECUTION,\n  StepExecutionEventPayload\n>;\n\nexport type StepTxExecutionBlockedEvent = Event<\n  StepEventType.TX_EXECUTION_BLOCKED,\n  StepBlockedEventPayload\n>;\n\nexport type StepCheckStatusEvent = Event<StepEventType.CHECK_STATUS>;\n\nexport type StepApprovalTxSucceededEvent =\n  Event<StepEventType.APPROVAL_TX_SUCCEEDED>;\n\nexport type StepOutputRevealedEvent = Event<\n  StepEventType.OUTPUT_REVEALED,\n  OutputRevealedEventPayload\n>;\n\nexport type StepEvent =\n  | StepStartedEvent\n  | StepSucceededEvent\n  | StepFailedEvent\n  | StepTxExecutionUpdatedEvent\n  | StepTxExecutionBlockedEvent\n  | StepCheckStatusEvent\n  | StepApprovalTxSucceededEvent\n  | StepOutputRevealedEvent;\n\nexport type RouteEvent =\n  | RouteStartedEvent\n  | RouteSucceededEvent\n  | RouteFailedEvent;\n\nexport type RouteExecutionEvents = {\n  [MainEvents.RouteEvent]: { route: Route; event: RouteEvent };\n  [MainEvents.StepEvent]: { route: Route; step: Step; event: StepEvent };\n};\n", "import {\n  ExecuterActions,\n  QueueInfo,\n  QueueName,\n  QueueType,\n} from '@rango-dev/queue-manager-core';\nimport {\n  ArrayElement,\n  BlockReason,\n  StepEventType,\n  SwapActionTypes,\n  SwapQueueContext,\n  SwapQueueDef,\n  SwapStorage,\n  StepExecutionEventStatus,\n  StepExecutionBlockedEventStatus,\n  Step,\n} from './types';\nimport {\n  getBlockChainNameFromId,\n  Meta,\n  Network,\n  Networks,\n  WalletState,\n  WalletType,\n} from '@rango-dev/wallets-shared';\nimport { Providers, readAccountAddress } from '@rango-dev/wallets-react';\n\nimport {\n  Transaction,\n  TransactionType,\n  EvmBlockchainMeta,\n  CreateTransactionResponse,\n} from 'rango-sdk';\n\nimport {\n  DEFAULT_ERROR_CODE,\n  ERROR_MESSAGE_WAIT_FOR_CHANGE_NETWORK,\n  ERROR_MESSAGE_WAIT_FOR_WALLET,\n  ERROR_MESSAGE_WAIT_FOR_WALLET_DESCRIPTION,\n} from './constants';\nimport { Manager } from '@rango-dev/queue-manager-core';\nimport { Status } from '@rango-dev/queue-manager-core';\nimport {\n  getCurrentBlockchainOf,\n  getCurrentBlockchainOfOrNull,\n  getScannerUrl,\n  getRelatedWalletOrNull,\n  MessageSeverity,\n  PendingSwap,\n  PendingSwapNetworkStatus,\n  PendingSwapStep,\n  StepStatus,\n  SwapStatus,\n  Wallet,\n  getRelatedWallet,\n  getCurrentAddressOf,\n} from './shared';\nimport { logRPCError } from './shared-sentry';\nimport {\n  PrettyError,\n  mapAppErrorCodesToAPIErrorCode,\n  prettifyErrorMessage,\n} from './shared-errors';\nimport { httpService } from './services';\nimport { APIErrorCode, SignerErrorCode } from 'rango-types/lib';\nimport { notifier } from './services/eventEmitter';\n\ntype WhenTaskBlocked = Parameters<NonNullable<SwapQueueDef['whenTaskBlocked']>>;\ntype WhenTaskBlockedEvent = WhenTaskBlocked[0];\ntype WhenTaskBlockedMeta = WhenTaskBlocked[1];\n\nlet swapClaimedBy: { id: string } | null = null;\n\n/**\n *\n * We simply use module-level variable to keep track of which queue has claimed the execution of parallel runnings.\n *\n */\nexport function claimQueue() {\n  return {\n    claimedBy: () => swapClaimedBy?.id,\n    setClaimer: (queue_id: string) => {\n      swapClaimedBy = {\n        id: queue_id,\n      };\n    },\n    reset: () => {\n      swapClaimedBy = null;\n    },\n  };\n}\n\n/**\n *\n * We use module-level variable to keep track of\n * map of transactions hash to the TransactionResponse and ...\n *\n */\ntype TransactionData = {\n  response?: any; // e.g. TransactionResponse in case of EVM transactions\n  receiptReceived?: boolean; // e.g. is TransactionReceipt ready in case of EVM transactions\n};\nconst swapTransactionToDataMap: { [id: string]: TransactionData } = {};\nexport function inMemoryTransactionsData() {\n  return {\n    getTransactionDataByHash: (hash: string) =>\n      swapTransactionToDataMap[hash] || {},\n    setTransactionDataByHash: (hash: string, data: TransactionData) => {\n      const r = swapTransactionToDataMap[hash];\n      if (!r) swapTransactionToDataMap[hash] = {};\n      swapTransactionToDataMap[hash].response =\n        data.response || swapTransactionToDataMap[hash].response;\n      swapTransactionToDataMap[hash].receiptReceived =\n        data.receiptReceived ||\n        swapTransactionToDataMap[hash].receiptReceived ||\n        false;\n    },\n  };\n}\n\n/**\n * Sample inputs are:\n *  - \"metamask-ETH\"\n *  - \"metamask-BSC-BSC:0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n *  - \"token-pocket-BSC-BSC:0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n * Returns \"wallet and network\" separately, even if the wallet is dashed inside.\n *\n */\n\nexport function splitWalletNetwork(input: string): string[] {\n  const removedAddressInput = input?.split(':')[0] || '';\n  const splittedInput = removedAddressInput.split('-');\n  const network = splittedInput[splittedInput.length - 1];\n  const walletNetwork = splittedInput.slice(0, -1);\n\n  if (walletNetwork[walletNetwork.length - 1] === network) {\n    walletNetwork.pop();\n  }\n  const wallet = walletNetwork.join('-');\n\n  return [wallet, network];\n}\n\n/**\n *\n * Returns `steps`, if it's a `running` swap.\n * Each `PendingSwap` has a `steps` inside it, `steps` shows how many tasks should be created and run to finish the swap.\n *\n */\nexport const getCurrentStep = (swap: PendingSwap): PendingSwapStep | null => {\n  return (\n    swap.steps.find(\n      (step) => step.status !== 'failed' && step.status !== 'success'\n    ) || null\n  );\n};\n\n/**\n *\n * Returns current step transaction\n *\n */\nexport const getCurrentStepTx = (\n  currentStep: PendingSwapStep\n): Transaction | null => {\n  const {\n    evmTransaction,\n    evmApprovalTransaction,\n    cosmosTransaction,\n    solanaTransaction,\n    transferTransaction,\n    starknetApprovalTransaction,\n    starknetTransaction,\n    tronApprovalTransaction,\n    tronTransaction,\n    tonTransaction,\n  } = currentStep;\n  return (\n    evmTransaction ||\n    evmApprovalTransaction ||\n    cosmosTransaction ||\n    solanaTransaction ||\n    transferTransaction ||\n    starknetApprovalTransaction ||\n    starknetTransaction ||\n    tronApprovalTransaction ||\n    tronTransaction ||\n    tonTransaction\n  );\n};\n\n/**\n *\n * Set current step transaction\n *\n */\nexport const setCurrentStepTx = (\n  currentStep: PendingSwapStep,\n  transaction: Transaction\n): PendingSwapStep => {\n  currentStep.transferTransaction = null;\n  currentStep.cosmosTransaction = null;\n  currentStep.evmTransaction = null;\n  currentStep.solanaTransaction = null;\n  currentStep.evmApprovalTransaction = null;\n  currentStep.starknetApprovalTransaction = null;\n  currentStep.starknetTransaction = null;\n  currentStep.tronApprovalTransaction = null;\n  currentStep.tronTransaction = null;\n  currentStep.tonTransaction = null;\n\n  const txType = transaction.type;\n  switch (txType) {\n    case TransactionType.EVM:\n      if (transaction.isApprovalTx)\n        currentStep.evmApprovalTransaction = transaction;\n      else currentStep.evmTransaction = transaction;\n      break;\n    case TransactionType.TRON:\n      if (transaction.isApprovalTx)\n        currentStep.tronApprovalTransaction = transaction;\n      else currentStep.tronTransaction = transaction;\n      break;\n    case TransactionType.STARKNET:\n      if (transaction.isApprovalTx)\n        currentStep.starknetApprovalTransaction = transaction;\n      else currentStep.starknetTransaction = transaction;\n      break;\n    case TransactionType.COSMOS:\n      currentStep.cosmosTransaction = transaction;\n      break;\n    case TransactionType.SOLANA:\n      currentStep.solanaTransaction = transaction;\n      break;\n    case TransactionType.TRANSFER:\n      currentStep.transferTransaction = transaction;\n      break;\n    case TransactionType.TON:\n      currentStep.tonTransaction = transaction;\n      break;\n    default:\n      ((x: never) => {\n        throw new Error(`${x} was unhandled!`);\n      })(txType);\n  }\n  return currentStep;\n};\n\n/**\n *\n * Returns current step transaction type\n *\n */\nexport const getCurrentStepTxType = (\n  currentStep: PendingSwapStep\n): TransactionType | undefined => {\n  return getCurrentStepTx(currentStep)?.type;\n};\n\n/**\n *\n * Returns a boolean indicating that current step is an approval tx or not.\n *\n */\nexport const isApprovalCurrentStepTx = (\n  currentStep: PendingSwapStep\n): boolean => {\n  const {\n    evmApprovalTransaction,\n    starknetApprovalTransaction,\n    tronApprovalTransaction,\n  } = currentStep;\n  return !!(\n    evmApprovalTransaction ||\n    starknetApprovalTransaction ||\n    tronApprovalTransaction\n  );\n};\n\n/**\n * When we are doing a swap, there are some common fields that will be updated together.\n * This function helps us to update a swap status and also it will update some more fields like `extraMessageSeverity` based on the input.\n */\nexport function updateSwapStatus({\n  getStorage,\n  setStorage,\n  nextStatus,\n  nextStepStatus,\n  message,\n  details,\n  errorCode = null,\n  hasAlreadyProceededToSign,\n}: {\n  getStorage: ExecuterActions<\n    SwapStorage,\n    SwapActionTypes,\n    SwapQueueContext\n  >['getStorage'];\n  setStorage: ExecuterActions<\n    SwapStorage,\n    SwapActionTypes,\n    SwapQueueContext\n  >['setStorage'];\n  nextStatus?: SwapStatus;\n  nextStepStatus?: StepStatus;\n  message?: string;\n  details?: string | null | undefined;\n  errorCode?: APIErrorCode | SignerErrorCode | null;\n  hasAlreadyProceededToSign?: boolean;\n}): {\n  swap: PendingSwap;\n  step: PendingSwapStep | null;\n  failureType?: APIErrorCode;\n} {\n  const swap = getStorage().swapDetails;\n  const currentStep = getCurrentStep(swap);\n  const updatedResult: {\n    swap: PendingSwap;\n    step: PendingSwapStep | null;\n    failureType?: APIErrorCode;\n  } = {\n    swap,\n    step: currentStep,\n  };\n  if (!!nextStepStatus && !!currentStep) currentStep.status = nextStepStatus;\n\n  if (nextStatus) swap.status = nextStatus;\n  swap.hasAlreadyProceededToSign = hasAlreadyProceededToSign;\n  if (!!nextStatus && ['failed', 'success'].includes(nextStatus))\n    swap.finishTime = new Date().getTime().toString();\n\n  if (!!message || !!details) {\n    swap.extraMessage = message || '';\n    swap.extraMessageDetail = details || '';\n  }\n\n  if (!!nextStepStatus && ['failed'].includes(nextStepStatus)) {\n    //if user cancel the swap, we should pass relevant reason to the server.\n    const errorReason =\n      details && details.includes('Warning')\n        ? 'Swap canceled by user.'\n        : details;\n    const walletType = getRelatedWalletOrNull(swap, currentStep!)?.walletType;\n    swap.extraMessageSeverity = MessageSeverity.error;\n\n    const failureType = mapAppErrorCodesToAPIErrorCode(errorCode);\n    updatedResult.failureType = failureType;\n\n    httpService()\n      .reportFailure({\n        requestId: swap.requestId,\n        step: currentStep?.id || 1,\n        eventType: failureType,\n        reason: errorReason || '',\n        tags: walletType\n          ? {\n              wallet: walletType,\n            }\n          : undefined,\n      })\n      .then()\n      .catch();\n  } else if (!!nextStepStatus && ['running'].includes(nextStepStatus))\n    swap.extraMessageSeverity = MessageSeverity.info;\n  else if (!!nextStepStatus && ['success', 'approved'].includes(nextStepStatus))\n    swap.extraMessageSeverity = MessageSeverity.success;\n  else if (nextStepStatus && ['waitingForApproval'].includes(nextStepStatus))\n    swap.extraMessageSeverity = MessageSeverity.warning;\n\n  if (nextStepStatus === 'running' && currentStep)\n    currentStep.startTransactionTime = new Date().getTime();\n\n  setStorage({\n    ...getStorage(),\n    swapDetails: swap,\n  });\n\n  return updatedResult;\n}\n\n/**\n *\n * Set current step transaction hash, update pending swap status, and notify user if needed\n *\n */\nexport function setStepTransactionIds(\n  { getStorage, setStorage }: ExecuterActions<SwapStorage, SwapActionTypes>,\n  txId: string | null,\n  explorerUrl?: { url?: string; description?: string }\n): void {\n  const swap = getStorage().swapDetails;\n  swap.hasAlreadyProceededToSign = null;\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  const currentStep = getCurrentStep(swap)!;\n  currentStep.executedTransactionId = txId;\n  currentStep.executedTransactionTime = new Date().getTime().toString();\n  if (explorerUrl?.url)\n    currentStep.explorerUrl = [\n      ...(currentStep.explorerUrl || []),\n      {\n        url: explorerUrl.url,\n        description: explorerUrl.description || null,\n      },\n    ];\n\n  const isApproval = isApprovalCurrentStepTx(currentStep);\n\n  if (isApproval) swap.extraMessage = 'Checking approve transaction status ...';\n  else swap.extraMessage = 'Checking transaction status ...';\n\n  swap.extraMessageDetail = '';\n  swap.extraMessageSeverity = MessageSeverity.info;\n\n  setStorage({\n    ...getStorage(),\n    swapDetails: swap,\n  });\n\n  notifier({\n    event: {\n      type: StepEventType.TX_EXECUTION,\n      status: StepExecutionEventStatus.TX_SENT,\n    },\n    swap: swap,\n    step: currentStep,\n  });\n\n  notifier({\n    event: { type: StepEventType.CHECK_STATUS },\n    swap: swap,\n    step: currentStep,\n  });\n}\n\n/**\n * If a swap needs a wallet to be connected,\n * By calling this function some related fields will be updated to show a correct message and state for notfiying the user.\n */\nexport function markRunningSwapAsWaitingForConnectingWallet(\n  {\n    getStorage,\n    setStorage,\n  }: Pick<ExecuterActions, 'getStorage' | 'setStorage'>,\n  reason: string,\n  reasonDetail: string\n): void {\n  const swap = getStorage().swapDetails as SwapStorage['swapDetails'];\n  const currentStep = getCurrentStep(swap);\n  if (!currentStep) return;\n  const currentTime = new Date();\n  swap.lastNotificationTime = currentTime.getTime().toString();\n\n  const isAlreadyMarked =\n    currentStep.networkStatus ===\n      PendingSwapNetworkStatus.WaitingForConnectingWallet &&\n    swap.networkStatusExtraMessage === reason &&\n    swap.networkStatusExtraMessageDetail === reasonDetail;\n\n  if (isAlreadyMarked) {\n    return;\n  }\n\n  currentStep.networkStatus =\n    PendingSwapNetworkStatus.WaitingForConnectingWallet;\n  swap.networkStatusExtraMessage = reason;\n  swap.networkStatusExtraMessageDetail = reasonDetail;\n\n  setStorage({\n    ...getStorage(),\n    swapDetails: swap,\n  });\n}\n\n/**\n * If a swap needs a certain network to proceed,\n * By calling this function some related fields will be updated to show a correct message and state for notfiying the user.\n */\nexport function markRunningSwapAsSwitchingNetwork({\n  getStorage,\n  setStorage,\n}: Pick<ExecuterActions, 'getStorage' | 'setStorage'>):\n  | {\n      swap: PendingSwap;\n      step: PendingSwapStep;\n    }\n  | undefined {\n  const swap = getStorage().swapDetails as SwapStorage['swapDetails'];\n\n  const currentStep = getCurrentStep(swap);\n  if (!currentStep) return;\n\n  // Generate message\n  const { type } = getRequiredWallet(swap);\n  const fromBlockchain = getCurrentBlockchainOf(swap, currentStep);\n  const reason = `Change ${type} wallet network to ${fromBlockchain}`;\n  const reasonDetail = `Please change your ${type} wallet network to ${fromBlockchain}.`;\n\n  const currentTime = new Date();\n  swap.lastNotificationTime = currentTime.getTime().toString();\n\n  currentStep.networkStatus = PendingSwapNetworkStatus.WaitingForNetworkChange;\n  swap.networkStatusExtraMessage = reason;\n  swap.networkStatusExtraMessageDetail = reasonDetail;\n\n  setStorage({\n    ...getStorage(),\n    swapDetails: swap,\n  });\n\n  return {\n    swap,\n    step: currentStep,\n  };\n}\n\n/**\n * We are marking the queue as it depends on other queues to be run (on Parallel mode)\n * By calling this function some related fields will be updated to show a correct message and state for notfiying the user.\n */\nexport function markRunningSwapAsDependsOnOtherQueues({\n  getStorage,\n  setStorage,\n}: Pick<ExecuterActions, 'getStorage' | 'setStorage'>):\n  | {\n      swap: PendingSwap;\n      step: PendingSwapStep;\n    }\n  | undefined {\n  const swap = getStorage().swapDetails as SwapStorage['swapDetails'];\n  const currentStep = getCurrentStep(swap);\n  if (!currentStep) return;\n\n  swap.networkStatusExtraMessage = '';\n  swap.networkStatusExtraMessageDetail = '';\n  currentStep.networkStatus = PendingSwapNetworkStatus.WaitingForQueue;\n\n  notifier({\n    event: {\n      type: StepEventType.TX_EXECUTION_BLOCKED,\n      status: StepExecutionBlockedEventStatus.WAITING_FOR_QUEUE,\n    },\n    swap,\n    step: currentStep,\n  });\n\n  setStorage({\n    ...getStorage(),\n    swapDetails: swap,\n  });\n\n  return {\n    swap,\n    step: currentStep,\n  };\n}\n\nexport function delay(ms: number): Promise<unknown> {\n  return new Promise((res) => setTimeout(res, ms));\n}\n\n/**\n *\n * To execute a swap, we are keeping the user prefrences on what wallet they are going to use for a sepecific blockchain\n * By passing the swap and the network we are looking for, it returns the wallet name that user selected.\n *\n */\nexport const getSwapWalletType = (\n  swap: PendingSwap,\n  network: Network\n): WalletType => {\n  return swap.wallets[network]?.walletType;\n};\n\n/**\n *\n * We are keeping the connected wallet in a specific structure (`Wallet`),\n * By using this function we normally want to check a specific wallet is connected and exists or not.\n *\n */\nexport function isWalletNull(wallet: Wallet | null): boolean {\n  return (\n    wallet === null ||\n    wallet?.blockchains === null ||\n    wallet?.blockchains.length === 0\n  );\n}\n\n/**\n * On our implementation for `wallets` package, We keep the instance in 2 ways\n * If it's a single chain wallet, it returns the instance directly,\n * If it's a multichain wallet, it returns a `Map` of instances.\n * This function will get the `ETHEREUM` instance in both types.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function getEvmProvider(providers: Providers, type: WalletType): any {\n  if (type && providers[type]) {\n    // we need this because provider can return an instance or a map of instances, so what you are doing here is try to detect that.\n    if (providers[type].size) return providers[type].get(Networks.ETHEREUM);\n\n    return providers[type];\n  }\n  return null;\n}\n\n/**\n * In a `PendingSwap`, each step needs a wallet to proceed,\n * By using this function we can access what wallet exactly we need to run current step.\n */\nexport function getRequiredWallet(swap: PendingSwap): {\n  type: WalletType | null;\n  network: Network | null;\n  address: string | null;\n} {\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  const step = getCurrentStep(swap)!;\n  const bcName = getCurrentBlockchainOfOrNull(swap, step);\n  if (!bcName) {\n    return {\n      type: null,\n      network: null,\n      address: null,\n    };\n  }\n\n  const walletType = getSwapWalletType(swap, bcName);\n  const sourceWallet = swap.wallets[bcName];\n\n  return {\n    type: walletType || null,\n    network: bcName,\n    address: sourceWallet ? sourceWallet.address : null,\n  };\n}\n\n/**\n * On EVM compatible wallets, There is one instance with different chains (like Polygon)\n * To get the chain from instance we will use this function.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nasync function getChainId(provider: any): Promise<string | number | null> {\n  try {\n    const chainId: number | string | null =\n      (await provider.request({ method: 'eth_chainId' })) || provider?.chainId;\n    return chainId;\n  } catch {\n    return provider?.chainId;\n  }\n}\n\n/**\n * For running a swap safely, we need to make sure about the state of wallet\n * which means the netowrk/chain of wallet should be exactly on what a transaction needs.\n */\nexport async function isNetworkMatchedForTransaction(\n  swap: PendingSwap,\n  step: PendingSwapStep,\n  wallet: Wallet | null,\n  meta: Meta,\n  providers: Providers\n): Promise<boolean> {\n  if (isWalletNull(wallet)) {\n    return false;\n  }\n  const fromBlockChain = getCurrentBlockchainOfOrNull(swap, step);\n  if (!fromBlockChain) return false;\n\n  if (\n    meta.evmBasedChains.find(\n      (evmBlochain) => evmBlochain.name === fromBlockChain\n    )\n  ) {\n    try {\n      const sourceWallet = swap.wallets[fromBlockChain];\n      if (sourceWallet) {\n        const provider = getEvmProvider(providers, sourceWallet.walletType);\n        const chainId: number | string | null = await getChainId(provider);\n        if (chainId) {\n          const blockChain = getBlockChainNameFromId(\n            chainId,\n            Object.entries(meta.blockchains).map(\n              ([, blockchainMeta]) => blockchainMeta\n            )\n          );\n          if (\n            blockChain &&\n            blockChain.toLowerCase() === fromBlockChain.toLowerCase()\n          )\n            return true;\n          if (\n            blockChain &&\n            blockChain.toLowerCase() !== fromBlockChain.toLowerCase()\n          )\n            return false;\n        }\n      }\n    } catch (e) {\n      console.log(e);\n    }\n    return false;\n  }\n  return true;\n}\n\nexport const isTxAlreadyCreated = (\n  swap: PendingSwap,\n  step: PendingSwapStep\n): boolean => {\n  const result =\n    swap.wallets[step.evmTransaction?.blockChain || ''] ||\n    swap.wallets[step.evmApprovalTransaction?.blockChain || ''] ||\n    swap.wallets[step.tronTransaction?.blockChain || ''] ||\n    swap.wallets[step.tronApprovalTransaction?.blockChain || ''] ||\n    swap.wallets[step.starknetTransaction?.blockChain || ''] ||\n    swap.wallets[step.starknetApprovalTransaction?.blockChain || ''] ||\n    swap.wallets[step.cosmosTransaction?.blockChain || ''] ||\n    swap.wallets[step.solanaTransaction?.blockChain || ''] ||\n    swap.wallets[step.tonTransaction?.blockChain || ''] ||\n    step.transferTransaction?.fromWalletAddress ||\n    null;\n\n  return result !== null;\n};\n\nexport function resetNetworkStatus(\n  actions: ExecuterActions<SwapStorage, SwapActionTypes, SwapQueueContext>\n): void {\n  const { getStorage, setStorage } = actions;\n  const swap = getStorage().swapDetails;\n  const currentStep = getCurrentStep(swap);\n\n  if (currentStep?.networkStatus) {\n    currentStep.networkStatus = null;\n    setStorage({ ...getStorage(), swapDetails: swap });\n  }\n}\n\nexport function updateNetworkStatus(\n  actions: ExecuterActions<SwapStorage, SwapActionTypes, SwapQueueContext>,\n  data: {\n    message: string;\n    details: string;\n    status: PendingSwapNetworkStatus | null;\n  } = {\n    message: '',\n    details: '',\n    status: null,\n  }\n): void {\n  const { message, details, status } = data;\n  const { getStorage, setStorage } = actions;\n  const swap = getStorage().swapDetails;\n  const currentStep = getCurrentStep(swap);\n\n  if (currentStep?.networkStatus) {\n    swap.networkStatusExtraMessage = message;\n    swap.networkStatusExtraMessageDetail = details;\n    currentStep.networkStatus = status;\n    setStorage({ ...getStorage(), swapDetails: swap });\n  }\n}\n\n/**\n * Event handler for blocked tasks.\n * If a transcation execution is manually blocked (like for parallel or waiting for wallet),\n * This function will be called by queue manager using `queue definition`.\n *\n * It checks if the required wallet is connected, unblock the queue to be run.\n */\nexport function onBlockForConnectWallet(\n  event: WhenTaskBlockedEvent,\n  meta: WhenTaskBlockedMeta\n): void {\n  const { context, queue } = meta;\n  const swap = queue.getStorage().swapDetails as SwapStorage['swapDetails'];\n\n  const { ok, reason } = isRequiredWalletConnected(swap, context.state);\n\n  if (!ok) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const currentStep = getCurrentStep(swap)!;\n    const { type: walletType, address } = getRequiredWallet(swap);\n    notifier({\n      event: {\n        type: StepEventType.TX_EXECUTION_BLOCKED,\n        ...(reason === 'account_miss_match'\n          ? {\n              status:\n                StepExecutionBlockedEventStatus.WAITING_FOR_CHANGE_WALLET_ACCOUNT,\n              requiredAccount: address ?? undefined,\n            }\n          : {\n              status:\n                StepExecutionBlockedEventStatus.WAITING_FOR_WALLET_CONNECT,\n              requiredWallet: walletType ?? undefined,\n              requiredAccount: address ?? undefined,\n            }),\n      },\n      swap: swap,\n      step: currentStep,\n    });\n\n    markRunningSwapAsWaitingForConnectingWallet(\n      {\n        getStorage: queue.getStorage.bind(queue),\n        setStorage: queue.setStorage.bind(queue),\n      },\n      ERROR_MESSAGE_WAIT_FOR_WALLET,\n      event.reason.description\n    );\n\n    return;\n  }\n\n  queue.unblock();\n}\n\n/**\n * Event handler for blocked tasks.\n * If a transcation execution is manually blocked (like for parallel or waiting for walle),\n * This function will be called by queue manager using `queue definition`.\n *\n * It checks if the required network is connected, unblock the queue to be run.\n * Note: it automatically try to switch the network if its `provider` supports.\n */\nexport function onBlockForChangeNetwork(\n  _event: WhenTaskBlockedEvent,\n  meta: WhenTaskBlockedMeta\n): void {\n  const { context, queue } = meta;\n  const swap = queue.getStorage().swapDetails as SwapStorage['swapDetails'];\n  const currentStep = getCurrentStep(swap);\n\n  if (!currentStep || swap.status !== 'running') return;\n\n  const result = markRunningSwapAsSwitchingNetwork({\n    getStorage: queue.getStorage.bind(queue),\n    setStorage: queue.setStorage.bind(queue),\n  });\n\n  const requiredNetwork = getCurrentBlockchainOfOrNull(swap, currentStep);\n\n  const requiredWallet = getRequiredWallet(swap).type;\n\n  const currentNetwork = requiredWallet\n    ? context.state(requiredWallet).network\n    : undefined;\n\n  if (result) {\n    notifier({\n      event: {\n        type: StepEventType.TX_EXECUTION_BLOCKED,\n        status: StepExecutionBlockedEventStatus.WAITING_FOR_NETWORK_CHANGE,\n        requiredNetwork: requiredNetwork ?? undefined,\n        currentNetwork: currentNetwork ?? undefined,\n      },\n      swap: result.swap,\n      step: result.step,\n    });\n  }\n\n  // Try to auto switch\n  const { type, network } = getRequiredWallet(swap);\n  if (!!type && !!network) {\n    if (context.canSwitchNetworkTo(type, network)) {\n      const result = context.switchNetwork(type, network);\n      if (result) {\n        result\n          .then(() => {\n            queue.unblock();\n          })\n          .catch((error) => {\n            // ignore switch network errors\n            console.log({ error });\n          });\n      }\n    }\n  }\n}\n\n/**\n * Event handler for blocked tasks. (Parallel mode)\n * If a transcation execution flow is manually blocked (like for parallel or waiting for walle),\n * This function will be called by queue manager using `queue definition`.\n *\n * It checks the blocked tasks, if there is no active `claimed` queue, try to give it to the best candidate.\n */\nexport function onDependsOnOtherQueues(\n  _event: WhenTaskBlockedEvent,\n  meta: WhenTaskBlockedMeta\n): void {\n  const { getBlockedTasks, forceExecute, queue, manager, context } = meta;\n  const { setClaimer, claimedBy, reset } = claimQueue();\n\n  // We only needs those blocked tasks that have DEPENDS_ON_OTHER_QUEUES reason.\n  const blockedTasks = getBlockedTasks().filter(\n    (task) => task.reason.reason === BlockReason.DEPENDS_ON_OTHER_QUEUES\n  );\n\n  if (blockedTasks.length === 0) {\n    return;\n  }\n\n  const claimerId = claimedBy();\n  const isClaimedByAnyQueue = !!claimerId;\n\n  if (claimerId === queue.id) return;\n\n  // Check if any queue `claimed` before, if yes, we don't should do anything.\n  if (isClaimedByAnyQueue) {\n    // We need to keep the latest swap messages\n    markRunningSwapAsDependsOnOtherQueues({\n      getStorage: queue.getStorage.bind(queue),\n      setStorage: queue.setStorage.bind(queue),\n    });\n    return;\n  }\n\n  // Prioritize current queue to be run first.\n\n  let task = blockedTasks.find((task) => {\n    return task.queue_id === meta.queue_id;\n  });\n\n  // If current task isn't available anymore, fallback to first blocked task.\n  if (!task) {\n    const firstBlockedTask = blockedTasks[0];\n    task = firstBlockedTask;\n  }\n\n  setClaimer(task.queue_id);\n  const claimedStorage = task.storage.get() as SwapStorage;\n  const { type, network, address } = getRequiredWallet(\n    claimedStorage.swapDetails\n  );\n\n  // Run\n  forceExecute(task.queue_id, {\n    claimedBy: claimedBy(),\n    resetClaimedBy: () => {\n      reset();\n      // TODO: Use key generator\n      retryOn(\n        `${type}-${network}:${address}`,\n        manager,\n        context.canSwitchNetworkTo\n      );\n    },\n  });\n}\n\nexport function isRequiredWalletConnected(\n  swap: PendingSwap,\n  getState: (type: WalletType) => WalletState\n): { ok: boolean; reason: 'not_connected' | 'account_miss_match' } {\n  const { type, address } = getRequiredWallet(swap);\n  if (!type || !address) {\n    return { ok: false, reason: 'not_connected' };\n  }\n  const walletState = getState(type);\n  const { accounts, connected } = walletState;\n  const connectedAccounts = accounts || [];\n  if (!connected) return { ok: false, reason: 'not_connected' };\n\n  const matched = connectedAccounts.some((account) => {\n    const { address: accountAddress } = readAccountAddress(account);\n    return address.toLocaleLowerCase() === accountAddress.toLocaleLowerCase();\n  });\n  return { ok: matched, reason: 'account_miss_match' };\n}\n\nexport function singTransaction(\n  actions: ExecuterActions<SwapStorage, SwapActionTypes, SwapQueueContext>\n): void {\n  const { setTransactionDataByHash } = inMemoryTransactionsData();\n  const { getStorage, setStorage, failed, next, schedule, context } = actions;\n  const { meta, getSigners, isMobileWallet } = context;\n  const swap = getStorage().swapDetails;\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  const currentStep = getCurrentStep(swap)!;\n\n  const sourceWallet = getRelatedWallet(swap, currentStep);\n  const mobileWallet = isMobileWallet(sourceWallet?.walletType);\n  const walletAddress = getCurrentAddressOf(swap, currentStep);\n  const walletSigners = getSigners(sourceWallet.walletType);\n  const currentStepBlockchain = getCurrentBlockchainOf(swap, currentStep);\n\n  const onFinish = () => {\n    // TODO resetClaimedBy is undefined here\n    if (actions.context.resetClaimedBy) {\n      actions.context.resetClaimedBy();\n    }\n  };\n\n  const tx = getCurrentStepTx(currentStep);\n  const txType = tx?.type;\n  const isApproval = isApprovalCurrentStepTx(currentStep);\n\n  if (!tx || !txType) {\n    const extraMessage = 'Unexpected Error: tx is null!';\n    const updateResult = updateSwapStatus({\n      getStorage,\n      setStorage,\n      nextStatus: 'failed',\n      nextStepStatus: 'failed',\n      message: extraMessage,\n      details: undefined,\n      errorCode: 'CLIENT_UNEXPECTED_BEHAVIOUR',\n    });\n    notifier({\n      event: {\n        type: StepEventType.FAILED,\n        reason: extraMessage,\n        reasonCode: 'CLIENT_UNEXPECTED_BEHAVIOUR',\n      },\n      ...updateResult,\n    });\n    failed();\n    return onFinish();\n  }\n\n  const chainId = meta.blockchains?.[tx.blockChain]?.chainId;\n\n  const hasAlreadyProceededToSign =\n    typeof swap.hasAlreadyProceededToSign === 'boolean';\n\n  let nextStatus: SwapStatus | undefined,\n    nextStepStatus: StepStatus,\n    message: string,\n    details: string,\n    eventType: StepEventType;\n\n  if (isApproval) {\n    message = `Waiting for approval of ${currentStep?.fromSymbol} coin ${\n      mobileWallet ? 'on your mobile phone!' : ''\n    }`;\n    details =\n      'Waiting for approve transaction to be mined and confirmed successfully';\n    nextStepStatus = 'waitingForApproval';\n    nextStatus = undefined;\n    eventType = StepEventType.TX_EXECUTION;\n  } else if (hasAlreadyProceededToSign) {\n    message = 'Transaction is expired. Please try again.';\n    nextStepStatus = 'failed';\n    nextStatus = 'failed';\n    details = '';\n    eventType = StepEventType.FAILED;\n  } else {\n    message = 'Executing transaction ...';\n    nextStepStatus = 'running';\n    nextStatus = 'running';\n    details = `${mobileWallet ? 'Check your mobile phone!' : ''}`;\n    eventType = StepEventType.TX_EXECUTION;\n  }\n\n  const updateResult = updateSwapStatus({\n    getStorage,\n    setStorage,\n    nextStepStatus,\n    nextStatus,\n    message: message,\n    details: details,\n    hasAlreadyProceededToSign: isApproval\n      ? undefined\n      : hasAlreadyProceededToSign,\n    errorCode: hasAlreadyProceededToSign ? 'TX_EXPIRED' : undefined,\n  });\n\n  if (eventType === StepEventType.FAILED) {\n    notifier({\n      event: {\n        type: eventType,\n        reason: message,\n        reasonCode: updateResult.failureType ?? DEFAULT_ERROR_CODE,\n      },\n      ...updateResult,\n    });\n  } else\n    notifier({\n      event: { type: eventType, status: StepExecutionEventStatus.SEND_TX },\n      ...updateResult,\n    });\n\n  if (hasAlreadyProceededToSign) {\n    failed();\n    onFinish();\n    return;\n  }\n  const signer = walletSigners.getSigner(txType);\n  signer.signAndSendTx(tx, walletAddress, chainId).then(\n    ({ hash, response }) => {\n      const explorerUrl = getScannerUrl(\n        hash,\n        currentStepBlockchain,\n        meta.blockchains\n      );\n      setStepTransactionIds(\n        actions,\n        hash,\n        explorerUrl &&\n          (!response || (response && !response.hashRequiringUpdate))\n          ? { url: explorerUrl, description: isApproval ? 'Approve' : 'Swap' }\n          : undefined\n      );\n      // response used for evm transactions to get receipt and track replaced\n      response && setTransactionDataByHash(hash, { response });\n      schedule(SwapActionTypes.CHECK_TRANSACTION_STATUS);\n      next();\n      onFinish();\n    },\n    (error) => {\n      if (swap.status === 'failed') return;\n\n      const { extraMessage, extraMessageDetail, extraMessageErrorCode } =\n        prettifyErrorMessage(error);\n\n      logRPCError(\n        error?.trace?.stack || error?.trace || error?.root || error,\n        swap,\n        currentStep,\n        sourceWallet?.walletType\n      );\n\n      const updateResult = updateSwapStatus({\n        getStorage,\n        setStorage,\n        nextStatus: 'failed',\n        nextStepStatus: 'failed',\n        message: extraMessage,\n        details: extraMessageDetail,\n        errorCode: extraMessageErrorCode,\n      });\n\n      notifier({\n        event: {\n          type: StepEventType.FAILED,\n          reason: extraMessage,\n          reasonCode: updateResult.failureType ?? DEFAULT_ERROR_CODE,\n        },\n        ...updateResult,\n      });\n      failed();\n      onFinish();\n    }\n  );\n}\n\nexport function checkWaitingForConnectWalletChange(params: {\n  wallet_network: string;\n  manager?: Manager;\n  evmChains: EvmBlockchainMeta[];\n}): void {\n  const { wallet_network, evmChains, manager } = params;\n  const [wallet, network] = splitWalletNetwork(wallet_network);\n  // We only need change network for EVM chains.\n  if (!evmChains.some((chain) => chain.name == network)) return;\n\n  manager?.getAll().forEach((q) => {\n    const queueStorage = q.list.getStorage() as SwapStorage | undefined;\n    const swap = queueStorage?.swapDetails;\n    if (swap && swap.status === 'running') {\n      const currentStep = getCurrentStep(swap);\n      if (currentStep) {\n        const currentStepRequiredWallet =\n          queueStorage?.swapDetails.wallets[currentStep.fromBlockchain]\n            ?.walletType;\n        const hasWaitingForConnect = Object.keys(q.list.state.tasks).some(\n          (taskId) => {\n            const task = q.list.state.tasks[taskId];\n            return (\n              task.status === Status.BLOCKED &&\n              // TODO double check later\n              [BlockReason.WAIT_FOR_CONNECT_WALLET].includes(\n                task.blockedFor?.reason\n              )\n            );\n          }\n        );\n\n        const requiredNetwork = getCurrentBlockchainOfOrNull(swap, currentStep);\n\n        if (\n          currentStepRequiredWallet === wallet &&\n          hasWaitingForConnect &&\n          requiredNetwork != network\n        ) {\n          const queueInstance = q.list;\n          const { type } = getRequiredWallet(swap);\n          const description = ERROR_MESSAGE_WAIT_FOR_CHANGE_NETWORK(type);\n\n          q.list.block({\n            reason: {\n              reason: BlockReason.WAIT_FOR_NETWORK_CHANGE,\n              description,\n            },\n            silent: true,\n          });\n\n          const result = markRunningSwapAsSwitchingNetwork({\n            getStorage: queueInstance.getStorage.bind(queueInstance),\n            setStorage: queueInstance.setStorage.bind(queueInstance),\n          });\n\n          if (result) {\n            notifier({\n              event: {\n                type: StepEventType.TX_EXECUTION_BLOCKED,\n                status:\n                  StepExecutionBlockedEventStatus.WAITING_FOR_NETWORK_CHANGE,\n                currentNetwork: network,\n                requiredNetwork: requiredNetwork ?? undefined,\n              },\n              swap: result.swap,\n              step: result.step,\n            });\n          }\n        }\n      }\n    }\n  });\n}\n\nexport function checkWaitingForNetworkChange(manager?: Manager): void {\n  manager?.getAll().forEach((q) => {\n    const hasWaitingForNetwork = Object.keys(q.list.state.tasks).some(\n      (taskId) => {\n        const task = q.list.state.tasks[taskId];\n        return (\n          task.status === Status.BLOCKED &&\n          [\n            BlockReason.WAIT_FOR_NETWORK_CHANGE,\n            BlockReason.DEPENDS_ON_OTHER_QUEUES,\n          ].includes(task.blockedFor?.reason)\n        );\n      }\n    );\n\n    if (hasWaitingForNetwork) {\n      const swap = q.list.getStorage()\n        ?.swapDetails as SwapStorage['swapDetails'];\n      if (swap.status === 'running') {\n        const { type } = getRequiredWallet(swap);\n        const description = ERROR_MESSAGE_WAIT_FOR_WALLET_DESCRIPTION(type);\n\n        // Change the block reason to waiting for connecting wallet\n        q.list.block({\n          reason: {\n            reason: BlockReason.WAIT_FOR_CONNECT_WALLET,\n            description,\n          },\n        });\n      }\n    }\n  });\n}\n\n/**\n * Get list of all running swaps\n *\n * @param manager\n * @returns list of pending swaps\n */\nexport function getRunningSwaps(manager: Manager): PendingSwap[] {\n  const queues = manager?.getAll() || new Map<QueueName, QueueInfo>();\n  const result: PendingSwap[] = [];\n  queues.forEach((q) => {\n    // retry only on affected queues\n    const queueStorage = q.list.getStorage() as SwapStorage | undefined;\n    const swap = queueStorage?.swapDetails;\n    if (!swap || swap.status !== 'running') return;\n    result.push(swap);\n  });\n  return result;\n}\n\n/**\n *\n * Trying to reset notifications for pending swaps to correct message on page load.\n * We could remove this after supporting auto connect for wallets.\n *\n * @param swaps\n * @param notifier\n * @returns\n */\nexport function resetRunningSwapNotifsOnPageLoad(runningSwaps: PendingSwap[]) {\n  runningSwaps.forEach((swap) => {\n    const currentStep = getCurrentStep(swap);\n    const eventType = StepEventType.TX_EXECUTION_BLOCKED;\n    let eventSubtype:\n      | StepExecutionBlockedEventStatus.WAITING_FOR_QUEUE\n      | StepExecutionBlockedEventStatus.WAITING_FOR_WALLET_CONNECT\n      | undefined;\n    if (currentStep?.networkStatus === PendingSwapNetworkStatus.WaitingForQueue)\n      eventSubtype = StepExecutionBlockedEventStatus.WAITING_FOR_QUEUE;\n    else if (swap?.status === 'running') {\n      eventSubtype = StepExecutionBlockedEventStatus.WAITING_FOR_WALLET_CONNECT;\n    }\n    if (!!eventType && !!notifier) {\n      notifier({\n        event: {\n          type: eventType,\n          status:\n            eventSubtype ?? StepExecutionBlockedEventStatus.WAITING_FOR_QUEUE,\n        },\n        swap: swap,\n        step: currentStep,\n      });\n    }\n  });\n}\n\n/**\n *\n * Try to run blocked tasks by wallet and network name.\n * Goes through queues and extract blocked queues with matched wallet.\n * If found any blocked tasks with same wallet and network, runs them.\n * If not, runs only blocked tasks with matched wallet.\n *\n * @param wallet_network a string includes `wallet` type and `network` type.\n * @param manager\n * @returns\n */\nexport function retryOn(\n  wallet_network: string,\n  manager?: Manager,\n  canSwitchNetworkTo?: (type: WalletType, network: Network) => boolean,\n  options = { fallbackToOnlyWallet: true }\n): void {\n  const [wallet, network] = splitWalletNetwork(wallet_network);\n  if (!wallet || !network) {\n    return;\n  }\n\n  const walletAndNetworkMatched: QueueType[] = [];\n  const onlyWalletMatched: QueueType[] = [];\n\n  manager?.getAll().forEach((q) => {\n    // retry only on affected queues\n    if (q.status === Status.BLOCKED) {\n      const queueStorage = q.list.getStorage() as SwapStorage | undefined;\n      const swap = queueStorage?.swapDetails;\n\n      if (swap && swap.status === 'running') {\n        const currentStep = getCurrentStep(swap);\n        if (currentStep) {\n          if (\n            getCurrentBlockchainOfOrNull(swap, currentStep) == network &&\n            queueStorage?.swapDetails.wallets[network]?.walletType === wallet\n          ) {\n            walletAndNetworkMatched.push(q.list);\n          } else if (\n            queueStorage?.swapDetails.wallets[currentStep.fromBlockchain]\n              ?.walletType === wallet\n          ) {\n            onlyWalletMatched.push(q.list);\n          }\n        }\n      }\n    }\n  });\n\n  let finalQueueToBeRun: QueueType | undefined = undefined;\n  if (walletAndNetworkMatched.length > 0) {\n    finalQueueToBeRun = walletAndNetworkMatched[0];\n\n    if (walletAndNetworkMatched.length > 1) {\n      for (let i = 1; i < walletAndNetworkMatched.length; i++) {\n        const currentQueue = walletAndNetworkMatched[i];\n\n        markRunningSwapAsDependsOnOtherQueues({\n          getStorage: currentQueue.getStorage.bind(currentQueue),\n          setStorage: currentQueue.setStorage.bind(currentQueue),\n        });\n      }\n    }\n  } else if (onlyWalletMatched.length > 0 && options.fallbackToOnlyWallet) {\n    finalQueueToBeRun = onlyWalletMatched[0];\n  }\n\n  if (!canSwitchNetworkTo?.(wallet, network)) finalQueueToBeRun?.unblock();\n  else finalQueueToBeRun?.checkBlock();\n}\n\n/* \n  For avoiding conflict by making too many requests to wallet, we need to make sure\n  We only run one request at a time (In parallel mode).\n  */\nexport function isNeedBlockQueueForParallel(step: PendingSwapStep): boolean {\n  return !!step.evmTransaction || !!step.evmApprovalTransaction;\n}\n\n/*\nCreate transaction endpoint doesn't return error code on http status code,\nFor backward compatibilty with server and sdk, we use this wrapper to reject the promise.\n*/\nexport async function throwOnOK(\n  rawResponse: Promise<CreateTransactionResponse>\n): Promise<CreateTransactionResponse> {\n  const responseBody = await rawResponse;\n  if (!responseBody.ok || !responseBody.transaction) {\n    throw PrettyError.CreateTransaction(\n      responseBody.error || 'bad response from create tx endpoint'\n    );\n  }\n  return responseBody;\n}\n\nexport function cancelSwap(\n  swap: QueueInfo,\n  manager?: Manager\n): {\n  swap: PendingSwap;\n  step: PendingSwapStep | null;\n} {\n  const { reset } = claimQueue();\n  swap.actions.cancel();\n\n  const updateResult = updateSwapStatus({\n    getStorage: swap.actions.getStorage,\n    setStorage: swap.actions.setStorage,\n    message: 'Swap canceled by user.',\n    details:\n      \"Warning: If you've already signed and sent a transaction, it won't be affected, but next swap steps will not be executed.\",\n    nextStatus: 'failed',\n    nextStepStatus: 'failed',\n    errorCode: 'USER_CANCEL',\n  });\n\n  notifier({\n    event: {\n      type: StepEventType.FAILED,\n      reasonCode: 'USER_CANCEL',\n      reason: updateResult.swap.extraMessage ?? undefined,\n    },\n\n    swap: updateResult.swap,\n    step: updateResult.step,\n  });\n\n  reset();\n  if (manager) manager?.retry();\n\n  return updateResult;\n}\n\nexport function getLastSuccessfulStep<T extends { status: StepStatus }[]>(\n  steps: T\n): ArrayElement<T> | undefined {\n  return steps\n    .slice()\n    .reverse()\n    .find((step) => step.status === 'success') as ArrayElement<T> | undefined;\n}\n\nexport function getFailedStep<T extends { status: StepStatus }[]>(\n  steps: T\n): ArrayElement<T> | undefined {\n  return steps\n    .slice()\n    .reverse()\n    .find((step) => step.status === 'failed') as ArrayElement<T> | undefined;\n}\n\nexport function isApprovalTX(step: Step): boolean {\n  const { transaction } = step;\n  const approvalTx =\n    (transaction?.type === TransactionType.EVM && transaction.isApprovalTx) ||\n    (transaction?.type === TransactionType.STARKNET &&\n      transaction.isApprovalTx) ||\n    (transaction?.type === TransactionType.TRON && transaction.isApprovalTx);\n\n  return approvalTx;\n}\n", "export const ERROR_MESSAGE_DEPENDS_ON_OTHER_QUEUES =\n  'Waiting for other swaps to complete';\nexport const ERROR_MESSAGE_WAIT_FOR_WALLET = 'Waiting for connecting wallet';\nexport const ERROR_MESSAGE_WAIT_FOR_WALLET_DESCRIPTION_WRONG_WALLET = (\n  type: string | null,\n  address: string | null\n): string =>\n  `Please change your ${type || 'wallet'} account to ${\n    address || 'proper address'\n  }`;\nexport const ERROR_MESSAGE_WAIT_FOR_WALLET_DESCRIPTION = (\n  type: string | null\n): string =>\n  `Please connect to ${\n    type || 'your wallet'\n  } by using bellow button or top right button on page.`;\nexport const ERROR_MESSAGE_WAIT_FOR_CHANGE_NETWORK = (\n  network: string | null\n): string => `Please change your network to ${network}.`;\n\nexport const DEFAULT_ERROR_CODE = 'CLIENT_UNEXPECTED_BEHAVIOUR';\n", "import type {\n  APIErrorCode,\n  SignerErrorCode as SignerErrorCodeType,\n} from 'rango-types';\nimport {\n  SignerErrorCode,\n  SignerError,\n  isSignerErrorCode,\n  isAPIErrorCode,\n} from 'rango-types';\nimport { DEFAULT_ERROR_CODE } from './constants';\n\nexport type ErrorDetail = {\n  extraMessage: string;\n  extraMessageDetail?: string | null | undefined;\n  extraMessageErrorCode: SignerErrorCodeType | APIErrorCode | null;\n};\n\nconst ERROR_ASSERTION_FAILED = 'Assertion failed (Unexpected behaviour)';\nconst ERROR_CREATE_TRANSACTION = 'Create transaction failed in Rango Server';\nconst ERROR_INPUT_WALLET_NOT_FOUND = 'Input wallet not found';\n\ntype ErrorRoot = string | Record<string, string> | null;\n\nexport class PrettyError extends Error {\n  private readonly detail?: string;\n  private readonly root?: ErrorRoot;\n  private readonly code?: APIErrorCode;\n  public _isPrettyError = true;\n\n  constructor(\n    code: APIErrorCode,\n    m: string,\n    root?: ErrorRoot,\n    detail?: string\n  ) {\n    super(m);\n    Object.setPrototypeOf(this, PrettyError.prototype);\n    PrettyError.prototype._isPrettyError = true;\n    this.code = code;\n    this.detail = detail;\n    this.root = root;\n  }\n\n  static isPrettyError(obj: unknown): obj is PrettyError {\n    return (\n      obj instanceof PrettyError ||\n      Object.prototype.hasOwnProperty.call(obj, '_isPrettyError')\n    );\n  }\n\n  getErrorDetail(): ErrorDetail {\n    const rawMessage =\n      typeof this.root === 'object' && this.root && this.root.error\n        ? this.root.error\n        : JSON.stringify(this.root);\n    const rootStr =\n      typeof this.root === 'string'\n        ? this.root\n        : this.root instanceof Error\n        ? this.root.message\n        : rawMessage;\n    return {\n      extraMessage: this.message,\n      extraMessageDetail: this.detail || rootStr,\n      extraMessageErrorCode: this.code || null,\n    };\n  }\n\n  static AssertionFailed(m: string): PrettyError {\n    return new PrettyError(\n      'CLIENT_UNEXPECTED_BEHAVIOUR',\n      ERROR_ASSERTION_FAILED,\n      null,\n      m\n    );\n  }\n\n  static BadStatusCode(\n    message: string,\n    statusCode: number | string\n  ): PrettyError {\n    return new PrettyError(\n      'TX_FAIL',\n      message,\n      null,\n      `status code = ${statusCode}`\n    );\n  }\n\n  static CreateTransaction(detail: string): PrettyError {\n    return new PrettyError(\n      'FETCH_TX_FAILED',\n      ERROR_CREATE_TRANSACTION,\n      null,\n      detail\n    );\n  }\n\n  static WalletMissing(): PrettyError {\n    return new PrettyError(\n      'CLIENT_UNEXPECTED_BEHAVIOUR',\n      ERROR_INPUT_WALLET_NOT_FOUND,\n      null,\n      'Server requested for a blockchain or address not selected by user'\n    );\n  }\n\n  static BlockchainMissing(): PrettyError {\n    return new PrettyError(\n      'CLIENT_UNEXPECTED_BEHAVIOUR',\n      ERROR_INPUT_WALLET_NOT_FOUND,\n      null,\n      'Server requested for a blockchain or address not selected by user'\n    );\n  }\n}\n\nexport function mapAppErrorCodesToAPIErrorCode(\n  errorCode: string | null\n): APIErrorCode {\n  try {\n    if (!errorCode) return DEFAULT_ERROR_CODE;\n    if (isAPIErrorCode(errorCode)) return errorCode;\n    if (isSignerErrorCode(errorCode)) {\n      const t: { [key in SignerErrorCodeType]: APIErrorCode } = {\n        [SignerErrorCode.REJECTED_BY_USER]: 'USER_REJECT',\n        [SignerErrorCode.SIGN_TX_ERROR]: 'CALL_WALLET_FAILED',\n        [SignerErrorCode.SEND_TX_ERROR]: 'SEND_TX_FAILED',\n        [SignerErrorCode.TX_FAILED_IN_BLOCKCHAIN]: 'TX_FAILED_IN_BLOCKCHAIN',\n        [SignerErrorCode.NOT_IMPLEMENTED]: DEFAULT_ERROR_CODE,\n        [SignerErrorCode.OPERATION_UNSUPPORTED]: DEFAULT_ERROR_CODE,\n        [SignerErrorCode.UNEXPECTED_BEHAVIOUR]: DEFAULT_ERROR_CODE,\n      };\n      return t[errorCode];\n    }\n    return DEFAULT_ERROR_CODE;\n  } catch (err) {\n    return DEFAULT_ERROR_CODE;\n  }\n}\n\nexport const prettifyErrorMessage = (obj: unknown): ErrorDetail => {\n  if (!obj) return { extraMessage: '', extraMessageErrorCode: null };\n  if (PrettyError.isPrettyError(obj)) return obj.getErrorDetail();\n  if (SignerError.isSignerError(obj)) {\n    const t = obj.getErrorDetail();\n    return {\n      extraMessage: t.message,\n      extraMessageDetail: t.detail,\n      extraMessageErrorCode: t.code,\n    };\n  }\n  if (obj instanceof Error)\n    return {\n      extraMessage: obj.toString(),\n      extraMessageErrorCode: null,\n    };\n  if (typeof obj !== 'string')\n    return {\n      extraMessage: JSON.stringify(obj),\n      extraMessageErrorCode: null,\n    };\n  return { extraMessage: obj, extraMessageErrorCode: null };\n};\n", "import { Network, WalletType } from '@rango-dev/wallets-shared';\nimport {\n  CosmosTransaction,\n  EvmTransaction,\n  SimulationResult,\n  SolanaTransaction,\n  StarknetTransaction,\n  TronTransaction,\n  Transfer as TransferTransaction,\n  AmountRestrictionType,\n  BestRouteResponse,\n  MetaResponse,\n  Token,\n  SwapResult,\n  BlockchainMeta,\n} from 'rango-sdk';\n\nimport { PrettyError } from './shared-errors';\nimport BigNumber from 'bignumber.js';\nimport { numberToString } from './numbers';\nimport {\n  TonTransaction,\n  isCosmosBlockchain,\n  isEvmBlockchain,\n  isStarknetBlockchain,\n  isTronBlockchain,\n} from 'rango-types';\n\nexport interface PendingSwapWithQueueID {\n  id: string;\n  swap: PendingSwap;\n}\n\nexport type WalletBalance = {\n  chain: Network;\n  symbol: string;\n  ticker: string;\n  address: string | null;\n  rawAmount: string;\n  decimal: number | null;\n  amount: string;\n  logo: string | null;\n  usdPrice: number | null;\n};\n\nexport type Account = {\n  balances: WalletBalance[] | null;\n  address: string;\n  loading: boolean;\n  walletType: WalletType;\n  error: boolean;\n  explorerUrl: string | null;\n  isConnected?: boolean;\n};\nexport type Blockchain = { name: string; accounts: Account[] };\nexport type Wallet = { blockchains: Blockchain[] };\n\nexport type EventType =\n  | 'swap_started'\n  | 'confirm_contract'\n  | 'confirm_transfer'\n  | 'task_failed'\n  | 'task_completed'\n  | 'task_canceled'\n  | 'task_paused'\n  | 'contract_confirmed'\n  | 'confirm_approve_contract'\n  | 'contract_rejected'\n  | 'check_tx_status'\n  | 'check_approve_tx_status'\n  | 'transfer_rejected'\n  | 'transfer_failed'\n  | 'calling_smart_contract'\n  | 'smart_contract_called'\n  | 'smart_contract_call_failed'\n  | 'step_completed_with_output'\n  | 'waiting_for_network_change'\n  | 'waiting_for_connecting_wallet'\n  | 'waiting_for_change_wallet_account'\n  | 'network_changed'\n  | 'not_enough_balance'\n  | 'not_enough_approval'\n  | 'waiting_for_queue'\n  | 'check_fee_failed'\n  | 'route_failed_to_find'\n  | 'transaction_expired';\n\nexport type SwapSavedSettings = {\n  slippage: string;\n  disabledSwappersIds?: string[];\n  disabledSwappersGroups?: string[];\n  infiniteApprove?: boolean;\n};\n\ntype InternalStepState =\n  | 'PENDING'\n  | 'CREATED'\n  | 'WAITING'\n  | 'SIGNED'\n  | 'SUCCESSED'\n  | 'FAILED';\n\nexport type SwapperStatusStep = {\n  name: string;\n  state: InternalStepState;\n  current: boolean;\n};\n\nexport enum PendingSwapNetworkStatus {\n  WaitingForConnectingWallet = 'waitingForConnectingWallet',\n  WaitingForQueue = 'waitingForQueue',\n  WaitingForNetworkChange = 'waitingForNetworkChange',\n  NetworkChanged = 'networkChanged',\n}\n\nexport type SwapExplorerUrl = {\n  url: string;\n  description: string | null;\n};\n\nexport type StepStatus =\n  | 'created'\n  | 'running'\n  | 'failed'\n  | 'success'\n  | 'waitingForApproval'\n  | 'approved';\n\nexport type PendingSwapStep = {\n  // routing data\n  id: number;\n  fromBlockchain: string;\n  fromSymbol: string;\n  fromSymbolAddress: string | null;\n  fromDecimals: number;\n  fromAmountPrecision: string | null;\n  fromAmountMinValue: string | null;\n  fromAmountMaxValue: string | null;\n  fromAmountRestrictionType: AmountRestrictionType | null;\n  fromLogo: string;\n  toBlockchain: string;\n  toSymbol: string;\n  toSymbolAddress: string | null;\n  toDecimals: number;\n  toLogo: string;\n  swapperId: string;\n  expectedOutputAmountHumanReadable: string | null;\n  startTransactionTime: number;\n  internalSteps: SwapperStatusStep[] | null;\n  estimatedTimeInSeconds: number | null;\n\n  // status data\n  status: StepStatus;\n  networkStatus: PendingSwapNetworkStatus | null;\n  executedTransactionId: string | null;\n  executedTransactionTime: string | null;\n  explorerUrl: SwapExplorerUrl[] | null;\n  diagnosisUrl: string | null;\n  outputAmount: string | null;\n\n  // txs data\n  cosmosTransaction: CosmosTransaction | null;\n  transferTransaction: TransferTransaction | null;\n  solanaTransaction: SolanaTransaction | null;\n  evmApprovalTransaction: EvmTransaction | null;\n  evmTransaction: EvmTransaction | null;\n  tronApprovalTransaction: TronTransaction | null;\n  tronTransaction: TronTransaction | null;\n  starknetApprovalTransaction: StarknetTransaction | null;\n  starknetTransaction: StarknetTransaction | null;\n  tonTransaction: TonTransaction | null;\n\n  // missing fields in older versions\n  // keeping null for backward compatability\n  swapperLogo: string | null;\n  swapperType: string | null;\n  fromBlockchainLogo: string | null;\n  toBlockchainLogo: string | null;\n  feeInUsd: string | null;\n};\n\nexport type WalletTypeAndAddress = {\n  walletType: WalletType;\n  address: string;\n};\n\nexport enum MessageSeverity {\n  error = 'error',\n  warning = 'warning',\n  info = 'info',\n  success = 'success',\n}\n\nexport type SwapStatus = 'running' | 'failed' | 'success';\n\nexport type PendingSwap = {\n  creationTime: string;\n  finishTime: string | null;\n  requestId: string;\n  inputAmount: string;\n  status: SwapStatus;\n  isPaused: boolean;\n  extraMessage: string | null;\n  extraMessageSeverity: MessageSeverity | null;\n  extraMessageErrorCode: string | null;\n  extraMessageDetail: string | null | undefined;\n  networkStatusExtraMessage: string | null;\n  networkStatusExtraMessageDetail: string | null;\n  lastNotificationTime: string | null;\n  wallets: { [p: string]: WalletTypeAndAddress };\n  settings: SwapSavedSettings;\n  steps: PendingSwapStep[];\n  simulationResult: SimulationResult;\n  validateBalanceOrFee: boolean;\n  hasAlreadyProceededToSign?: boolean | null;\n};\n\nexport const getCurrentBlockchainOfOrNull = (\n  swap: PendingSwap,\n  step: PendingSwapStep\n): Network | null => {\n  try {\n    return getCurrentBlockchainOf(swap, step);\n  } catch (e) {\n    return null;\n  }\n};\n\nexport const getCurrentBlockchainOf = (\n  swap: PendingSwap,\n  step: PendingSwapStep\n): Network => {\n  const b1 =\n    step.evmTransaction?.blockChain ||\n    step.evmApprovalTransaction?.blockChain ||\n    step.starknetTransaction?.blockChain ||\n    step.starknetApprovalTransaction?.blockChain ||\n    step.tronTransaction?.blockChain ||\n    step.tronApprovalTransaction?.blockChain ||\n    step.cosmosTransaction?.blockChain ||\n    step.solanaTransaction?.blockChain ||\n    step.tonTransaction?.blockChain;\n  if (b1) return b1;\n\n  const transferAddress = step.transferTransaction?.fromWalletAddress;\n  if (!transferAddress) throw PrettyError.BlockchainMissing();\n\n  const blockchain =\n    Object.keys(swap.wallets).find(\n      (b) => swap.wallets[b]?.address === transferAddress\n    ) || null;\n  if (blockchain == null) throw PrettyError.BlockchainMissing();\n\n  return blockchain;\n};\n\nconst getBlockchainMetaExplorerBaseUrl = (\n  blockchainMeta: BlockchainMeta\n): string | undefined => {\n  if (isCosmosBlockchain(blockchainMeta))\n    return blockchainMeta.info?.explorerUrlToTx;\n  else if (\n    isEvmBlockchain(blockchainMeta) ||\n    isStarknetBlockchain(blockchainMeta) ||\n    isTronBlockchain(blockchainMeta)\n  )\n    return blockchainMeta.info.transactionUrl;\n  return;\n};\n\nexport const getScannerUrl = (\n  txHash: string,\n  network: Network,\n  blockchainMetaMap: { [key: string]: BlockchainMeta }\n): string | undefined => {\n  const blockchainMeta = blockchainMetaMap[network];\n  const baseUrl = getBlockchainMetaExplorerBaseUrl(blockchainMeta);\n  if (!baseUrl) return;\n  if (baseUrl.indexOf('/{txHash}') !== -1)\n    return baseUrl.replace('{txHash}', txHash?.toLowerCase());\n  return `${baseUrl}/${txHash?.toLowerCase()}`;\n};\n\nexport function getNextStep(\n  swap: PendingSwap,\n  currentStep: PendingSwapStep\n): PendingSwapStep | null {\n  return (\n    swap.steps.find(\n      (step) =>\n        step.status !== 'failed' &&\n        step.status !== 'success' &&\n        step.id !== currentStep.id\n    ) || null\n  );\n}\n\n/**\n * Returns the wallet address, based on the current step of `PendingSwap`.\n */\nexport const getCurrentAddressOf = (\n  swap: PendingSwap,\n  step: PendingSwapStep\n): string => {\n  const result =\n    swap.wallets[step.evmTransaction?.blockChain || ''] ||\n    swap.wallets[step.evmApprovalTransaction?.blockChain || ''] ||\n    swap.wallets[step.tronTransaction?.blockChain || ''] ||\n    swap.wallets[step.tronApprovalTransaction?.blockChain || ''] ||\n    swap.wallets[step.starknetTransaction?.blockChain || ''] ||\n    swap.wallets[step.starknetApprovalTransaction?.blockChain || ''] ||\n    swap.wallets[step.cosmosTransaction?.blockChain || ''] ||\n    swap.wallets[step.solanaTransaction?.blockChain || ''] ||\n    swap.wallets[step.tonTransaction?.blockChain || ''] ||\n    (step.transferTransaction?.fromWalletAddress\n      ? { address: step.transferTransaction?.fromWalletAddress }\n      : null) ||\n    null;\n  if (result == null) throw PrettyError.WalletMissing();\n  return result.address;\n};\n\nexport function getRelatedWallet(\n  swap: PendingSwap,\n  currentStep: PendingSwapStep\n): WalletTypeAndAddress {\n  const walletAddress = getCurrentAddressOf(swap, currentStep);\n  const walletKV =\n    Object.keys(swap.wallets)\n      .map((k) => ({ k, v: swap.wallets[k] }))\n      .find(({ v }) => v.address === walletAddress) || null;\n  const blockchain = walletKV?.k || null;\n  const wallet = walletKV?.v || null;\n\n  const walletType = wallet?.walletType;\n  if (wallet === null)\n    throw PrettyError.AssertionFailed(\n      `Wallet for source ${blockchain} not passed: walletType: ${walletType}`\n    );\n  return wallet;\n}\n\nexport function getRelatedWalletOrNull(\n  swap: PendingSwap,\n  currentStep: PendingSwapStep\n): WalletTypeAndAddress | null {\n  try {\n    return getRelatedWallet(swap, currentStep);\n  } catch (e) {\n    return null;\n  }\n}\n\nexport const getUsdPrice = (\n  blockchain: string,\n  symbol: string,\n  address: string | null,\n  allTokens: Token[]\n): number | null => {\n  const token = allTokens?.find(\n    (t) =>\n      t.blockchain === blockchain &&\n      t.symbol?.toUpperCase() === symbol?.toUpperCase() &&\n      t.address === address\n  );\n  return token?.usdPrice || null;\n};\n\nexport function getUsdFeeOfStep(\n  step: SwapResult,\n  allTokens: Token[]\n): BigNumber {\n  let totalFeeInUsd = new BigNumber(0);\n  for (let i = 0; i < step.fee.length; i++) {\n    const fee = step.fee[i];\n    if (fee.expenseType === 'DECREASE_FROM_OUTPUT') continue;\n\n    const unitPrice = getUsdPrice(\n      fee.asset.blockchain,\n      fee.asset.symbol,\n      fee.asset.address,\n      allTokens\n    );\n    totalFeeInUsd = totalFeeInUsd.plus(\n      new BigNumber(fee.amount).multipliedBy(unitPrice || 0)\n    );\n  }\n\n  return totalFeeInUsd;\n}\n\nexport function calculatePendingSwap(\n  inputAmount: string,\n  bestRoute: BestRouteResponse,\n  wallets: { [p: string]: WalletTypeAndAddress },\n  settings: SwapSavedSettings,\n  validateBalanceOrFee: boolean,\n  meta: MetaResponse | null\n): PendingSwap {\n  const simulationResult = bestRoute.result;\n  if (!simulationResult) throw Error('Simulation result should not be null');\n\n  return {\n    creationTime: new Date().getTime().toString(),\n    finishTime: null,\n    requestId: bestRoute.requestId || '',\n    inputAmount: inputAmount,\n    wallets,\n    status: 'running',\n    isPaused: false,\n    extraMessage: null,\n    extraMessageSeverity: null,\n    extraMessageDetail: null,\n    extraMessageErrorCode: null,\n    networkStatusExtraMessage: null,\n    networkStatusExtraMessageDetail: null,\n    lastNotificationTime: null,\n    settings: settings,\n    simulationResult: simulationResult,\n    validateBalanceOrFee,\n    steps:\n      bestRoute.result?.swaps?.map((swap, index) => {\n        return {\n          id: index + 1,\n\n          // from\n          fromBlockchain: swap.from.blockchain,\n          fromBlockchainLogo: swap.from.blockchainLogo,\n          fromLogo: swap.from.logo,\n          fromSymbol: swap.from.symbol,\n          fromSymbolAddress: swap.from.address,\n          fromDecimals: swap.from.decimals,\n          fromAmountPrecision: swap.fromAmountPrecision,\n          fromAmountMinValue: swap.fromAmountMinValue,\n          fromAmountMaxValue: swap.fromAmountMaxValue,\n          fromAmountRestrictionType: swap.fromAmountRestrictionType,\n\n          // to\n          toBlockchain: swap.to.blockchain,\n          toBlockchainLogo: swap.to.blockchainLogo,\n          toSymbol: swap.to.symbol,\n          toSymbolAddress: swap.to.address,\n          toDecimals: swap.to.decimals,\n          toLogo: swap.to.logo,\n\n          // swapper\n          swapperId: swap.swapperId,\n          swapperLogo: swap.swapperLogo,\n          swapperType: swap.swapperType,\n\n          // output, fee, timing\n          expectedOutputAmountHumanReadable: swap.toAmount,\n          outputAmount: '',\n          feeInUsd: meta\n            ? numberToString(getUsdFeeOfStep(swap, meta?.tokens), null, 8)\n            : null,\n          estimatedTimeInSeconds: swap.estimatedTimeInSeconds || null,\n\n          // status, tracking\n          status: 'created',\n          networkStatus: null,\n          startTransactionTime: new Date().getTime(),\n          externalTransactionId: null,\n          executedTransactionId: null,\n          executedTransactionTime: null,\n          explorerUrl: null,\n          diagnosisUrl: null,\n          trackingCode: null,\n          internalSteps: null,\n\n          // transactions\n          evmTransaction: null,\n          evmApprovalTransaction: null,\n          starknetTransaction: null,\n          starknetApprovalTransaction: null,\n          tronTransaction: null,\n          tronApprovalTransaction: null,\n          cosmosTransaction: null,\n          solanaTransaction: null,\n          transferTransaction: null,\n          tonTransaction: null,\n\n          // front fields\n          hasAlreadyProceededToSign: false,\n        };\n      }) || [],\n  };\n}\n", "import BigNumber from 'bignumber.js';\n\nexport const numberToString = (\n  number: BigNumber | string | null,\n  minDecimals: number | null = null,\n  maxDecimals: number | null = null\n): string => {\n  if (number === null) return '';\n  if (number === '') return '';\n  const n = new BigNumber(number);\n  const roundingMode = 1;\n  let maxI = 1000;\n  for (let i = 0; i < 60; i++) {\n    if (new BigNumber(n.toFixed(i, roundingMode)).eq(n)) {\n      maxI = i;\n      break;\n    }\n  }\n\n  if (n.gte(10000)) return n.toFormat(0, roundingMode);\n  if (n.gte(1000))\n    return n.toFormat(\n      Math.min(\n        maxI,\n        Math.min(maxDecimals || 100, Math.max(minDecimals || 0, 1))\n      ),\n      roundingMode\n    );\n  if (n.gte(100))\n    return n.toFormat(\n      Math.min(\n        maxI,\n        Math.min(maxDecimals || 100, Math.max(minDecimals || 0, 1))\n      ),\n      roundingMode\n    );\n  if (n.gte(1))\n    return n.toFormat(\n      Math.min(\n        maxI,\n        Math.min(maxDecimals || 100, Math.max(minDecimals || 0, 2))\n      ),\n      roundingMode\n    );\n  if (n.gte(0.01))\n    return n.toFormat(\n      Math.min(\n        maxI,\n        Math.min(maxDecimals || 100, Math.max(minDecimals || 0, 4))\n      ),\n      roundingMode\n    );\n  for (let i = minDecimals || 4; i < 17; i++)\n    if (n.gte(Math.pow(10, -i)))\n      return n.toFormat(\n        Math.min(\n          maxI,\n          Math.min(maxDecimals || 100, Math.max(minDecimals || 0, i))\n        ),\n        roundingMode\n      );\n  if (n.isEqualTo(0)) return '0';\n\n  return n.toFormat(\n    Math.min(maxI, Math.min(maxDecimals || 100, Math.max(minDecimals || 0, 8))),\n    roundingMode\n  );\n};\n", "import * as Sentry from '@sentry/browser';\nimport { PendingSwap, PendingSwapStep } from './shared';\nimport { WalletType } from '@rango-dev/wallets-shared';\n\nexport function logRPCError(\n  error: unknown,\n  swap: PendingSwap,\n  currentStep: PendingSwapStep | undefined,\n  walletType: WalletType | undefined\n): void {\n  try {\n    Sentry.captureException(error, {\n      tags: {\n        requestId: swap.requestId,\n        rpc: true,\n        swapper: currentStep?.swapperId || '',\n        walletType: walletType || '',\n      },\n      level: 'warning' as any,\n    });\n  } catch (e) {\n    console.log({ e });\n  }\n}\n", "import { RangoClient } from 'rango-sdk';\nimport { getConfig } from '../configs';\n\nlet rango: RangoClient | undefined = undefined;\n\nexport const httpService = () => {\n  if (rango) return rango;\n  rango = new RangoClient(getConfig('API_KEY'), getConfig('BASE_URL'));\n  return rango;\n};\n", "import mitt from 'mitt';\nimport {\n  MainEvents,\n  RemoveNameField,\n  Route,\n  RouteEvent,\n  RouteEventType,\n  RouteExecutionEvents,\n  EventSeverity,\n  Step,\n  StepEvent,\n  StepEventType,\n  StepExecutionEventStatus,\n  StepExecutionBlockedEventStatus,\n} from '../types';\nimport { PendingSwap, PendingSwapStep } from 'rango-types/lib';\nimport { getCurrentBlockchainOfOrNull } from '../shared';\nimport {\n  getCurrentStepTx,\n  getFailedStep,\n  getLastSuccessfulStep,\n  isApprovalCurrentStepTx,\n} from '../helpers';\n\ntype NotifierParams = {\n  swap: PendingSwap;\n  step: PendingSwapStep | null;\n} & {\n  event: RemoveNameField<StepEvent, 'message' | 'messageSeverity'>;\n};\n\nfunction createSteps(swapSteps: PendingSwapStep[]): Step[] {\n  return swapSteps.map((swapStep) => {\n    const {\n      diagnosisUrl,\n      estimatedTimeInSeconds,\n      explorerUrl,\n      feeInUsd,\n      executedTransactionId,\n      executedTransactionTime,\n      expectedOutputAmountHumanReadable,\n      fromBlockchain,\n      toBlockchain,\n      fromSymbol,\n      toSymbol,\n      fromSymbolAddress,\n      toSymbolAddress,\n      swapperType,\n      swapperId,\n      outputAmount,\n      fromAmountMaxValue,\n      fromAmountMinValue,\n      fromAmountPrecision,\n      fromAmountRestrictionType,\n      fromDecimals,\n      status: stepStatus,\n    } = swapStep;\n\n    const step: Step = {\n      diagnosisUrl,\n      estimatedTimeInSeconds,\n      explorerUrl,\n      feeInUsd,\n      executedTransactionId,\n      executedTransactionTime,\n      expectedOutputAmountHumanReadable,\n      fromBlockchain,\n      toBlockchain,\n      fromSymbol,\n      toSymbol,\n      fromSymbolAddress,\n      toSymbolAddress,\n      swapperName: swapperId,\n      swapperType,\n      outputAmount,\n      fromAmountMaxValue,\n      fromAmountMinValue,\n      fromAmountPrecision,\n      fromAmountRestrictionType,\n      fromDecimals,\n      status: stepStatus,\n      transaction: getCurrentStepTx(swapStep),\n    };\n\n    return step;\n  });\n}\n\nfunction getEventPayload(\n  swap: PendingSwap,\n  type: StepEventType | RouteEventType,\n  swapStep?: PendingSwapStep\n): { route: Route; step: Step } {\n  const {\n    creationTime,\n    finishTime,\n    requestId,\n    inputAmount,\n    status,\n    wallets,\n    steps,\n    settings,\n  } = swap;\n\n  const routeSteps = createSteps(steps);\n  const route: Route = {\n    creationTime,\n    finishTime,\n    requestId,\n    inputAmount,\n    status,\n    wallets,\n    steps: routeSteps,\n    slippage: settings.slippage,\n    infiniteApproval: settings.infiniteApprove,\n  };\n\n  const result: { route: Route; step: Step } = {\n    route,\n    step: routeSteps[routeSteps.length - 1],\n  };\n  if (swapStep) result.step = createSteps([swapStep])[0];\n  else {\n    if (type === 'failed') {\n      const failedStep = getFailedStep(routeSteps);\n      if (failedStep) result.step = failedStep;\n    } else {\n      const lastSuccessfulStep = getLastSuccessfulStep(routeSteps);\n      if (lastSuccessfulStep) result.step = lastSuccessfulStep;\n    }\n  }\n\n  return result;\n}\n\nexport const eventEmitter = mitt<RouteExecutionEvents>();\n\nfunction emitRouteEvent(stepEvent: StepEvent, route: Route) {\n  let routeEvent: RouteEvent | undefined;\n  const { type } = stepEvent;\n  switch (type) {\n    case StepEventType.STARTED:\n      routeEvent = { ...stepEvent, type: RouteEventType.STARTED };\n      break;\n    case StepEventType.FAILED:\n      routeEvent = { ...stepEvent, type: RouteEventType.FAILED };\n      break;\n    case StepEventType.SUCCEEDED:\n      routeEvent = { ...stepEvent, type: RouteEventType.SUCCEEDED };\n      break;\n    default:\n      break;\n  }\n  if (routeEvent)\n    eventEmitter.emit(MainEvents.RouteEvent, { event: routeEvent, route });\n}\n\nfunction emitStepEvent(stepEvent: StepEvent, route: Route, step: Step) {\n  eventEmitter.emit(MainEvents.StepEvent, { event: stepEvent, route, step });\n}\n\nexport function notifier(params: NotifierParams) {\n  const { event } = params;\n  const { type } = event;\n  const { route, step } = getEventPayload(\n    params.swap,\n    type,\n    params.step ?? undefined\n  );\n  const fromAsset = `${step.fromBlockchain}.${step.fromSymbol}`;\n  const toAsset = `${step.toBlockchain}.${step.toSymbol}`;\n  const outputAmount = step.outputAmount ?? '';\n  const currentFromBlockchain = !!params.step\n    ? getCurrentBlockchainOfOrNull(params.swap, params.step)\n    : null;\n  let message = '';\n  let messageSeverity: StepEvent['messageSeverity'] = EventSeverity.INFO;\n\n  switch (type) {\n    case StepEventType.STARTED:\n      message = 'Swap process started';\n      messageSeverity = EventSeverity.SUCCESS;\n      break;\n    case StepEventType.SUCCEEDED:\n      message = `You received ${outputAmount} ${toAsset}, hooray!`;\n      messageSeverity = EventSeverity.SUCCESS;\n      break;\n    case StepEventType.FAILED:\n      message = `Swap failed: ${\n        params.swap?.extraMessage ?? 'Reason is unknown'\n      }`;\n      messageSeverity = EventSeverity.ERROR;\n      break;\n    case StepEventType.TX_EXECUTION:\n      if (event.status === StepExecutionEventStatus.CREATE_TX) {\n        message = 'Please wait while the transaction is created ...';\n        messageSeverity = EventSeverity.INFO;\n      } else if (event.status === StepExecutionEventStatus.SEND_TX) {\n        if (params.step && isApprovalCurrentStepTx(params.step))\n          message = `Please confirm '${step.swapperName}' smart contract access to ${fromAsset}`;\n        else message = 'Please confirm transaction request in your wallet';\n        messageSeverity = EventSeverity.WARNING;\n      } else if (event.status === StepExecutionEventStatus.TX_SENT) {\n        message = 'Transaction sent successfully';\n        messageSeverity = EventSeverity.INFO;\n      }\n      break;\n    case StepEventType.CHECK_STATUS:\n      if (params.step && isApprovalCurrentStepTx(params.step))\n        message = 'Checking approve transacation status ...';\n      else message = 'Checking transacation status ...';\n      messageSeverity = EventSeverity.INFO;\n      break;\n    case StepEventType.APPROVAL_TX_SUCCEEDED:\n      message = 'Smart contract called successfully';\n      messageSeverity = EventSeverity.SUCCESS;\n      break;\n    case StepEventType.OUTPUT_REVEALED:\n      message = 'Transaction output amount revealed';\n      messageSeverity = EventSeverity.SUCCESS;\n      break;\n\n    case StepEventType.TX_EXECUTION_BLOCKED:\n      if (\n        event.status ===\n        StepExecutionBlockedEventStatus.WAITING_FOR_WALLET_CONNECT\n      ) {\n        message = 'Please connect your wallet.';\n        messageSeverity = EventSeverity.WARNING;\n      } else if (\n        event.status === StepExecutionBlockedEventStatus.WAITING_FOR_QUEUE\n      ) {\n        message = 'Waiting for other swaps to complete';\n        messageSeverity = EventSeverity.WARNING;\n      } else if (\n        event.status ===\n        StepExecutionBlockedEventStatus.WAITING_FOR_CHANGE_WALLET_ACCOUNT\n      ) {\n        message = 'Please change your wallet account.';\n        messageSeverity = EventSeverity.WARNING;\n      } else if (\n        event.status ===\n        StepExecutionBlockedEventStatus.WAITING_FOR_NETWORK_CHANGE\n      ) {\n        message = `Please change your wallet network to ${currentFromBlockchain}.`;\n        messageSeverity = EventSeverity.WARNING;\n      }\n      break;\n\n    default:\n      break;\n  }\n\n  if (params.step)\n    emitStepEvent({ ...event, message, messageSeverity }, route, step);\n  else emitRouteEvent({ ...event, message, messageSeverity }, route);\n}\n", "import { ExecuterActions } from '@rango-dev/queue-manager-core';\nimport {\n  delay,\n  getCurrentStep,\n  getCurrentStepTx,\n  getCurrentStepTxType,\n  resetNetworkStatus,\n  setCurrentStepTx,\n  updateSwapStatus,\n  inMemoryTransactionsData,\n} from '../helpers';\nimport {\n  StepEventType,\n  SwapActionTypes,\n  SwapQueueContext,\n  SwapStorage,\n} from '../types';\nimport {\n  getCurrentBlockchainOf,\n  getNextStep,\n  getRelatedWallet,\n  getScannerUrl,\n  MessageSeverity,\n} from '../shared';\nimport { Transaction, TransactionStatusResponse } from 'rango-sdk';\nimport { httpService } from '../services';\nimport type { GenericSigner } from 'rango-types';\nimport { prettifyErrorMessage } from '../shared-errors';\nimport { notifier } from '../services/eventEmitter';\nimport { DEFAULT_ERROR_CODE } from '../constants';\n\nconst INTERVAL_FOR_CHECK = 5_000;\n\n/**\n * Subscribe to status of swap transaction by checking from server periodically.\n * After getting the status, notify the user and schedule `SCHEDULE_NEXT_STEP`.\n */\nasync function checkTransactionStatus({\n  getStorage,\n  setStorage,\n  next,\n  schedule,\n  retry,\n  failed,\n  context,\n}: ExecuterActions<\n  SwapStorage,\n  SwapActionTypes,\n  SwapQueueContext\n>): Promise<void> {\n  const swap = getStorage().swapDetails;\n  const { meta } = context;\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  const currentStep = getCurrentStep(swap)!;\n\n  if (!currentStep?.executedTransactionId) return;\n  const tx = getCurrentStepTx(currentStep);\n  let txId = currentStep.executedTransactionId;\n  let explorerUrlToUpdate = false;\n  let getTxReceiptFailed = false;\n  let status: TransactionStatusResponse | null = null;\n  let signer: GenericSigner<Transaction> | null = null;\n  const { getTransactionDataByHash, setTransactionDataByHash } =\n    inMemoryTransactionsData();\n\n  try {\n    const txType = getCurrentStepTxType(currentStep);\n    const sourceWallet = getRelatedWallet(swap, currentStep);\n    if (txType && sourceWallet)\n      signer = context.getSigners(sourceWallet.walletType).getSigner(txType);\n  } catch (error) {\n    // wallet is not connected yet\n    // no need to do anything\n  }\n\n  try {\n    // if wallet is connected, try to get transaction reciept\n    const { response: txResponse, receiptReceived } =\n      getTransactionDataByHash(txId);\n    if (signer?.wait && !receiptReceived) {\n      const chainId =\n        (tx?.blockChain && meta.blockchains?.[tx?.blockChain]?.chainId) ||\n        undefined;\n      const { hash: updatedTxHash, response: updatedTxResponse } =\n        await signer.wait(txId, chainId, txResponse);\n      if (updatedTxResponse?.isMultiSig) {\n        explorerUrlToUpdate = !updatedTxResponse.hashWasUpdated;\n      }\n      if (updatedTxHash !== txId) {\n        currentStep.executedTransactionId =\n          updatedTxHash || currentStep.executedTransactionId;\n        const currentStepBlockchain = getCurrentBlockchainOf(swap, currentStep);\n        let explorerUrl: string | undefined;\n        const blockchainsMetaNotEmpty = !!Object.keys(meta.blockchains).length;\n        if (blockchainsMetaNotEmpty) {\n          explorerUrl = getScannerUrl(\n            currentStep.executedTransactionId,\n            currentStepBlockchain,\n            meta.blockchains\n          );\n        }\n        if (explorerUrl) {\n          if (currentStep.explorerUrl && currentStep.explorerUrl?.length >= 1) {\n            currentStep.explorerUrl[currentStep.explorerUrl.length - 1] = {\n              url: explorerUrl,\n              description: 'Replaced Swap',\n            };\n          }\n        }\n        txId = currentStep.executedTransactionId;\n        if (updatedTxHash && updatedTxResponse)\n          setTransactionDataByHash(updatedTxHash, {\n            response: updatedTxResponse,\n          });\n      } else {\n        setTransactionDataByHash(updatedTxHash, {\n          receiptReceived: true,\n        });\n      }\n    } else if (!signer) {\n      explorerUrlToUpdate = true;\n    }\n  } catch (error) {\n    const { extraMessage, extraMessageDetail, extraMessageErrorCode } =\n      prettifyErrorMessage(error);\n    const updateResult = updateSwapStatus({\n      getStorage,\n      setStorage,\n      nextStatus: 'failed',\n      nextStepStatus: 'failed',\n      message: extraMessage,\n      details: extraMessageDetail,\n      errorCode: extraMessageErrorCode,\n    });\n\n    notifier({\n      event: {\n        type: StepEventType.FAILED,\n        reason: extraMessage,\n        reasonCode: updateResult.failureType ?? DEFAULT_ERROR_CODE,\n      },\n      ...updateResult,\n    });\n\n    getTxReceiptFailed = true;\n    // We shouldn't return here, because we need to trigger check status job in backend.\n    // This is not a ui requirement but the backend one.\n  }\n\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    status = await httpService().checkStatus({\n      requestId: swap.requestId,\n      txId,\n      step: currentStep.id,\n    });\n  } catch (e) {\n    await delay(INTERVAL_FOR_CHECK);\n    retry();\n    return;\n  }\n\n  // If user cancel swap during check status api call,\n  // or getting transaction receipt failed,\n  // we should ignore check status response and return\n  if (getTxReceiptFailed) return failed();\n  if (currentStep?.status === 'failed') return;\n\n  const outputAmount: string | null =\n    status?.outputAmount ||\n    (currentStep.outputAmount ? currentStep.outputAmount : null);\n  const prevOutputAmount = currentStep.outputAmount || null;\n  swap.extraMessage = status?.extraMessage || swap.extraMessage;\n  swap.extraMessageSeverity = MessageSeverity.info;\n  swap.extraMessageDetail = '';\n\n  currentStep.status = status?.status || currentStep.status;\n  currentStep.diagnosisUrl =\n    status?.diagnosisUrl || currentStep.diagnosisUrl || null;\n  currentStep.outputAmount = outputAmount || currentStep.outputAmount;\n  currentStep.explorerUrl = !explorerUrlToUpdate\n    ? status?.explorerUrl || currentStep.explorerUrl\n    : null;\n  currentStep.internalSteps = status?.steps || null;\n\n  const newTransaction = status?.newTx;\n\n  if (newTransaction) {\n    currentStep.status = 'created';\n    currentStep.executedTransactionId = null;\n    currentStep.executedTransactionTime = null;\n    setCurrentStepTx(currentStep, newTransaction);\n  }\n\n  if (prevOutputAmount === null && outputAmount !== null)\n    notifier({\n      event: { type: StepEventType.OUTPUT_REVEALED, outputAmount },\n      swap: swap,\n      step: currentStep,\n    });\n  else if (prevOutputAmount === null && outputAmount === null) {\n    // it is needed to set notification after reloading the page\n    notifier({\n      event: { type: StepEventType.CHECK_STATUS },\n      swap: swap,\n      step: currentStep,\n    });\n  }\n\n  if (currentStep.status === 'success') {\n    const nextStep = getNextStep(swap, currentStep);\n    swap.extraMessageDetail = '';\n    swap.extraMessage = nextStep\n      ? `starting next step: ${nextStep.swapperId}: ${nextStep.fromBlockchain} -> ${nextStep.toBlockchain}`\n      : '';\n    notifier({\n      event: {\n        type: StepEventType.SUCCEEDED,\n        outputAmount: currentStep.outputAmount ?? '',\n      },\n      swap,\n      step: currentStep,\n    });\n  } else if (currentStep.status === 'failed') {\n    swap.extraMessage = 'Transaction failed in blockchain';\n    swap.extraMessageSeverity = MessageSeverity.error;\n    swap.extraMessageDetail = status?.extraMessage || '';\n    swap.status = 'failed';\n    swap.finishTime = new Date().getTime().toString();\n  }\n\n  // Sync data with storage\n  setStorage({ ...getStorage(), swapDetails: swap });\n\n  if (status?.status === 'failed') {\n    failed();\n  } else if (\n    status?.status === 'success' ||\n    (status?.status === 'running' && !!status.newTx)\n  ) {\n    schedule(SwapActionTypes.SCHEDULE_NEXT_STEP);\n    next();\n  } else {\n    await delay(INTERVAL_FOR_CHECK);\n    retry();\n  }\n}\n\n/**\n * Subscribe to status of approval transaction by checking from server periodically.\n * After getting the status, notify the user and schedule `SCHEDULE_NEXT_STEP`.\n */\nasync function checkApprovalStatus({\n  getStorage,\n  setStorage,\n  next,\n  schedule,\n  retry,\n  failed,\n  context,\n}: ExecuterActions<\n  SwapStorage,\n  SwapActionTypes,\n  SwapQueueContext\n>): Promise<void> {\n  const swap = getStorage().swapDetails as SwapStorage['swapDetails'];\n  const { meta } = context;\n  const { getTransactionDataByHash, setTransactionDataByHash } =\n    inMemoryTransactionsData();\n\n  const currentStep = getCurrentStep(swap);\n  if (!currentStep) {\n    console.log('ignore check status, current step is null');\n    return;\n  }\n  const tx = getCurrentStepTx(currentStep);\n\n  if (!currentStep?.executedTransactionId) return;\n  let txId = currentStep.executedTransactionId;\n\n  let signer: GenericSigner<Transaction> | null = null;\n  try {\n    const txType = getCurrentStepTxType(currentStep);\n    const sourceWallet = getRelatedWallet(swap, currentStep);\n    if (txType && sourceWallet)\n      signer = context.getSigners(sourceWallet.walletType).getSigner(txType);\n  } catch (error) {\n    // wallet is not connected yet\n    // no need to do anything\n  }\n\n  try {\n    const { response: txResponse, receiptReceived } =\n      getTransactionDataByHash(txId);\n    // if wallet is connected, try to get transaction reciept\n    if (signer?.wait && !receiptReceived) {\n      const chainId =\n        (tx?.blockChain && meta.blockchains?.[tx?.blockChain]?.chainId) ||\n        undefined;\n      const { hash: updatedTxHash, response: updatedTxResponse } =\n        await signer.wait(txId, chainId, txResponse);\n      if (updatedTxHash !== txId) {\n        currentStep.executedTransactionId =\n          updatedTxHash || currentStep.executedTransactionId;\n        const currentStepBlockchain = getCurrentBlockchainOf(swap, currentStep);\n        let explorerUrl: string | undefined;\n        const blockchainsMetaNotEmpty = !!Object.keys(meta.blockchains).length;\n        if (blockchainsMetaNotEmpty) {\n          explorerUrl = getScannerUrl(\n            currentStep.executedTransactionId,\n            currentStepBlockchain,\n            meta.blockchains\n          );\n        }\n        if (explorerUrl) {\n          if (currentStep.explorerUrl && currentStep.explorerUrl?.length >= 1) {\n            currentStep.explorerUrl[currentStep.explorerUrl.length - 1] = {\n              url: explorerUrl,\n              description: 'Replaced Approve',\n            };\n          }\n        }\n        txId = currentStep.executedTransactionId;\n        if (updatedTxHash && updatedTxResponse)\n          setTransactionDataByHash(updatedTxHash, {\n            response: updatedTxResponse,\n          });\n      } else {\n        setTransactionDataByHash(updatedTxHash, {\n          receiptReceived: true,\n        });\n      }\n    }\n  } catch (error) {\n    const { extraMessage, extraMessageDetail, extraMessageErrorCode } =\n      prettifyErrorMessage(error);\n    const updateResult = updateSwapStatus({\n      getStorage,\n      setStorage,\n      nextStatus: 'failed',\n      nextStepStatus: 'failed',\n      message: extraMessage,\n      details: extraMessageDetail,\n      errorCode: extraMessageErrorCode,\n    });\n    notifier({\n      event: {\n        type: StepEventType.FAILED,\n        reason: extraMessage,\n        reasonCode: updateResult.failureType ?? DEFAULT_ERROR_CODE,\n      },\n      ...updateResult,\n    });\n    return failed();\n  }\n\n  let isApproved = false;\n  try {\n    const response = await httpService().checkApproval(\n      swap.requestId,\n      currentStep.executedTransactionId\n    );\n    // If user cancel swap during check status api call, we should ignore check approval response\n    if (currentStep?.status === 'failed') return;\n\n    isApproved = response.isApproved;\n    if (\n      !isApproved &&\n      (response.txStatus === 'failed' || response.txStatus === 'success')\n    ) {\n      let message, details;\n      if (response.txStatus === 'failed') {\n        message = 'Approve transaction failed';\n        details = 'Smart contract approval tx failed in blockchain.';\n      } else {\n        message = 'Not enough approval';\n        if (response.requiredApprovedAmount && response.currentApprovedAmount)\n          details = `Required approval: ${response.requiredApprovedAmount}, current approval: ${response.currentApprovedAmount}`;\n        else details = `You still don't have enough approval for this swap.`;\n      }\n      // approve transaction failed on\n      // we should fail the whole swap\n      const updateResult = updateSwapStatus({\n        getStorage,\n        setStorage,\n        nextStatus: 'failed',\n        nextStepStatus: 'failed',\n        errorCode: 'INSUFFICIENT_APPROVE',\n        message: message,\n        details: details,\n      });\n\n      notifier({\n        event: {\n          type: StepEventType.FAILED,\n          reason: message,\n          reasonCode: updateResult.failureType ?? DEFAULT_ERROR_CODE,\n        },\n        ...updateResult,\n      });\n\n      failed();\n    } else if (!isApproved) {\n      // it is needed to set notification after reloading the page\n      notifier({\n        event: { type: StepEventType.CHECK_STATUS },\n        swap,\n        step: currentStep,\n      });\n    }\n  } catch (e) {\n    isApproved = false;\n  }\n  if (isApproved) {\n    currentStep.status = 'approved';\n    swap.extraMessage = `Spending ${currentStep.fromSymbol} approved successfully.`;\n    swap.extraMessageDetail = null;\n    swap.extraMessageSeverity = MessageSeverity.success;\n    currentStep.evmApprovalTransaction = null;\n    currentStep.executedTransactionId = null;\n    currentStep.executedTransactionTime = null;\n    currentStep.starknetApprovalTransaction = null;\n    currentStep.tronApprovalTransaction = null;\n\n    setStorage({\n      ...getStorage(),\n      swapDetails: swap,\n    });\n\n    notifier({\n      event: { type: StepEventType.APPROVAL_TX_SUCCEEDED },\n      swap: swap,\n      step: currentStep,\n    });\n\n    schedule(SwapActionTypes.SCHEDULE_NEXT_STEP);\n    next();\n  } else {\n    await delay(2000);\n    retry();\n  }\n}\n\n/**\n *\n * For doing a swap the user needs to accept a `contract` so it can use the user balance.\n * There is two types of check status:\n *  1. Checking approval transaction (Give permission to a contract)\n *  2. Checking swap transaction.\n *\n */\nexport async function checkStatus(\n  actions: ExecuterActions<SwapStorage, SwapActionTypes, SwapQueueContext>\n): Promise<void> {\n  const swap = actions.getStorage().swapDetails;\n  const currentStep = getCurrentStep(swap);\n  if (!currentStep) {\n    console.log('ignore check status, current step is null', swap.requestId);\n    return;\n  }\n\n  // Reset network status\n  // Because when check status is on `loading` or `failed` status, it shows previous message that isn't related to current state.\n  resetNetworkStatus(actions);\n\n  if (currentStep.status === 'running') {\n    await checkTransactionStatus(actions);\n  } else if (currentStep.status === 'waitingForApproval') {\n    await checkApprovalStatus(actions);\n  }\n}\n", "import { ExecuterActions } from '@rango-dev/queue-manager-core';\nimport {\n  StepEventType,\n  SwapActionTypes,\n  SwapQueueContext,\n  SwapStorage,\n  StepExecutionEventStatus,\n} from '../types';\nimport {\n  getCurrentStep,\n  updateSwapStatus,\n  throwOnOK,\n  getCurrentStepTx,\n  setCurrentStepTx,\n} from '../helpers';\nimport { prettifyErrorMessage } from '../shared-errors';\nimport { CreateTransactionRequest } from 'rango-sdk';\nimport { httpService } from '../services';\nimport { notifier } from '../services/eventEmitter';\nimport { DEFAULT_ERROR_CODE } from '../constants';\n\n/**\n *\n * When a user asks for a swap, We first create the transaction by sending a request to server\n * Server will return the transaction that need to be sent to wallet.\n * It can be failed if server goes through an error, If not, we will schedule the `EXECTUTE_TRANSACTION`.\n *\n */\nexport async function createTransaction(\n  actions: ExecuterActions<SwapStorage, SwapActionTypes, SwapQueueContext>\n): Promise<void> {\n  const { setStorage, getStorage, next, schedule } = actions;\n  const swap = getStorage().swapDetails;\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  const currentStep = getCurrentStep(swap)!;\n  const transaction = getCurrentStepTx(currentStep);\n\n  if (!transaction) {\n    notifier({\n      event: {\n        type: StepEventType.TX_EXECUTION,\n        status: StepExecutionEventStatus.CREATE_TX,\n      },\n      swap,\n      step: currentStep,\n    });\n    const request: CreateTransactionRequest = {\n      requestId: swap.requestId,\n      step: currentStep.id,\n      userSettings: {\n        slippage: swap.settings.slippage,\n        infiniteApprove: swap.settings.infiniteApprove,\n      },\n      validations: {\n        balance: swap.validateBalanceOrFee,\n        fee: swap.validateBalanceOrFee,\n      },\n    };\n    try {\n      // Getting transcation from server.\n\n      const { transaction } = await throwOnOK(\n        httpService().createTransaction(request)\n      );\n\n      if (transaction) setCurrentStepTx(currentStep, transaction);\n\n      setStorage({ ...getStorage(), swapDetails: swap });\n      schedule(SwapActionTypes.EXECUTE_TRANSACTION);\n      next();\n    } catch (error) {\n      swap.status = 'failed';\n      swap.finishTime = new Date().getTime().toString();\n      const { extraMessage, extraMessageDetail } = prettifyErrorMessage(error);\n\n      const updateResult = updateSwapStatus({\n        getStorage,\n        setStorage,\n        nextStatus: 'failed',\n        nextStepStatus: 'failed',\n        message: extraMessage,\n        details: extraMessageDetail,\n        errorCode: 'FETCH_TX_FAILED',\n      });\n\n      notifier({\n        event: {\n          type: StepEventType.FAILED,\n          reason: extraMessage,\n          reasonCode: updateResult.failureType ?? DEFAULT_ERROR_CODE,\n        },\n        ...updateResult,\n      });\n\n      actions.failed();\n    }\n  }\n}\n", "import { ExecuterActions } from '@rango-dev/queue-manager-core';\nimport {\n  ERROR_MESSAGE_DEPENDS_ON_OTHER_QUEUES,\n  ERROR_MESSAGE_WAIT_FOR_CHANGE_NETWORK,\n  ERROR_MESSAGE_WAIT_FOR_WALLET_DESCRIPTION,\n  ERROR_MESSAGE_WAIT_FOR_WALLET_DESCRIPTION_WRONG_WALLET,\n} from '../constants';\n\nimport {\n  getCurrentStep,\n  isNetworkMatchedForTransaction,\n  isRequiredWalletConnected,\n  updateNetworkStatus,\n  singTransaction,\n  resetNetworkStatus,\n  getRequiredWallet,\n  isNeedBlockQueueForParallel,\n  claimQueue,\n} from '../helpers';\nimport { getCurrentBlockchainOf, PendingSwapNetworkStatus } from '../shared';\nimport {\n  BlockReason,\n  SwapActionTypes,\n  SwapQueueContext,\n  SwapStorage,\n} from '../types';\n\n/**\n * Excecute a created transaction.\n *\n * This function implemented the parallel mode by `claim` mechanism which means\n * All the queues the meet certain situation (like multiple evm transaction) will go through\n * a `claim` mechanims that decides which queue should be run and it blocks other ones.\n *\n * A queue will be go to sign process, if the wallet and network is matched.\n */\nexport async function executeTransaction(\n  actions: ExecuterActions<SwapStorage, SwapActionTypes, SwapQueueContext>\n): Promise<void> {\n  const { getStorage, context } = actions;\n  const { meta, wallets, providers } = context;\n  const { claimedBy } = claimQueue();\n\n  const isClaimed = context.claimedBy === context._queue?.id;\n  const requestBlock: typeof actions.block = (blockedFor) => {\n    actions.block(blockedFor);\n    if (isClaimed && actions.context.resetClaimedBy) {\n      actions.context.resetClaimedBy();\n    }\n  };\n\n  const swap = getStorage().swapDetails;\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  const currentStep = getCurrentStep(swap)!;\n\n  // Resetting network status, so we will set it again during the running of this task.\n  resetNetworkStatus(actions);\n\n  /* Make sure wallet is connected and also the connected wallet is matched with tx by checking address. */\n  const isWrongAddress = !isRequiredWalletConnected(swap, context.state).ok;\n  if (isWrongAddress) {\n    const { type, address } = getRequiredWallet(swap);\n    const isWalletInCompatible = wallets?.blockchains?.find(\n      (w) => !w.accounts?.find((account) => account.walletType === type)\n    );\n    const description =\n      !wallets || isWalletInCompatible\n        ? ERROR_MESSAGE_WAIT_FOR_WALLET_DESCRIPTION(type)\n        : ERROR_MESSAGE_WAIT_FOR_WALLET_DESCRIPTION_WRONG_WALLET(type, address);\n\n    const blockedFor = {\n      reason: BlockReason.WAIT_FOR_CONNECT_WALLET,\n      description,\n    };\n    requestBlock(blockedFor);\n    return;\n  }\n\n  /* Wallet should be on correct network */\n  const networkMatched = await isNetworkMatchedForTransaction(\n    swap,\n    currentStep,\n    wallets,\n    meta,\n    providers\n  );\n  const claimerId = claimedBy();\n  const isClaimedByAnyQueue = !!claimerId && !isClaimed;\n  if (isClaimedByAnyQueue && !networkMatched) {\n    const details = ERROR_MESSAGE_DEPENDS_ON_OTHER_QUEUES;\n\n    const blockedFor = {\n      reason: BlockReason.DEPENDS_ON_OTHER_QUEUES,\n      details: details,\n    };\n    requestBlock(blockedFor);\n    return;\n  } else if (!networkMatched) {\n    const fromBlockchain = getCurrentBlockchainOf(swap, currentStep);\n    const details = ERROR_MESSAGE_WAIT_FOR_CHANGE_NETWORK(fromBlockchain);\n\n    const blockedFor = {\n      reason: BlockReason.WAIT_FOR_NETWORK_CHANGE,\n      details: details,\n    };\n    requestBlock(blockedFor);\n    return;\n  } else {\n    // Update network to mark it as network changed successfully.\n    updateNetworkStatus(actions, {\n      message: '',\n      details: 'Wallet network changed successfully',\n      status: PendingSwapNetworkStatus.NetworkChanged,\n    });\n  }\n\n  /* \n  For avoiding conflict by making too many requests to wallet, we need to make sure\n  We only run one request at a time (In parallel mode).\n  */\n  const needsToBlockQueue = isNeedBlockQueueForParallel(currentStep);\n\n  if (needsToBlockQueue && !isClaimed) {\n    const blockedFor = {\n      reason: BlockReason.DEPENDS_ON_OTHER_QUEUES,\n      description: ERROR_MESSAGE_DEPENDS_ON_OTHER_QUEUES,\n      details: {},\n    };\n    requestBlock(blockedFor);\n    return;\n  }\n\n  // All the conditions are met. We can safely send the tx to wallet for sign.\n  singTransaction(actions);\n}\n", "import { ExecuterActions } from '@rango-dev/queue-manager-core';\nimport {\n  StepEventType,\n  SwapActionTypes,\n  SwapQueueContext,\n  SwapStorage,\n} from '../types';\nimport {\n  getCurrentStep,\n  getLastSuccessfulStep,\n  isTxAlreadyCreated,\n} from '../helpers';\nimport { notifier } from '../services/eventEmitter';\n\n/**\n *\n * This function is responsibe for scheduling the correct `action` based on `PendingSwap` status.\n * It means `action`s schedule this step to decide what should be the next step/task.\n *\n * It's acts like a `while(true)` and will `break` the loop on certain `action`s like `CHECK_STATUS`.\n *\n *\n */\nexport function scheduleNextStep({\n  schedule,\n  next,\n  failed,\n  setStorage,\n  getStorage,\n}: ExecuterActions<SwapStorage, SwapActionTypes, SwapQueueContext>): void {\n  const swap = getStorage().swapDetails;\n  const currentStep = getCurrentStep(swap);\n  const isFailed = swap.steps.find((step) => step.status === 'failed');\n\n  if (!!currentStep && !isFailed) {\n    if (isTxAlreadyCreated(swap, currentStep)) {\n      schedule(SwapActionTypes.EXECUTE_TRANSACTION);\n      return next();\n    }\n\n    if (currentStep?.executedTransactionId) {\n      schedule(SwapActionTypes.CHECK_TRANSACTION_STATUS);\n      return next();\n    }\n\n    swap.status = 'running';\n\n    setStorage({ ...getStorage(), swapDetails: swap });\n\n    notifier({\n      event: { type: StepEventType.STARTED },\n      swap,\n      step: currentStep,\n    });\n\n    schedule(SwapActionTypes.CREATE_TRANSACTION);\n    next();\n  } else {\n    swap.status = isFailed ? 'failed' : 'success';\n    swap.finishTime = new Date().getTime().toString();\n\n    setStorage({\n      ...getStorage(),\n      swapDetails: swap,\n    });\n\n    notifier({\n      ...(isFailed\n        ? {\n            event: {\n              type: StepEventType.FAILED,\n              reason: swap.extraMessage ?? undefined,\n              reasonCode: 'CALL_OR_SEND_FAILED',\n            },\n          }\n        : {\n            event: {\n              type: StepEventType.SUCCEEDED,\n              outputAmount:\n                getLastSuccessfulStep(swap.steps)?.outputAmount ?? '',\n            },\n          }),\n      swap: swap,\n      step: null,\n    });\n\n    if (isFailed) failed();\n    else next();\n  }\n}\n", "import { ExecuterActions } from '@rango-dev/queue-manager-core';\nimport { StepEventType, SwapActionTypes, SwapStorage } from '../types';\nimport { notifier } from '../services/eventEmitter';\n\nexport function start({\n  schedule,\n  next,\n  getStorage,\n}: ExecuterActions<SwapStorage, SwapActionTypes>): void {\n  const swap = getStorage().swapDetails;\n\n  notifier({ event: { type: StepEventType.STARTED }, swap, step: null });\n\n  schedule(SwapActionTypes.SCHEDULE_NEXT_STEP);\n  next();\n}\n", "import { BlockReason, SwapActionTypes, SwapQueueDef } from './types';\nimport { checkStatus } from './actions/checkStatus';\nimport { createTransaction } from './actions/createTransaction';\nimport { executeTransaction } from './actions/executeTransaction';\nimport { scheduleNextStep } from './actions/scheduleNextStep';\nimport { start } from './actions/start';\nimport {\n  onBlockForChangeNetwork,\n  onBlockForConnectWallet,\n  onDependsOnOtherQueues,\n} from './helpers';\n\n/**\n *\n * The idea behind this queue is to be able dynamically add some steps.\n * After running a swap, it can be blocked (like on waiting for switch netwrok)\n *  or waits for something happend (like checking status of a transaction from server)\n *\n */\nexport const swapQueueDef: SwapQueueDef = {\n  name: 'swap',\n  actions: {\n    [SwapActionTypes.START]: start,\n    [SwapActionTypes.SCHEDULE_NEXT_STEP]: scheduleNextStep,\n    [SwapActionTypes.CREATE_TRANSACTION]: createTransaction,\n    [SwapActionTypes.EXECUTE_TRANSACTION]: executeTransaction,\n    [SwapActionTypes.CHECK_TRANSACTION_STATUS]: checkStatus,\n  },\n  run: [SwapActionTypes.START],\n  whenTaskBlocked: (event, meta) => {\n    if (event.reason.reason === BlockReason.WAIT_FOR_CONNECT_WALLET) {\n      onBlockForConnectWallet(event, meta);\n    } else if (event.reason.reason === BlockReason.WAIT_FOR_NETWORK_CHANGE) {\n      onBlockForChangeNetwork(event, meta);\n    } else if (event.reason.reason === BlockReason.DEPENDS_ON_OTHER_QUEUES) {\n      onDependsOnOtherQueues(event, meta);\n    }\n  },\n};\n", "import { useManager } from '@rango-dev/queue-manager-react';\nimport { useEffect, useState } from 'react';\nimport {\n  checkWaitingForConnectWalletChange,\n  checkWaitingForNetworkChange,\n  retryOn,\n} from './helpers';\nimport { migrated, migration } from './migration';\nimport { UseQueueManagerParams } from './types';\nimport { eventEmitter } from './services/eventEmitter';\n\nlet isCalled = 0;\n\n/**\n *\n * Runs a migration (old swaps from localstorage to queue manager's IndexedDB)\n * It will be run only once on page load.\n *\n */\nfunction useMigration(): {\n  status: boolean;\n} {\n  const isMigrated = migrated();\n  const [status, setStatus] = useState<boolean>(isMigrated);\n\n  useEffect(() => {\n    (async () => {\n      // Preventing react to be called twice on Strict Mode (development)\n      if (isCalled) return;\n      isCalled = 1;\n\n      migration().finally(() => {\n        setStatus(true);\n      });\n    })();\n  }, []);\n\n  return {\n    status,\n  };\n}\n\n/**\n *\n * On initial load and also connect/disconnet we may need to update swap's notified message.\n * And also if a new wallet is connected we will retry the queue to see we can resume it or not.\n *\n */\nfunction useQueueManager(params: UseQueueManagerParams): void {\n  const { manager } = useManager();\n\n  useEffect(() => {\n    if (params.lastConnectedWallet) {\n      checkWaitingForConnectWalletChange({\n        evmChains: params.evmChains,\n        wallet_network: params.lastConnectedWallet,\n        manager,\n      });\n      retryOn(params.lastConnectedWallet, manager, params.canSwitchNetworkTo);\n    }\n  }, [params.lastConnectedWallet]);\n\n  useEffect(() => {\n    if (params.disconnectedWallet) {\n      checkWaitingForNetworkChange(manager);\n\n      /* \n        We need to reset the state value, so if a wallet disconnected twice (after reconnect),\n        this effect will be run properly.\n      */\n      params.clearDisconnectedWallet();\n    }\n  }, [params.disconnectedWallet]);\n}\n\nfunction useEvents() {\n  return eventEmitter;\n}\n\nexport { useQueueManager, useMigration, useEvents };\n", "import {\n  PersistedQueue,\n  Persistor,\n  Status,\n  DB_NAME,\n} from '@rango-dev/queue-manager-core';\nimport { v4 as uuid } from 'uuid';\nimport { PendingSwap } from './shared';\nimport { SwapActionTypes } from './types';\n\nconst MIGRATED_KEY = 'migratedToQueueManager';\n\n/**\n *\n * If `MIGRATED_KEY` is set, it means we already migrated data from localstorage.\n *\n */\nfunction migrated(): boolean {\n  return !!window.localStorage.getItem(MIGRATED_KEY);\n}\n\nasync function hasQueueManagerOnIDB(): Promise<boolean> {\n  try {\n    return (await (window.indexedDB as any).databases())\n      .map((db: any) => db.name)\n      .includes(DB_NAME);\n  } catch {\n    return false;\n  }\n}\n\n/**\n *\n * By calling this function, we first check if the data already migrated or not,\n * If not, starting to migrating to IndexedDb with proper format that queue manager is understand.\n *\n */\nasync function migration(): Promise<boolean> {\n  const swapsFromStorage = window.localStorage.getItem('pendingSwaps');\n  const hasIndexDB = await hasQueueManagerOnIDB();\n\n  // For new users or already migrated.\n  if (!swapsFromStorage || migrated() || hasIndexDB) {\n    return true;\n  }\n\n  // For old users, but they didn't do any swaps yet.\n  const swaps: PendingSwap[] = JSON.parse(swapsFromStorage);\n  const convertedSwaps: PersistedQueue[] = [];\n\n  swaps.forEach((swap) => {\n    /* \n      For running task we need to add some more work\n      We need to create a queue task to be run and resume the running task from queue manager.\n     */\n    if (swap.status === 'running') {\n      const taskId = uuid();\n\n      const convertedSwap: PersistedQueue = {\n        id: swap.requestId,\n        createdAt: Number(swap.creationTime),\n        name: 'swap',\n        status: Status.RUNNING,\n        storage: {\n          swapDetails: swap,\n        },\n        state: {\n          status: Status.RUNNING,\n          activeTaskIndex: 0,\n          tasks: {\n            [taskId]: {\n              blockedFor: null,\n              status: Status.RUNNING,\n            },\n          },\n        },\n        tasks: [\n          {\n            id: taskId,\n            action: SwapActionTypes.SCHEDULE_NEXT_STEP,\n          },\n        ],\n      };\n      convertedSwaps.push(convertedSwap);\n    } else {\n      /*\n       * For failed or successful swaps, we only move it to IndexedDB,\n       * And there is no need to consider them to be run.\n       */\n      const status = swap.status === 'success' ? Status.SUCCESS : Status.FAILED;\n\n      const convertedSwap: PersistedQueue = {\n        id: swap.requestId,\n        createdAt: Number(swap.creationTime),\n        name: 'swap',\n        status,\n        storage: {\n          swapDetails: swap,\n        },\n        state: {\n          status,\n          activeTaskIndex: 0,\n          tasks: {},\n        },\n        tasks: [],\n      };\n\n      convertedSwaps.push(convertedSwap);\n    }\n  });\n\n  // Getting an instance from persistor, so we can directly put our data inside it.\n  const persistor = new Persistor();\n\n  const promises = convertedSwaps.map((queue) => persistor.insertQueue(queue));\n  await Promise.all(promises);\n\n  // Mark as the data has been successfully migrated.\n  window.localStorage.setItem(MIGRATED_KEY, '1');\n\n  return true;\n}\n\nexport { migration, migrated };\n", "import type { Configs } from './configs';\nimport type { SwapQueueDef } from './types';\n\nimport { initConfig } from './configs';\nimport { swapQueueDef } from './queueDef';\n\nexport { PrettyError, prettifyErrorMessage } from './shared-errors';\nexport type {\n  SwapQueueContext,\n  SwapStorage,\n  RouteExecutionEvents,\n  Route,\n  Step,\n  RouteEvent,\n  StepEvent,\n  EventSeverity,\n  RouteStartedEvent,\n  RouteSucceededEvent,\n  RouteFailedEvent,\n  StepStartedEvent,\n  StepSucceededEvent,\n  StepFailedEvent,\n  StepTxExecutionUpdatedEvent,\n  StepTxExecutionBlockedEvent,\n  StepCheckStatusEvent,\n  StepApprovalTxSucceededEvent,\n  StepOutputRevealedEvent,\n} from './types';\nexport {\n  MainEvents,\n  StepEventType,\n  RouteEventType,\n  StepExecutionEventStatus,\n  StepExecutionBlockedEventStatus,\n} from './types';\nexport type {\n  PendingSwapWithQueueID,\n  PendingSwapStep,\n  PendingSwap,\n  EventType,\n} from './shared';\nexport {\n  getCurrentBlockchainOfOrNull,\n  getRelatedWalletOrNull,\n  getRelatedWallet,\n  MessageSeverity,\n  PendingSwapNetworkStatus,\n  calculatePendingSwap,\n} from './shared';\nexport {\n  updateSwapStatus,\n  checkWaitingForNetworkChange,\n  getCurrentStep,\n  getEvmProvider,\n  cancelSwap,\n  getRequiredWallet,\n  getRunningSwaps,\n  splitWalletNetwork,\n  resetRunningSwapNotifsOnPageLoad,\n  isApprovalTX,\n  getLastSuccessfulStep,\n} from './helpers';\nexport { useMigration, useQueueManager, useEvents } from './hooks';\n\nexport function makeQueueDefinition(configs: Configs): SwapQueueDef {\n  initConfig(configs);\n  return swapQueueDef;\n}\n"],
  "mappings": "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",
  "names": ["RANGO_PUBLIC_API_KEY", "configs", "getConfig", "name", "__name", "initConfig", "nextConfigs", "clonedConfigs", "configs", "__name", "MainEvents", "RouteEventType", "StepExecutionEventStatus", "StepExecutionBlockedEventStatus", "StepEventType", "getBlockChainNameFromId", "Networks", "readAccountAddress", "TransactionType", "ERROR_MESSAGE_DEPENDS_ON_OTHER_QUEUES", "ERROR_MESSAGE_WAIT_FOR_WALLET", "ERROR_MESSAGE_WAIT_FOR_WALLET_DESCRIPTION_WRONG_WALLET", "__name", "type", "address", "ERROR_MESSAGE_WAIT_FOR_WALLET_DESCRIPTION", "ERROR_MESSAGE_WAIT_FOR_CHANGE_NETWORK", "network", "DEFAULT_ERROR_CODE", "Status", "SignerErrorCode", "SignerError", "isSignerErrorCode", "isAPIErrorCode", "ERROR_ASSERTION_FAILED", "ERROR_CREATE_TRANSACTION", "ERROR_INPUT_WALLET_NOT_FOUND", "PrettyError", "code", "m", "root", "detail", "obj", "rawMessage", "rootStr", "message", "statusCode", "__name", "mapAppErrorCodesToAPIErrorCode", "errorCode", "isAPIErrorCode", "isSignerErrorCode", "SignerErrorCode", "DEFAULT_ERROR_CODE", "prettifyErrorMessage", "SignerError", "BigNumber", "BigNumber", "numberToString", "__name", "number", "minDecimals", "maxDecimals", "n", "BigNumber", "roundingMode", "maxI", "i", "isCosmosBlockchain", "isEvmBlockchain", "isStarknetBlockchain", "isTronBlockchain", "PendingSwapNetworkStatus", "MessageSeverity", "getCurrentBlockchainOfOrNull", "__name", "swap", "step", "getCurrentBlockchainOf", "b1", "transferAddress", "PrettyError", "blockchain", "b", "getBlockchainMetaExplorerBaseUrl", "blockchainMeta", "isCosmosBlockchain", "isEvmBlockchain", "isStarknetBlockchain", "isTronBlockchain", "getScannerUrl", "txHash", "network", "blockchainMetaMap", "baseUrl", "getNextStep", "currentStep", "getCurrentAddressOf", "result", "getRelatedWallet", "walletAddress", "walletKV", "k", "v", "wallet", "walletType", "getRelatedWalletOrNull", "getUsdPrice", "symbol", "address", "allTokens", "t", "getUsdFeeOfStep", "totalFeeInUsd", "BigNumber", "i", "fee", "unitPrice", "calculatePendingSwap", "inputAmount", "bestRoute", "wallets", "settings", "validateBalanceOrFee", "meta", "simulationResult", "index", "numberToString", "Sentry", "logRPCError", "error", "swap", "currentStep", "walletType", "e", "__name", "RangoClient", "rango", "httpService", "__name", "RangoClient", "getConfig", "mitt", "createSteps", "swapSteps", "swapStep", "diagnosisUrl", "estimatedTimeInSeconds", "explorerUrl", "feeInUsd", "executedTransactionId", "executedTransactionTime", "expectedOutputAmountHumanReadable", "fromBlockchain", "toBlockchain", "fromSymbol", "toSymbol", "fromSymbolAddress", "toSymbolAddress", "swapperType", "swapperId", "outputAmount", "fromAmountMaxValue", "fromAmountMinValue", "fromAmountPrecision", "fromAmountRestrictionType", "fromDecimals", "stepStatus", "getCurrentStepTx", "__name", "getEventPayload", "swap", "type", "creationTime", "finishTime", "requestId", "inputAmount", "status", "wallets", "steps", "settings", "routeSteps", "result", "failedStep", "getFailedStep", "lastSuccessfulStep", "getLastSuccessfulStep", "eventEmitter", "mitt", "emitRouteEvent", "stepEvent", "route", "routeEvent", "emitStepEvent", "step", "notifier", "params", "event", "fromAsset", "toAsset", "currentFromBlockchain", "getCurrentBlockchainOfOrNull", "message", "messageSeverity", "isApprovalCurrentStepTx", "swapClaimedBy", "claimQueue", "queue_id", "__name", "swapTransactionToDataMap", "inMemoryTransactionsData", "hash", "data", "splitWalletNetwork", "input", "splittedInput", "network", "walletNetwork", "getCurrentStep", "swap", "step", "getCurrentStepTx", "currentStep", "evmTransaction", "evmApprovalTransaction", "cosmosTransaction", "solanaTransaction", "transferTransaction", "starknetApprovalTransaction", "starknetTransaction", "tronApprovalTransaction", "tronTransaction", "tonTransaction", "setCurrentStepTx", "transaction", "txType", "TransactionType", "x", "getCurrentStepTxType", "isApprovalCurrentStepTx", "updateSwapStatus", "getStorage", "setStorage", "nextStatus", "nextStepStatus", "message", "details", "errorCode", "hasAlreadyProceededToSign", "updatedResult", "errorReason", "walletType", "getRelatedWalletOrNull", "failureType", "mapAppErrorCodesToAPIErrorCode", "httpService", "setStepTransactionIds", "txId", "explorerUrl", "notifier", "markRunningSwapAsWaitingForConnectingWallet", "reason", "reasonDetail", "currentTime", "markRunningSwapAsSwitchingNetwork", "type", "getRequiredWallet", "fromBlockchain", "getCurrentBlockchainOf", "markRunningSwapAsDependsOnOtherQueues", "delay", "ms", "res", "getSwapWalletType", "isWalletNull", "wallet", "getEvmProvider", "providers", "Networks", "bcName", "getCurrentBlockchainOfOrNull", "sourceWallet", "getChainId", "provider", "isNetworkMatchedForTransaction", "meta", "fromBlockChain", "evmBlochain", "chainId", "blockChain", "getBlockChainNameFromId", "blockchainMeta", "e", "isTxAlreadyCreated", "resetNetworkStatus", "actions", "updateNetworkStatus", "status", "onBlockForConnectWallet", "event", "context", "queue", "ok", "isRequiredWalletConnected", "address", "ERROR_MESSAGE_WAIT_FOR_WALLET", "onBlockForChangeNetwork", "_event", "result", "requiredNetwork", "requiredWallet", "currentNetwork", "error", "onDependsOnOtherQueues", "getBlockedTasks", "forceExecute", "manager", "setClaimer", "claimedBy", "reset", "blockedTasks", "task", "claimerId", "isClaimedByAnyQueue", "claimedStorage", "retryOn", "getState", "walletState", "accounts", "connected", "connectedAccounts", "account", "accountAddress", "readAccountAddress", "singTransaction", "setTransactionDataByHash", "failed", "next", "schedule", "getSigners", "isMobileWallet", "getRelatedWallet", "mobileWallet", "walletAddress", "getCurrentAddressOf", "walletSigners", "currentStepBlockchain", "onFinish", "tx", "isApproval", "extraMessage", "updateResult", "eventType", "DEFAULT_ERROR_CODE", "response", "getScannerUrl", "extraMessageDetail", "extraMessageErrorCode", "prettifyErrorMessage", "logRPCError", "checkWaitingForConnectWalletChange", "params", "wallet_network", "evmChains", "chain", "q", "queueStorage", "currentStepRequiredWallet", "hasWaitingForConnect", "taskId", "Status", "queueInstance", "description", "ERROR_MESSAGE_WAIT_FOR_CHANGE_NETWORK", "checkWaitingForNetworkChange", "ERROR_MESSAGE_WAIT_FOR_WALLET_DESCRIPTION", "getRunningSwaps", "queues", "resetRunningSwapNotifsOnPageLoad", "runningSwaps", "eventSubtype", "canSwitchNetworkTo", "options", "walletAndNetworkMatched", "onlyWalletMatched", "finalQueueToBeRun", "i", "currentQueue", "isNeedBlockQueueForParallel", "throwOnOK", "rawResponse", "responseBody", "PrettyError", "cancelSwap", "getLastSuccessfulStep", "steps", "getFailedStep", "isApprovalTX", "INTERVAL_FOR_CHECK", "checkTransactionStatus", "getStorage", "setStorage", "next", "schedule", "retry", "failed", "context", "swap", "meta", "currentStep", "getCurrentStep", "tx", "getCurrentStepTx", "txId", "explorerUrlToUpdate", "getTxReceiptFailed", "status", "signer", "getTransactionDataByHash", "setTransactionDataByHash", "inMemoryTransactionsData", "txType", "getCurrentStepTxType", "sourceWallet", "getRelatedWallet", "txResponse", "receiptReceived", "chainId", "updatedTxHash", "updatedTxResponse", "currentStepBlockchain", "getCurrentBlockchainOf", "explorerUrl", "getScannerUrl", "error", "extraMessage", "extraMessageDetail", "extraMessageErrorCode", "prettifyErrorMessage", "updateResult", "updateSwapStatus", "notifier", "DEFAULT_ERROR_CODE", "httpService", "delay", "outputAmount", "prevOutputAmount", "newTransaction", "setCurrentStepTx", "nextStep", "getNextStep", "__name", "checkApprovalStatus", "isApproved", "response", "message", "details", "checkStatus", "actions", "resetNetworkStatus", "createTransaction", "actions", "setStorage", "getStorage", "next", "schedule", "swap", "currentStep", "getCurrentStep", "getCurrentStepTx", "notifier", "request", "transaction", "throwOnOK", "httpService", "setCurrentStepTx", "error", "extraMessage", "extraMessageDetail", "prettifyErrorMessage", "updateResult", "updateSwapStatus", "DEFAULT_ERROR_CODE", "__name", "executeTransaction", "actions", "getStorage", "context", "meta", "wallets", "providers", "claimedBy", "claimQueue", "isClaimed", "requestBlock", "__name", "blockedFor", "swap", "currentStep", "getCurrentStep", "resetNetworkStatus", "isRequiredWalletConnected", "type", "address", "getRequiredWallet", "isWalletInCompatible", "w", "account", "description", "ERROR_MESSAGE_WAIT_FOR_WALLET_DESCRIPTION", "ERROR_MESSAGE_WAIT_FOR_WALLET_DESCRIPTION_WRONG_WALLET", "networkMatched", "isNetworkMatchedForTransaction", "details", "ERROR_MESSAGE_DEPENDS_ON_OTHER_QUEUES", "updateNetworkStatus", "fromBlockchain", "getCurrentBlockchainOf", "ERROR_MESSAGE_WAIT_FOR_CHANGE_NETWORK", "isNeedBlockQueueForParallel", "singTransaction", "scheduleNextStep", "schedule", "next", "failed", "setStorage", "getStorage", "swap", "currentStep", "getCurrentStep", "isFailed", "step", "isTxAlreadyCreated", "notifier", "getLastSuccessfulStep", "__name", "start", "schedule", "next", "getStorage", "swap", "notifier", "__name", "swapQueueDef", "start", "scheduleNextStep", "createTransaction", "executeTransaction", "checkStatus", "event", "meta", "onBlockForConnectWallet", "onBlockForChangeNetwork", "onDependsOnOtherQueues", "useManager", "useEffect", "useState", "Persistor", "Status", "DB_NAME", "uuid", "MIGRATED_KEY", "migrated", "__name", "hasQueueManagerOnIDB", "db", "DB_NAME", "migration", "swapsFromStorage", "hasIndexDB", "swaps", "convertedSwaps", "swap", "taskId", "uuid", "convertedSwap", "Status", "status", "persistor", "Persistor", "promises", "queue", "isCalled", "useMigration", "isMigrated", "migrated", "status", "setStatus", "useState", "useEffect", "migration", "__name", "useQueueManager", "params", "manager", "useManager", "checkWaitingForConnectWalletChange", "retryOn", "checkWaitingForNetworkChange", "useEvents", "eventEmitter", "makeQueueDefinition", "configs", "initConfig", "swapQueueDef", "__name"]
}
