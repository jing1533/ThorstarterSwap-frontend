{
  "version": 3,
  "sources": ["../src/provider.tsx", "../src/state.ts"],
  "sourcesContent": ["import type { ManagerContext, ManagerState } from './types';\nimport type {\n  ManagerContext as Context,\n  Events,\n  QueueDef,\n} from '@rango-dev/queue-manager-core';\nimport type { PropsWithChildren } from 'react';\n\nimport { Manager } from '@rango-dev/queue-manager-core';\nimport React, {\n  createContext,\n  useContext,\n  useEffect,\n  useLayoutEffect,\n  useMemo,\n  useRef,\n  useState,\n} from 'react';\n\nimport { initState as initManagerState, useManagerState } from './state';\n\nconst ManagerCtx = createContext<{\n  manager: ManagerContext;\n  state: ManagerState;\n}>({\n  manager: undefined,\n  state: initManagerState,\n});\n\ninterface PropTypes {\n  queuesDefs: QueueDef<any, any, any>[];\n  context: Context;\n  onPersistedDataLoaded?: Events['onPersistedDataLoaded'];\n  isPaused?: boolean;\n}\n\nfunction Provider(props: PropsWithChildren<PropTypes>) {\n  // TODO: this is not a proper way but i don't want to change the context interface atm.\n  const [, forceRender] = useState({});\n  const { state, update } = useManagerState();\n  const context = useRef(props.context);\n\n  const manager = useMemo<Manager>(() => {\n    return new Manager({\n      queuesDefs: props.queuesDefs,\n      events: {\n        onStorageUpdate: () => {\n          forceRender({});\n        },\n        onCreateQueue: () => {\n          forceRender({});\n        },\n        onCreateTask: () => {\n          forceRender({});\n        },\n        onUpdateQueue: () => {\n          forceRender({});\n        },\n        onUpdateTask: () => {\n          forceRender({});\n        },\n        onPersistedDataLoaded: (manager) => {\n          forceRender({});\n\n          if (props.onPersistedDataLoaded) {\n            props.onPersistedDataLoaded(manager);\n          }\n\n          /*\n           * This condition will make sure, we only update the `loadedFromPersistor`.\n           * But be aware `onPersistedDataLoaded` is calling after each `sync` which means can be called multiple times.\n           */\n          if (!state.loadedFromPersistor) {\n            update('loadedFromPersistor', true);\n          }\n        },\n        onTaskBlock: () => {\n          forceRender({});\n        },\n        onDeleteQueue: () => {\n          forceRender({});\n        },\n      },\n      context: context || {},\n      isPaused: props.isPaused,\n    });\n  }, []);\n\n  useLayoutEffect(() => {\n    context.current = props.context;\n  }, [props.context]);\n\n  useEffect(() => {\n    if (typeof props.isPaused !== 'undefined') {\n      if (props.isPaused) {\n        manager.pause();\n      } else {\n        manager.run();\n      }\n      forceRender({});\n    }\n  }, [props.isPaused]);\n\n  return (\n    // eslint-disable-next-line react/jsx-no-constructed-context-values\n    <ManagerCtx.Provider value={{ manager, state }}>\n      {props.children}\n    </ManagerCtx.Provider>\n  );\n}\n\nexport function useManager(): { manager: ManagerContext; state: ManagerState } {\n  const context = useContext(ManagerCtx);\n  if (!context) {\n    throw Error('useManager can only be used within the Provider component');\n  }\n  return context;\n}\n\nexport default Provider;\n", "import { useReducer } from 'react';\nimport { ManagerState } from './types';\n\ntype Update<T> = (name: keyof T, value: T[keyof T]) => void;\ntype Action<T> = { type: 'UPDATE'; name: keyof T; value: T[keyof T] };\n\nexport const initState: ManagerState = {\n  loadedFromPersistor: false,\n};\n\nfunction reducer(state: ManagerState, action: Action<ManagerState>) {\n  switch (action.type) {\n    case 'UPDATE':\n      return { ...state, [action.name]: action.value };\n    default:\n      return state;\n  }\n}\n\nexport function useManagerState(): {\n  state: ManagerState;\n  update: Update<ManagerState>;\n} {\n  const [state, dispatch] = useReducer(reducer, initState);\n\n  return {\n    state,\n    update: (name, value) => {\n      dispatch({\n        type: 'UPDATE',\n        name,\n        value,\n      });\n    },\n  };\n}\n"],
  "mappings": "+EAQA,OAAS,WAAAA,MAAe,gCACxB,OAAOC,GACL,iBAAAC,EACA,cAAAC,EACA,aAAAC,EACA,mBAAAC,EACA,WAAAC,EACA,UAAAC,EACA,YAAAC,MACK,QCjBP,OAAS,cAAAC,MAAkB,QAMpB,IAAMC,EAA0B,CACrC,oBAAqB,EACvB,EAEA,SAASC,EAAQC,EAAqBC,EAA8B,CAClE,OAAQA,EAAO,KAAM,CACnB,IAAK,SACH,MAAO,CAAE,GAAGD,EAAO,CAACC,EAAO,IAAI,EAAGA,EAAO,KAAM,EACjD,QACE,OAAOD,CACX,CACF,CAPSE,EAAAH,EAAA,WASF,SAASI,GAGd,CACA,GAAM,CAACH,EAAOI,CAAQ,EAAIC,EAAWN,EAASD,CAAS,EAEvD,MAAO,CACL,MAAAE,EACA,OAAQ,CAACM,EAAMC,IAAU,CACvBH,EAAS,CACP,KAAM,SACN,KAAAE,EACA,MAAAC,CACF,CAAC,CACH,CACF,CACF,CAhBgBL,EAAAC,EAAA,mBDEhB,IAAMK,EAAaC,EAGhB,CACD,QAAS,OACT,MAAOC,CACT,CAAC,EASD,SAASC,EAASC,EAAqC,CAErD,GAAM,CAAC,CAAEC,CAAW,EAAIC,EAAS,CAAC,CAAC,EAC7B,CAAE,MAAAC,EAAO,OAAAC,CAAO,EAAIC,EAAgB,EACpCC,EAAUC,EAAOP,EAAM,OAAO,EAE9BQ,EAAUC,EAAiB,IACxB,IAAIC,EAAQ,CACjB,WAAYV,EAAM,WAClB,OAAQ,CACN,gBAAiB,IAAM,CACrBC,EAAY,CAAC,CAAC,CAChB,EACA,cAAe,IAAM,CACnBA,EAAY,CAAC,CAAC,CAChB,EACA,aAAc,IAAM,CAClBA,EAAY,CAAC,CAAC,CAChB,EACA,cAAe,IAAM,CACnBA,EAAY,CAAC,CAAC,CAChB,EACA,aAAc,IAAM,CAClBA,EAAY,CAAC,CAAC,CAChB,EACA,sBAAwBO,GAAY,CAClCP,EAAY,CAAC,CAAC,EAEVD,EAAM,uBACRA,EAAM,sBAAsBQ,CAAO,EAOhCL,EAAM,qBACTC,EAAO,sBAAuB,EAAI,CAEtC,EACA,YAAa,IAAM,CACjBH,EAAY,CAAC,CAAC,CAChB,EACA,cAAe,IAAM,CACnBA,EAAY,CAAC,CAAC,CAChB,CACF,EACA,QAASK,GAAW,CAAC,EACrB,SAAUN,EAAM,QAClB,CAAC,EACA,CAAC,CAAC,EAEL,OAAAW,EAAgB,IAAM,CACpBL,EAAQ,QAAUN,EAAM,OAC1B,EAAG,CAACA,EAAM,OAAO,CAAC,EAElBY,EAAU,IAAM,CACV,OAAOZ,EAAM,SAAa,MACxBA,EAAM,SACRQ,EAAQ,MAAM,EAEdA,EAAQ,IAAI,EAEdP,EAAY,CAAC,CAAC,EAElB,EAAG,CAACD,EAAM,QAAQ,CAAC,EAIjBa,EAAA,cAACjB,EAAW,SAAX,CAAoB,MAAO,CAAE,QAAAY,EAAS,MAAAL,CAAM,GAC1CH,EAAM,QACT,CAEJ,CAzESc,EAAAf,EAAA,YA2EF,SAASgB,GAA+D,CAC7E,IAAMT,EAAUU,EAAWpB,CAAU,EACrC,GAAI,CAACU,EACH,MAAM,MAAM,2DAA2D,EAEzE,OAAOA,CACT,CANgBQ,EAAAC,EAAA,cAQhB,IAAOE,EAAQlB",
  "names": ["Manager", "React", "createContext", "useContext", "useEffect", "useLayoutEffect", "useMemo", "useRef", "useState", "useReducer", "initState", "reducer", "state", "action", "__name", "useManagerState", "dispatch", "useReducer", "name", "value", "ManagerCtx", "createContext", "initState", "Provider", "props", "forceRender", "useState", "state", "update", "useManagerState", "context", "useRef", "manager", "useMemo", "Manager", "useLayoutEffect", "useEffect", "React", "__name", "useManager", "useContext", "provider_default"]
}
