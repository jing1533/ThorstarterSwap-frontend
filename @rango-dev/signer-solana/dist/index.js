var w=Object.defineProperty;var t=(n,a)=>w(n,"name",{value:a,configurable:!0});import{Connection as E,PublicKey as l,Transaction as g,TransactionInstruction as b,VersionedTransaction as P}from"@solana/web3.js";import{SignerError as d,SignerErrorCode as f}from"rango-types";async function m(n,a,o,i=null){let r=a;for(;r>0;)try{let e=await Promise.race([n,new Promise((c,s)=>setTimeout(()=>s(new Error("timeout")),o))]);if(r>1&&i!=null&&!i(e))throw new Error("bad result");return e}catch(e){console.log("cant get result. time="+new Date().toLocaleTimeString()+" i="+r+" , err=",e),r--}throw new d(f.SEND_TX_ERROR,"function reached max retry count")}t(m,"retryPromise");function R(n){let a=Math.floor(Math.random()*9e3)+1e3;return"failed::"+n.identifier+"::"+a}t(R,"getFailedHash");var _=!process.env.NODE_ENV||process.env.NODE_ENV==="development",k=_?"https://fluent-still-scion.solana-mainnet.discover.quiknode.pro/fc8be9b8ac7aea382ec591359628e16d8c52ef6a/":"https://icy-crimson-wind.solana-mainnet.quiknode.pro/c83f94ebeb39a6d6a9d2ab03d4cba2c2af83c5c0/";function T(){return new E(k,{commitment:"confirmed",disableRetryOnRateLimit:!1})}t(T,"getSolanaConnection");function v(n){return new Promise(async function(a,o){let i=3,r=!1;for(;i>0;){try{let e=await T().confirmTransaction(n);if(e&&e.value&&e.value.err==null){r=!0;break}else i===1&&e&&e.value&&e.value.err&&o(e.value.err)}catch(e){i===1&&o(e)}i-=1}a(r)})}t(v,"confirmTx");var h=t(async(n,a)=>{let o=T(),i,r;if(n.serializedMessage!=null)if(n.txType==="VERSIONED"){i=P.deserialize(new Uint8Array(n.serializedMessage));let e=(await m(o.getLatestBlockhash("confirmed"),5,1e4)).blockhash;e&&(i.message.recentBlockhash=e)}else n.txType==="LEGACY"&&(r=g.from(Buffer.from(new Uint8Array(n.serializedMessage))),r.feePayer=new l(n.from),r.recentBlockhash=void 0);else r=new g,r.feePayer=new l(n.from),n.recentBlockhash?r.recentBlockhash=n.recentBlockhash:r.recentBlockhash=(await m(o.getLatestBlockhash("confirmed"),5,1e4)).blockhash,n.instructions.forEach(e=>{r?.add(new b({keys:e.keys.map(c=>({pubkey:new l(c.pubkey),isSigner:c.isSigner,isWritable:c.isWritable})),programId:new l(e.programId),data:Buffer.from(e.data)}))}),n.signatures.forEach(function(e){let c=Buffer.from(new Uint8Array(e.signature)),s=new l(e.publicKey);r?.addSignature(s,c)});try{let e;if(r)e=r;else if(i)e=i;else throw new Error("error creating transaction");let c=await a(e),s=await m(o.sendRawTransaction(c),2,3e4);if(!s)throw new Error("tx cant send to blockchain. signature="+s);if(!await v(s))throw new Error("tx cant confirm on blockchain. signature="+s);return s}catch(e){if(e&&d.isSignerError(e)&&e.code===f.REJECTED_BY_USER)throw e;if(e&&e.hasOwnProperty("code")&&e.code===4001)throw new d(f.REJECTED_BY_USER,void 0,e);return R(n)}},"generalSolanaTransactionExecutor");async function y(n,a){return await h(n,t(async i=>{try{return(await a.signTransaction(i)).serialize()}catch(r){throw new d(f.SIGN_TX_ERROR,void 0,r)}},"DefaultSolanaSigner"))}t(y,"executeSolanaTransaction");import{SignerError as p,SignerErrorCode as S}from"rango-types";var u=class{constructor(a){this.provider=a}async signMessage(a){try{let o=new TextEncoder().encode(a),{signature:i}=await this.provider.request({method:"signMessage",params:{message:o}});return i}catch(o){throw new p(S.SIGN_TX_ERROR,void 0,o)}}async signAndSendTx(a){try{return{hash:await y(a,this.provider)}}catch(o){throw new p(S.SEND_TX_ERROR,void 0,o)}}};t(u,"DefaultSolanaSigner");export{u as DefaultSolanaSigner,h as generalSolanaTransactionExecutor};
//# sourceMappingURL=index.js.map
