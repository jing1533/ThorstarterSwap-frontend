var S=Object.defineProperty;var s=(i,t)=>S(i,"name",{value:t,configurable:!0});var m=(a=>(a.CONNECTED="connected",a.CONNECTING="connecting",a.REACHABLE="reachable",a.INSTALLED="installed",a.ACCOUNTS="accounts",a.NETWORK="network",a))(m||{});var d=class{getItem(t){let e=localStorage.getItem(t);return e?JSON.parse(e):null}setItem(t,e){localStorage.setItem(t,JSON.stringify(e))}removeItem(t){localStorage.removeItem(t)}};s(d,"Persistor");function N(i,t){return`${t||""}:${i}`}s(N,"formatAddressWithNetwork");function u(i,t){return i?i.map(e=>N(e,t)):[]}s(u,"accountAddressesWithNetwork");function T(i){let[t,e]=i.split(":");return{network:t,address:e}}s(T,"readAccountAddress");function f(i){let{checkInstallation:t=!0}=i.config;return t}s(f,"needsCheckInstallation");import{getBlockChainNameFromId as w,Networks as h}from"@rango-dev/wallets-shared";var k=class{constructor(t,e){this.actions=e,this.options=t,this.provider=null,this.meta=[],this.state={connected:!1,connecting:!1,reachable:!1,installed:!1,accounts:null,network:null},f(t)||this.setInstalledAs(!0)}async getConnectionFromState(){return this.state.connected&&this.provider?{accounts:this.state.accounts,network:this.state.network,provider:this.provider}:null}async connect(t){if(this.state.connecting)throw new Error("Connecting...");let e=await this.getConnectionFromState(),n=this.state.network,o=t||n||this.options.config.defaultNetwork;if(e){let l=n!==o&&!!o;if(n===o)return e;let r=!0;if(this.actions.canSwitchNetworkTo&&(r=this.actions.canSwitchNetworkTo({provider:this.provider,meta:this.meta,network:o||""})),l&&r&&this.actions.switchNetwork)return await this.actions.switchNetwork({instance:this.provider,meta:this.meta,network:o,newInstance:this.tryGetInstance.bind(this)}),o!==this.state.network&&this.updateState({network:t}),{accounts:e.accounts,network:o,provider:this.provider}}let c=await this.tryGetInstance({network:t});this.updateState({connecting:!0}),this.setInstalledAs(!0);try{var a=await this.actions.connect({instance:c,network:o||void 0,meta:this.meta||[]})}catch(l){throw this.resetState(),l}this.updateState({connected:!0,reachable:!0,connecting:!1});let p=[],g=null;if(Array.isArray(a))p=a.flatMap(r=>{let y=r.chainId||h.Unknown,I=w(y,this.meta)||h.Unknown;return u(r.accounts,I)}).filter(Boolean),g=o||this.options.config.defaultNetwork;else{let l=a.chainId||h.Unknown,r=w(l,this.meta)||h.Unknown;p=u(a.accounts,r),g=r}return p.length>0&&this.updateState({accounts:p,network:g}),{accounts:this.state.accounts,network:this.state.network,provider:this.provider}}async disconnect(){this.resetState(),this.actions.disconnect&&this.actions.disconnect({instance:this.provider,destroyInstance:()=>{this.setProvider(null)}})}async eagerConnect(){let t=await this.tryGetInstance({network:void 0}),{canEagerConnect:e}=this.actions,n=`can't restore connection for ${this.options.config.type} .`;if(e){if(await e({instance:t,meta:this.meta}))return this.connect();throw new Error(n)}else throw new Error(n)}getSigners(t){return this.actions.getSigners(t)}getWalletInfo(t){return this.actions.getWalletInfo(t)}canSwitchNetworkTo(t,e){let n=this.actions.canSwitchNetworkTo;return n?n({network:t,meta:this.meta,provider:e}):!1}onInit(){this.options.config.isAsyncInstance?f(this.options)&&this.actions.getInstance().then(t=>{t&&this.setInstalledAs(!0)}):this.actions.getInstance()&&!this.state.installed&&this.setInstalledAs(!0)}setProvider(t){this.provider=t,t&&this.actions.subscribe&&this.actions.subscribe({instance:t,state:this.state,meta:this.meta,connect:this.connect.bind(this),disconnect:this.disconnect.bind(this),updateAccounts:(e,n)=>{let o=this.state.network;n&&(o=w(n,this.meta)||h.Unknown);let c=u(e,o);c.length>0&&this.updateState({accounts:c})},updateChainId:this.updateChainId.bind(this)})}setMeta(t){this.meta=t}setHandler(t){this.options.handler=t}getState(){return this.state}updateState(t){let e=[];typeof t.connected<"u"&&(this.state.connected=t.connected,e.push(["connected",t.connected])),typeof t.connecting<"u"&&(this.state.connecting=t.connecting,e.push(["connecting",t.connecting])),typeof t.reachable<"u"&&(this.state.reachable=t.reachable,e.push(["reachable",t.reachable])),typeof t.installed<"u"&&(this.state.installed=t.installed,e.push(["installed",t.installed])),typeof t.accounts<"u"&&(this.state.accounts=t.accounts,e.push(["accounts",t.accounts])),typeof t.network<"u"&&(this.state.network=t.network,e.push(["network",t.network]));let n=this.getState();e.forEach(([o,c])=>{this.options.handler(this.options.config.type,o,c,n,this.meta)})}resetState(){this.updateState({connected:!1,connecting:!1,reachable:!1,accounts:null,network:null})}updateChainId(t){let e=t?w(t,this.meta):h.Unknown;this.updateState({network:e})}setInstalledAs(t){!f(this.options)&&t===!1||this.updateState({installed:t})}async tryGetInstance({network:t,force:e}){let n=null;if(this.setProvider(null),this.options.config.isAsyncInstance){let o={currentProvider:this.provider,meta:this.meta,force:e||!1,updateChainId:this.updateChainId.bind(this),getState:this.getState.bind(this)};t&&(o.network=t),n=await this.actions.getInstance(o)}else n=this.actions.getInstance();if(!n){this.setInstalledAs(!1),this.resetState();let o=`It seems your selected wallet (${this.options.config.type}) isn't installed.`;throw new Error(o)}return this.setProvider(n),n}};s(k,"Wallet");var v=k;export{m as Events,d as Persistor,u as accountAddressesWithNetwork,v as default,N as formatAddressWithNetwork,f as needsCheckInstallation,T as readAccountAddress};
//# sourceMappingURL=index.js.map
